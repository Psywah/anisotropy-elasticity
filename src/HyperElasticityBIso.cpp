// This code conforms with the UFC specification version 2017.2.0.dev0
// and was automatically generated by FFC version 2017.2.0.dev0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   add_tabulate_tensor_timing:     False
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   eliminate_zeros:                True
//   epsilon:                        1e-14
//   error_control:                  False
//   external_include_dirs:          ''
//   external_includes:              ''
//   external_libraries:             ''
//   external_library_dirs:          ''
//   form_postfix:                   True
//   format:                         'dolfin'
//   generate_dummy_tabulate_tensor: False
//   max_signature_length:           0
//   optimize:                       True
//   precision:                      None
//   precompute_basis_const:         True
//   precompute_ip_const:            True
//   quadrature_degree:              1
//   quadrature_rule:                None
//   representation:                 'auto'
//   split:                          True

#include "HyperElasticityBIso.h"

hyperelasticitybiso_finite_element_0::hyperelasticitybiso_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

hyperelasticitybiso_finite_element_0::~hyperelasticitybiso_finite_element_0()
{
    // Do nothing
}

const char * hyperelasticitybiso_finite_element_0::signature() const
{
    return "FiniteElement('Real', tetrahedron, 0)";
}

ufc::shape hyperelasticitybiso_finite_element_0::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t hyperelasticitybiso_finite_element_0::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_0::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_0::space_dimension() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_0::value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_0::degree() const
{
    return 0;
}

const char * hyperelasticitybiso_finite_element_0::family() const
{
    return "Real";
}

void hyperelasticitybiso_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
}

void hyperelasticitybiso_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
}

void hyperelasticitybiso_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void hyperelasticitybiso_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    
    // Compute subdeterminants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
}

void hyperelasticitybiso_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
}

void hyperelasticitybiso_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
}

void hyperelasticitybiso_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
}

double hyperelasticitybiso_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
}

void hyperelasticitybiso_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
    y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
    y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
}

void hyperelasticitybiso_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
    vertex_values[3] = dof_values[0];
}

void hyperelasticitybiso_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
}

void hyperelasticitybiso_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[3] = { 0.25, 0.25, 0.25 };
    std::copy_n(dof_X, 3, reference_dof_coordinates);
}

std::size_t hyperelasticitybiso_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * hyperelasticitybiso_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * hyperelasticitybiso_finite_element_0::create() const
{
    return new hyperelasticitybiso_finite_element_0();
}


hyperelasticitybiso_finite_element_1::hyperelasticitybiso_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

hyperelasticitybiso_finite_element_1::~hyperelasticitybiso_finite_element_1()
{
    // Do nothing
}

const char * hyperelasticitybiso_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Real', tetrahedron, 0), dim=3)";
}

ufc::shape hyperelasticitybiso_finite_element_1::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t hyperelasticitybiso_finite_element_1::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_1::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_1::space_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t hyperelasticitybiso_finite_element_1::value_size() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t hyperelasticitybiso_finite_element_1::reference_value_size() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_1::degree() const
{
    return 0;
}

const char * hyperelasticitybiso_finite_element_1::family() const
{
    return "Real";
}

void hyperelasticitybiso_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points * 3 * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[3 * 3 * ip] += coefficients0[0][0] * basisvalues0[0];
        reference_values[3 * 3 * ip + 3 + 1] += coefficients0[0][0] * basisvalues0[0];
        reference_values[3 * 3 * ip + 3 * 2 + 2] += coefficients0[0][0] * basisvalues0[0];
    }
}

void hyperelasticitybiso_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives * 3, 0.0);
    if (order > 0)
        return;
}

void hyperelasticitybiso_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    std::fill_n(values, num_points * 3 * 3, 0.0);
    const std::size_t reference_offsets[3] = { 0, 1, 2 };
    const std::size_t physical_offsets[3] = { 0, 1, 2 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * 3 * ip + 3 * d + 3 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[3 * 3 * ip + 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void hyperelasticitybiso_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    
    // Compute subdeterminants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[1] = {0.0};
      
      // Declare helper variables
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      
      // Table(s) of coefficients
      static const double coefficients0[1] = \
      {1.0};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 1; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[1] = {0.0};
      
      // Declare helper variables
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      
      // Table(s) of coefficients
      static const double coefficients0[1] = \
      {1.0};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 1; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[1] = {0.0};
      
      // Declare helper variables
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      
      // Table(s) of coefficients
      static const double coefficients0[1] = \
      {1.0};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 1; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
}

void hyperelasticitybiso_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
}

void hyperelasticitybiso_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
}

void hyperelasticitybiso_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[3];
    for (unsigned int r = 0; r < 3; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
}

double hyperelasticitybiso_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 2:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
}

void hyperelasticitybiso_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
    y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
    y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    values[1] = vals[1];
    values[2] = vals[2];
}

void hyperelasticitybiso_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[0];
    vertex_values[6] = dof_values[0];
    vertex_values[9] = dof_values[0];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[1];
    vertex_values[4] = dof_values[1];
    vertex_values[7] = dof_values[1];
    vertex_values[10] = dof_values[1];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[2];
    vertex_values[5] = dof_values[2];
    vertex_values[8] = dof_values[2];
    vertex_values[11] = dof_values[2];
}

void hyperelasticitybiso_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 2] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 2 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 2 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
}

void hyperelasticitybiso_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[9] = { 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25 };
    std::copy_n(dof_X, 9, reference_dof_coordinates);
}

std::size_t hyperelasticitybiso_finite_element_1::num_sub_elements() const
{
    return 3;
}

ufc::finite_element * hyperelasticitybiso_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_0();
    case 1:
        return new hyperelasticitybiso_finite_element_0();
    case 2:
        return new hyperelasticitybiso_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * hyperelasticitybiso_finite_element_1::create() const
{
    return new hyperelasticitybiso_finite_element_1();
}


hyperelasticitybiso_finite_element_2::hyperelasticitybiso_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

hyperelasticitybiso_finite_element_2::~hyperelasticitybiso_finite_element_2()
{
    // Do nothing
}

const char * hyperelasticitybiso_finite_element_2::signature() const
{
    return "FiniteElement('Lagrange', tetrahedron, 1)";
}

ufc::shape hyperelasticitybiso_finite_element_2::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t hyperelasticitybiso_finite_element_2::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_2::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_2::space_dimension() const
{
    return 4;
}

std::size_t hyperelasticitybiso_finite_element_2::value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_2::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_2::value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_2::reference_value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_2::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_2::reference_value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_2::degree() const
{
    return 1;
}

const char * hyperelasticitybiso_finite_element_2::family() const
{
    return "Lagrange";
}

void hyperelasticitybiso_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    for (std::size_t k = 0; k < num_points * 4; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= 0.8660254037844386;
        basisvalues1[3] *= 1.118033988749895;
        basisvalues1[2] *= 1.5811388300841898;
        basisvalues1[1] *= 2.7386127875258306;
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 3] += coefficients3[0][r] * basisvalues1[r];
    }
}

void hyperelasticitybiso_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 4 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][4][4] =
        { { { 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336758, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 5.477225575051663, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 1.8257418583505545, 0.0, 0.0, 0.0 },
            { 5.163977794943224, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    const std::size_t reference_offset[4] = {};
    const std::size_t num_components[4] = { 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= 0.8660254037844386;
        basisvalues1[3] *= 1.118033988749895;
        basisvalues1[2] *= 1.5811388300841898;
        basisvalues1[1] *= 2.7386127875258306;
        double aux_dmats0_basisvalues1[4] = {};
        for (std::size_t r = 0; r < num_derivatives; ++r)
        {
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4];
            // Initialize dmats.
            std::size_t comb = combinations[order - 1][r][0];
            for (std::size_t t = 0; t < 4; ++t)
                for (std::size_t u = 0; u < 4; ++u)
                    dmats[t][u] = dmats0[comb][t][u];
            // Looping derivative order to generate dmats.
            for (std::size_t s = 1; s < order; ++s)
            {
                // Store previous dmats matrix.
                double dmats_old[4][4];
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        dmats_old[t][u] = dmats[t][u];
                // Resetting dmats.
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        dmats[t][u] = 0.0;
                // Update dmats using an inner product.
                comb = combinations[order - 1][r][s];
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        for (std::size_t tu = 0; tu < 4; ++tu)
                            dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
            }
            for (std::size_t s = 0; s < 4; ++s)
                for (std::size_t t = 0; t < 4; ++t)
                    aux_dmats0_basisvalues1[s] += dmats[s][t] * basisvalues1[t];
        }
        // Loop over all dofs
        for (std::size_t i = 0; i < 4; ++i)
        {
            double derivatives[3];
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[4 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void hyperelasticitybiso_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    std::fill_n(values, num_points * 4 * num_derivatives, 0.0);
    const std::size_t reference_offsets[4] = {};
    const std::size_t physical_offsets[4] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[3][3];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 4; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[4 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[4 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void hyperelasticitybiso_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
}

void hyperelasticitybiso_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 4; r++)
    {
      evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
}

void hyperelasticitybiso_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[3][1];
    for (unsigned int row = 0; row < 3; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K[0], K[1], K[2]}, {K[3], K[4], K[5]}, {K[6], K[7], K[8]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[3][3];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
}

void hyperelasticitybiso_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 4; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[3];
    for (unsigned int r = 0; r < 3; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 4; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
}

double hyperelasticitybiso_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
}

void hyperelasticitybiso_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
}

void hyperelasticitybiso_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
}

void hyperelasticitybiso_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
}

void hyperelasticitybiso_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[12] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
}

std::size_t hyperelasticitybiso_finite_element_2::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * hyperelasticitybiso_finite_element_2::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * hyperelasticitybiso_finite_element_2::create() const
{
    return new hyperelasticitybiso_finite_element_2();
}


hyperelasticitybiso_finite_element_3::hyperelasticitybiso_finite_element_3() : ufc::finite_element()
{
    // Do nothing
}

hyperelasticitybiso_finite_element_3::~hyperelasticitybiso_finite_element_3()
{
    // Do nothing
}

const char * hyperelasticitybiso_finite_element_3::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

ufc::shape hyperelasticitybiso_finite_element_3::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t hyperelasticitybiso_finite_element_3::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_3::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_3::space_dimension() const
{
    return 12;
}

std::size_t hyperelasticitybiso_finite_element_3::value_rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_3::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t hyperelasticitybiso_finite_element_3::value_size() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_3::reference_value_rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_3::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t hyperelasticitybiso_finite_element_3::reference_value_size() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_3::degree() const
{
    return 1;
}

const char * hyperelasticitybiso_finite_element_3::family() const
{
    return "Lagrange";
}

void hyperelasticitybiso_finite_element_3::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    for (std::size_t k = 0; k < num_points * 12 * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= 0.8660254037844386;
        basisvalues1[3] *= 1.118033988749895;
        basisvalues1[2] *= 1.5811388300841898;
        basisvalues1[1] *= 2.7386127875258306;
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 3] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 4 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 5 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 6 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 7 + 1] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 8 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 9 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 10 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 11 + 2] += coefficients3[0][r] * basisvalues1[r];
    }
}

void hyperelasticitybiso_finite_element_3::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 12 * num_derivatives * 3, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][4][4] =
        { { { 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336758, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 5.477225575051663, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 1.8257418583505545, 0.0, 0.0, 0.0 },
            { 5.163977794943224, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    const std::size_t reference_offset[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    const std::size_t num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= 0.8660254037844386;
        basisvalues1[3] *= 1.118033988749895;
        basisvalues1[2] *= 1.5811388300841898;
        basisvalues1[1] *= 2.7386127875258306;
        double aux_dmats0_basisvalues1[4] = {};
        for (std::size_t r = 0; r < num_derivatives; ++r)
        {
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4];
            // Initialize dmats.
            std::size_t comb = combinations[order - 1][r][0];
            for (std::size_t t = 0; t < 4; ++t)
                for (std::size_t u = 0; u < 4; ++u)
                    dmats[t][u] = dmats0[comb][t][u];
            // Looping derivative order to generate dmats.
            for (std::size_t s = 1; s < order; ++s)
            {
                // Store previous dmats matrix.
                double dmats_old[4][4];
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        dmats_old[t][u] = dmats[t][u];
                // Resetting dmats.
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        dmats[t][u] = 0.0;
                // Update dmats using an inner product.
                comb = combinations[order - 1][r][s];
                for (std::size_t t = 0; t < 4; ++t)
                    for (std::size_t u = 0; u < 4; ++u)
                        for (std::size_t tu = 0; tu < 4; ++tu)
                            dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
            }
            for (std::size_t s = 0; s < 4; ++s)
                for (std::size_t t = 0; t < 4; ++t)
                    aux_dmats0_basisvalues1[s] += dmats[s][t] * basisvalues1[t];
        }
        // Loop over all dofs
        for (std::size_t i = 0; i < 12; ++i)
        {
            double derivatives[3];
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux_dmats0_basisvalues1[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void hyperelasticitybiso_finite_element_3::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    std::fill_n(values, num_points * 12 * num_derivatives * 3, 0.0);
    const std::size_t reference_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    const std::size_t physical_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[3][3];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 12; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void hyperelasticitybiso_finite_element_3::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
}

void hyperelasticitybiso_finite_element_3::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
}

void hyperelasticitybiso_finite_element_3::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[3][1];
    for (unsigned int row = 0; row < 3; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K[0], K[1], K[2]}, {K[3], K[4], K[5]}, {K[6], K[7], K[8]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[3][3];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.1825741858350554, -0.105409255338946, -0.07453559924999298};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.1825741858350554, -0.105409255338946, -0.07453559924999296};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.210818510677892, -0.07453559924999299};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.2886751345948129, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.324555320336758, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {5.477225575051663, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.162277660168379, 0.0, 0.0, 0.0},
      {1.825741858350554, 0.0, 0.0, 0.0},
      {5.163977794943224, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
}

void hyperelasticitybiso_finite_element_3::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[9];
    for (unsigned int r = 0; r < 9; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
}

double hyperelasticitybiso_finite_element_3::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 5:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 6:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 9:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 10:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 11:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
}

void hyperelasticitybiso_finite_element_3::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    values[4] = vals[1];
    values[8] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    values[5] = vals[1];
    values[9] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    values[6] = vals[1];
    values[10] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    values[7] = vals[1];
    values[11] = vals[2];
}

void hyperelasticitybiso_finite_element_3::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[4] = dof_values[5];
    vertex_values[7] = dof_values[6];
    vertex_values[10] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[5] = dof_values[9];
    vertex_values[8] = dof_values[10];
    vertex_values[11] = dof_values[11];
}

void hyperelasticitybiso_finite_element_3::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 4] = coordinate_dofs[0];
    dof_coordinates[3 * 4 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 4 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 5] = coordinate_dofs[3];
    dof_coordinates[3 * 5 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 5 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 6] = coordinate_dofs[6];
    dof_coordinates[3 * 6 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 6 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 7] = coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 8] = coordinate_dofs[0];
    dof_coordinates[3 * 8 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 8 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 9] = coordinate_dofs[3];
    dof_coordinates[3 * 9 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 9 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 10] = coordinate_dofs[6];
    dof_coordinates[3 * 10 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 10 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 11] = coordinate_dofs[9];
    dof_coordinates[3 * 11 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 11 + 2] = coordinate_dofs[11];
}

void hyperelasticitybiso_finite_element_3::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[36] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 36, reference_dof_coordinates);
}

std::size_t hyperelasticitybiso_finite_element_3::num_sub_elements() const
{
    return 3;
}

ufc::finite_element * hyperelasticitybiso_finite_element_3::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_2();
    case 1:
        return new hyperelasticitybiso_finite_element_2();
    case 2:
        return new hyperelasticitybiso_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::finite_element * hyperelasticitybiso_finite_element_3::create() const
{
    return new hyperelasticitybiso_finite_element_3();
}


hyperelasticitybiso_finite_element_4::hyperelasticitybiso_finite_element_4() : ufc::finite_element()
{
    // Do nothing
}

hyperelasticitybiso_finite_element_4::~hyperelasticitybiso_finite_element_4()
{
    // Do nothing
}

const char * hyperelasticitybiso_finite_element_4::signature() const
{
    return "FiniteElement('Discontinuous Lagrange', tetrahedron, 0)";
}

ufc::shape hyperelasticitybiso_finite_element_4::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t hyperelasticitybiso_finite_element_4::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_4::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_finite_element_4::space_dimension() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_4::value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_4::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_4::value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_4::reference_value_rank() const
{
    return 0;
}

std::size_t hyperelasticitybiso_finite_element_4::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_4::reference_value_size() const
{
    return 1;
}

std::size_t hyperelasticitybiso_finite_element_4::degree() const
{
    return 0;
}

const char * hyperelasticitybiso_finite_element_4::family() const
{
    return "Discontinuous Lagrange";
}

void hyperelasticitybiso_finite_element_4::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
}

void hyperelasticitybiso_finite_element_4::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
}

void hyperelasticitybiso_finite_element_4::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void hyperelasticitybiso_finite_element_4::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    
    // Compute subdeterminants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
}

void hyperelasticitybiso_finite_element_4::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
}

void hyperelasticitybiso_finite_element_4::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
}

void hyperelasticitybiso_finite_element_4::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
}

double hyperelasticitybiso_finite_element_4::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
}

void hyperelasticitybiso_finite_element_4::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
    y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
    y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
}

void hyperelasticitybiso_finite_element_4::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
    vertex_values[3] = dof_values[0];
}

void hyperelasticitybiso_finite_element_4::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
}

void hyperelasticitybiso_finite_element_4::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[3] = { 0.25, 0.25, 0.25 };
    std::copy_n(dof_X, 3, reference_dof_coordinates);
}

std::size_t hyperelasticitybiso_finite_element_4::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * hyperelasticitybiso_finite_element_4::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * hyperelasticitybiso_finite_element_4::create() const
{
    return new hyperelasticitybiso_finite_element_4();
}


hyperelasticitybiso_dofmap_0::hyperelasticitybiso_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

hyperelasticitybiso_dofmap_0::~hyperelasticitybiso_dofmap_0()
{
    // Do nothing
}

const char * hyperelasticitybiso_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Real', tetrahedron, 0)";
}

bool hyperelasticitybiso_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = {};
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_0::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 1;
}

std::size_t hyperelasticitybiso_dofmap_0::num_global_support_dofs() const
{
    return 1;
}

std::size_t hyperelasticitybiso_dofmap_0::num_element_support_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_0::num_element_dofs() const
{
    return 1;
}

std::size_t hyperelasticitybiso_dofmap_0::num_facet_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 1 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 1 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void hyperelasticitybiso_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = 0;
}

void hyperelasticitybiso_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void hyperelasticitybiso_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

void hyperelasticitybiso_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

std::size_t hyperelasticitybiso_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * hyperelasticitybiso_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * hyperelasticitybiso_dofmap_0::create() const
{
    return new hyperelasticitybiso_dofmap_0();
}


hyperelasticitybiso_dofmap_1::hyperelasticitybiso_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

hyperelasticitybiso_dofmap_1::~hyperelasticitybiso_dofmap_1()
{
    // Do nothing
}

const char * hyperelasticitybiso_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Real', tetrahedron, 0), dim=3)";
}

bool hyperelasticitybiso_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { false, false, false, true };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_1::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_1::num_global_support_dofs() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_1::num_element_support_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_1::num_element_dofs() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_1::num_facet_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 3 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 3 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void hyperelasticitybiso_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset;
    offset += 1;
    dofs[1] = offset;
    offset += 1;
    dofs[2] = offset;
    offset += 1;
}

void hyperelasticitybiso_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void hyperelasticitybiso_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
}

void hyperelasticitybiso_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
}

std::size_t hyperelasticitybiso_dofmap_1::num_sub_dofmaps() const
{
    return 3;
}

ufc::dofmap * hyperelasticitybiso_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_0();
    case 1:
        return new hyperelasticitybiso_dofmap_0();
    case 2:
        return new hyperelasticitybiso_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_dofmap_1::create() const
{
    return new hyperelasticitybiso_dofmap_1();
}


hyperelasticitybiso_dofmap_2::hyperelasticitybiso_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

hyperelasticitybiso_dofmap_2::~hyperelasticitybiso_dofmap_2()
{
    // Do nothing
}

const char * hyperelasticitybiso_dofmap_2::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 1)";
}

bool hyperelasticitybiso_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, false, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_2::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t hyperelasticitybiso_dofmap_2::num_global_support_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_2::num_element_support_dofs() const
{
    return 4;
}

std::size_t hyperelasticitybiso_dofmap_2::num_element_dofs() const
{
    return 4;
}

std::size_t hyperelasticitybiso_dofmap_2::num_facet_dofs() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 0, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 2, 3, 4 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void hyperelasticitybiso_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
    dofs[3] = entity_indices[0][3];
}

void hyperelasticitybiso_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        break;
    }
}

void hyperelasticitybiso_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    }
}

void hyperelasticitybiso_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            break;
        }
        break;
    }
}

std::size_t hyperelasticitybiso_dofmap_2::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * hyperelasticitybiso_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * hyperelasticitybiso_dofmap_2::create() const
{
    return new hyperelasticitybiso_dofmap_2();
}


hyperelasticitybiso_dofmap_3::hyperelasticitybiso_dofmap_3() : ufc::dofmap()
{
    // Do nothing
}

hyperelasticitybiso_dofmap_3::~hyperelasticitybiso_dofmap_3()
{
    // Do nothing
}

const char * hyperelasticitybiso_dofmap_3::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

bool hyperelasticitybiso_dofmap_3::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, false, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_3::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_3::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 3 * num_global_entities[0];
}

std::size_t hyperelasticitybiso_dofmap_3::num_global_support_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_3::num_element_support_dofs() const
{
    return 12;
}

std::size_t hyperelasticitybiso_dofmap_3::num_element_dofs() const
{
    return 12;
}

std::size_t hyperelasticitybiso_dofmap_3::num_facet_dofs() const
{
    return 9;
}

std::size_t hyperelasticitybiso_dofmap_3::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 0, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_3::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 6, 9, 12 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void hyperelasticitybiso_dofmap_3::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[8] = offset + entity_indices[0][0];
    dofs[9] = offset + entity_indices[0][1];
    dofs[10] = offset + entity_indices[0][2];
    dofs[11] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
}

void hyperelasticitybiso_dofmap_3::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 11;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 10;
        dofs[8] = 11;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 11;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 6;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 10;
        break;
    }
}

void hyperelasticitybiso_dofmap_3::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            break;
        }
        break;
    }
}

void hyperelasticitybiso_dofmap_3::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 7;
            dofs[4] = 10;
            dofs[5] = 11;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 7;
            dofs[4] = 9;
            dofs[5] = 11;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 5;
            dofs[3] = 6;
            dofs[4] = 9;
            dofs[5] = 10;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 4;
            dofs[3] = 7;
            dofs[4] = 8;
            dofs[5] = 11;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 10;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 8;
            dofs[5] = 9;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 11;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 10;
            dofs[8] = 11;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 11;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 6;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 10;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            break;
        }
        break;
    }
}

std::size_t hyperelasticitybiso_dofmap_3::num_sub_dofmaps() const
{
    return 3;
}

ufc::dofmap * hyperelasticitybiso_dofmap_3::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_2();
    case 1:
        return new hyperelasticitybiso_dofmap_2();
    case 2:
        return new hyperelasticitybiso_dofmap_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_dofmap_3::create() const
{
    return new hyperelasticitybiso_dofmap_3();
}


hyperelasticitybiso_dofmap_4::hyperelasticitybiso_dofmap_4() : ufc::dofmap()
{
    // Do nothing
}

hyperelasticitybiso_dofmap_4::~hyperelasticitybiso_dofmap_4()
{
    // Do nothing
}

const char * hyperelasticitybiso_dofmap_4::signature() const
{
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', tetrahedron, 0)";
}

bool hyperelasticitybiso_dofmap_4::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { false, false, false, true };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_4::topological_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_dofmap_4::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[3];
}

std::size_t hyperelasticitybiso_dofmap_4::num_global_support_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_4::num_element_support_dofs() const
{
    return 1;
}

std::size_t hyperelasticitybiso_dofmap_4::num_element_dofs() const
{
    return 1;
}

std::size_t hyperelasticitybiso_dofmap_4::num_facet_dofs() const
{
    return 0;
}

std::size_t hyperelasticitybiso_dofmap_4::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 1 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t hyperelasticitybiso_dofmap_4::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 1 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void hyperelasticitybiso_dofmap_4::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[3][0];
}

void hyperelasticitybiso_dofmap_4::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void hyperelasticitybiso_dofmap_4::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

void hyperelasticitybiso_dofmap_4::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

std::size_t hyperelasticitybiso_dofmap_4::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * hyperelasticitybiso_dofmap_4::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * hyperelasticitybiso_dofmap_4::create() const
{
    return new hyperelasticitybiso_dofmap_4();
}


hyperelasticitybiso_coordinate_mapping_3::hyperelasticitybiso_coordinate_mapping_3() : ufc::coordinate_mapping()
{
    // Do nothing
}

hyperelasticitybiso_coordinate_mapping_3::~hyperelasticitybiso_coordinate_mapping_3()
{
    // Do nothing
}

const char * hyperelasticitybiso_coordinate_mapping_3::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

ufc::coordinate_mapping * hyperelasticitybiso_coordinate_mapping_3::create() const
{
    return new hyperelasticitybiso_coordinate_mapping_3();
}

std::size_t hyperelasticitybiso_coordinate_mapping_3::geometric_dimension() const
{
    return 3;
}

std::size_t hyperelasticitybiso_coordinate_mapping_3::topological_dimension() const
{
    return 3;
}

ufc::shape hyperelasticitybiso_coordinate_mapping_3::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

ufc::finite_element * hyperelasticitybiso_coordinate_mapping_3::create_coordinate_finite_element() const
{
    return new hyperelasticitybiso_finite_element_3();
}

ufc::dofmap * hyperelasticitybiso_coordinate_mapping_3::create_coordinate_dofmap() const
{
    return new hyperelasticitybiso_dofmap_3();
}

void hyperelasticitybiso_coordinate_mapping_3::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    hyperelasticitybiso_finite_element_2 xelement;
    double phi[4];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[3 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 3; ++i)
            for (std::size_t d = 0; d < 4; ++d)
                x[3 * ip + i] += coordinate_dofs[3 * d + i] * phi[d];
    }
}

void hyperelasticitybiso_coordinate_mapping_3::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    double J[9];
    double detJ[1];
    double K[9];
    double x0[3] = {};
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 3; ++i)
    {
        for (std::size_t j = 0; j < 3; ++j)
        {
            J[3 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t i = 0; i < 3; ++i)
                X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void hyperelasticitybiso_coordinate_mapping_3::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    double x0[3] = {};
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 3; ++i)
    {
        for (std::size_t j = 0; j < 3; ++j)
        {
            J[3 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t i = 0; i < 3; ++i)
                X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void hyperelasticitybiso_coordinate_mapping_3::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    hyperelasticitybiso_finite_element_2 xelement;
    double dphi[12];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[3 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 3; ++i)
            for (std::size_t j = 0; j < 3; ++j)
                for (std::size_t d = 0; d < 4; ++d)
                    J[3 * 3 * ip + 3 * i + j] += coordinate_dofs[3 * d + i] * dphi[3 * d + j];
    }
}

void hyperelasticitybiso_coordinate_mapping_3::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[3 * 3 * ip] * (J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2 + 2] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) + J[3 * 3 * ip + 1] * (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 2]) + J[3 * 3 * ip + 2] * (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2]);
}

void hyperelasticitybiso_coordinate_mapping_3::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[3 * 3 * ip] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
        K[3 * 3 * ip + 1] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2 + 2]) / detJ[ip];
        K[3 * 3 * ip + 2] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 + 2] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3] = (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3]) / detJ[ip];
        K[3 * 3 * ip + 3 + 1] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2]) / detJ[ip];
        K[3 * 3 * ip + 3 + 2] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2] = (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 * 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2 + 1] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2 + 2] = (J[3 * 3 * ip] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3]) / detJ[ip];
    }
}

void hyperelasticitybiso_coordinate_mapping_3::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void hyperelasticitybiso_coordinate_mapping_3::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[4] = { 0.25000000000000006, 0.24999999999999997, 0.25, 0.25 };
    const double dphi_Xm[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t d = 0; d < 4; ++d)
            x[i] += coordinate_dofs[3 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t d = 0; d < 4; ++d)
                J[3 * i + j] += coordinate_dofs[3 * d + i] * dphi_Xm[j][d];
}


hyperelasticitybiso_cell_integral_0_otherwise::hyperelasticitybiso_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

hyperelasticitybiso_cell_integral_0_otherwise::~hyperelasticitybiso_cell_integral_0_otherwise()
{

}

const std::vector<bool> & hyperelasticitybiso_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true});
return enabled;
}

void hyperelasticitybiso_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 1
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 0
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           1
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE35_C0_D001_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c4 = coordinate_dofs[1] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[7] * FE35_C0_D001_Q1[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[11] * FE35_C0_D001_Q1[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[10] * FE35_C0_D001_Q1[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[8] * FE35_C0_D001_Q1[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[3] * FE35_C0_D001_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[6] * FE35_C0_D001_Q1[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[5] * FE35_C0_D001_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[4] * FE35_C0_D001_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE35_C0_D001_Q1[0][0][0] + coordinate_dofs[9] * FE35_C0_D001_Q1[0][0][1];
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE35_C0_D001_Q1[0][0][ic];
    const double w0_d1_c0 = w[0][0] * FE35_C0_D001_Q1[0][0][0] + w[0][2] * FE35_C0_D001_Q1[0][0][1];
    const double w0_d2_c0 = w[0][0] * FE35_C0_D001_Q1[0][0][0] + w[0][3] * FE35_C0_D001_Q1[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 4] * FE35_C0_D001_Q1[0][0][ic];
    const double w0_d1_c1 = w[0][4] * FE35_C0_D001_Q1[0][0][0] + w[0][6] * FE35_C0_D001_Q1[0][0][1];
    const double w0_d2_c1 = w[0][4] * FE35_C0_D001_Q1[0][0][0] + w[0][7] * FE35_C0_D001_Q1[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 8] * FE35_C0_D001_Q1[0][0][ic];
    const double w0_d1_c2 = w[0][8] * FE35_C0_D001_Q1[0][0][0] + w[0][10] * FE35_C0_D001_Q1[0][0][1];
    const double w0_d2_c2 = w[0][8] * FE35_C0_D001_Q1[0][0][0] + w[0][11] * FE35_C0_D001_Q1[0][0][1];
    alignas(32) double sp[5005];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = sp[2] / sp[13];
    sp[15] = J_c3 * (-1 * J_c8);
    sp[16] = sp[4] + sp[15];
    sp[17] = sp[16] / sp[13];
    sp[18] = sp[11] / sp[13];
    sp[19] = sp[14] * sp[14];
    sp[20] = sp[14] * sp[17];
    sp[21] = sp[18] * sp[14];
    sp[22] = sp[17] * sp[17];
    sp[23] = sp[18] * sp[17];
    sp[24] = sp[18] * sp[18];
    sp[25] = sp[19] + sp[19];
    sp[26] = sp[20] + sp[20];
    sp[27] = sp[21] + sp[21];
    sp[28] = sp[22] + sp[22];
    sp[29] = sp[23] + sp[23];
    sp[30] = sp[24] + sp[24];
    sp[31] = J_c2 * J_c7;
    sp[32] = J_c8 * (-1 * J_c1);
    sp[33] = sp[31] + sp[32];
    sp[34] = sp[33] / sp[13];
    sp[35] = J_c0 * J_c8;
    sp[36] = J_c6 * (-1 * J_c2);
    sp[37] = sp[35] + sp[36];
    sp[38] = sp[37] / sp[13];
    sp[39] = J_c1 * J_c6;
    sp[40] = J_c0 * J_c7;
    sp[41] = sp[39] + -1 * sp[40];
    sp[42] = sp[41] / sp[13];
    sp[43] = sp[34] * sp[34];
    sp[44] = sp[34] * sp[38];
    sp[45] = sp[34] * sp[42];
    sp[46] = sp[38] * sp[38];
    sp[47] = sp[38] * sp[42];
    sp[48] = sp[42] * sp[42];
    sp[49] = sp[43] + sp[43];
    sp[50] = sp[44] + sp[44];
    sp[51] = sp[45] + sp[45];
    sp[52] = sp[46] + sp[46];
    sp[53] = sp[47] + sp[47];
    sp[54] = sp[48] + sp[48];
    sp[55] = sp[49] + sp[25];
    sp[56] = sp[50] + sp[26];
    sp[57] = sp[51] + sp[27];
    sp[58] = sp[52] + sp[28];
    sp[59] = sp[53] + sp[29];
    sp[60] = sp[30] + sp[54];
    sp[61] = J_c1 * J_c5;
    sp[62] = J_c2 * J_c4;
    sp[63] = sp[61] + -1 * sp[62];
    sp[64] = sp[63] / sp[13];
    sp[65] = J_c2 * J_c3;
    sp[66] = J_c0 * J_c5;
    sp[67] = sp[65] + -1 * sp[66];
    sp[68] = sp[67] / sp[13];
    sp[69] = J_c0 * J_c4;
    sp[70] = J_c1 * J_c3;
    sp[71] = sp[69] + -1 * sp[70];
    sp[72] = sp[71] / sp[13];
    sp[73] = sp[64] * sp[64];
    sp[74] = sp[64] * sp[68];
    sp[75] = sp[72] * sp[64];
    sp[76] = sp[68] * sp[68];
    sp[77] = sp[72] * sp[68];
    sp[78] = sp[72] * sp[72];
    sp[79] = sp[73] + sp[73];
    sp[80] = sp[74] + sp[74];
    sp[81] = sp[75] + sp[75];
    sp[82] = sp[76] + sp[76];
    sp[83] = sp[77] + sp[77];
    sp[84] = sp[78] + sp[78];
    sp[85] = sp[55] + sp[79];
    sp[86] = sp[56] + sp[80];
    sp[87] = sp[57] + sp[81];
    sp[88] = sp[58] + sp[82];
    sp[89] = sp[59] + sp[83];
    sp[90] = sp[60] + sp[84];
    sp[91] = w0_d0_c0 * sp[34];
    sp[92] = w0_d1_c0 * sp[38];
    sp[93] = sp[91] + sp[92];
    sp[94] = w0_d2_c0 * sp[42];
    sp[95] = sp[93] + sp[94];
    sp[96] = sp[95] * sp[34];
    sp[97] = sp[95] * sp[38];
    sp[98] = sp[95] * sp[42];
    sp[99] = sp[96] + sp[96];
    sp[100] = sp[97] + sp[97];
    sp[101] = sp[98] + sp[98];
    sp[102] = w0_d0_c1 * sp[34];
    sp[103] = w0_d1_c1 * sp[38];
    sp[104] = sp[102] + sp[103];
    sp[105] = w0_d2_c1 * sp[42];
    sp[106] = sp[104] + sp[105];
    sp[107] = (1 + sp[106]) * sp[34];
    sp[108] = (1 + sp[106]) * sp[38];
    sp[109] = (1 + sp[106]) * sp[42];
    sp[110] = sp[107] + sp[107];
    sp[111] = sp[108] + sp[108];
    sp[112] = sp[109] + sp[109];
    sp[113] = w0_d0_c2 * sp[34];
    sp[114] = w0_d1_c2 * sp[38];
    sp[115] = sp[113] + sp[114];
    sp[116] = w0_d2_c2 * sp[42];
    sp[117] = sp[115] + sp[116];
    sp[118] = sp[117] * sp[34];
    sp[119] = sp[117] * sp[38];
    sp[120] = sp[117] * sp[42];
    sp[121] = sp[118] + sp[118];
    sp[122] = sp[119] + sp[119];
    sp[123] = sp[120] + sp[120];
    sp[124] = w0_d0_c0 * sp[64];
    sp[125] = w0_d1_c0 * sp[68];
    sp[126] = sp[124] + sp[125];
    sp[127] = w0_d2_c0 * sp[72];
    sp[128] = sp[126] + sp[127];
    sp[129] = sp[128] * sp[128];
    sp[130] = w0_d0_c1 * sp[64];
    sp[131] = w0_d1_c1 * sp[68];
    sp[132] = sp[130] + sp[131];
    sp[133] = w0_d2_c1 * sp[72];
    sp[134] = sp[132] + sp[133];
    sp[135] = sp[134] * sp[134];
    sp[136] = sp[129] + sp[135];
    sp[137] = w0_d0_c2 * sp[64];
    sp[138] = w0_d1_c2 * sp[68];
    sp[139] = sp[137] + sp[138];
    sp[140] = w0_d2_c2 * sp[72];
    sp[141] = sp[139] + sp[140];
    sp[142] = (1 + sp[141]) * (1 + sp[141]);
    sp[143] = sp[136] + sp[142];
    sp[144] = sp[143] * sp[99];
    sp[145] = sp[143] * sp[100];
    sp[146] = sp[143] * sp[101];
    sp[147] = sp[143] * sp[110];
    sp[148] = sp[143] * sp[111];
    sp[149] = sp[143] * sp[112];
    sp[150] = sp[143] * sp[121];
    sp[151] = sp[143] * sp[122];
    sp[152] = sp[143] * sp[123];
    sp[153] = sp[128] * sp[64];
    sp[154] = sp[128] * sp[68];
    sp[155] = sp[128] * sp[72];
    sp[156] = sp[153] + sp[153];
    sp[157] = sp[154] + sp[154];
    sp[158] = sp[155] + sp[155];
    sp[159] = sp[134] * sp[64];
    sp[160] = sp[134] * sp[68];
    sp[161] = sp[134] * sp[72];
    sp[162] = sp[159] + sp[159];
    sp[163] = sp[160] + sp[160];
    sp[164] = sp[161] + sp[161];
    sp[165] = (1 + sp[141]) * sp[64];
    sp[166] = (1 + sp[141]) * sp[68];
    sp[167] = (1 + sp[141]) * sp[72];
    sp[168] = sp[165] + sp[165];
    sp[169] = sp[166] + sp[166];
    sp[170] = sp[167] + sp[167];
    sp[171] = (1 + sp[106]) * (1 + sp[106]);
    sp[172] = sp[95] * sp[95];
    sp[173] = sp[171] + sp[172];
    sp[174] = sp[117] * sp[117];
    sp[175] = sp[173] + sp[174];
    sp[176] = sp[175] * sp[156];
    sp[177] = sp[175] * sp[157];
    sp[178] = sp[175] * sp[158];
    sp[179] = sp[175] * sp[162];
    sp[180] = sp[175] * sp[163];
    sp[181] = sp[175] * sp[164];
    sp[182] = sp[175] * sp[168];
    sp[183] = sp[175] * sp[169];
    sp[184] = sp[175] * sp[170];
    sp[185] = sp[144] + sp[176];
    sp[186] = sp[145] + sp[177];
    sp[187] = sp[178] + sp[146];
    sp[188] = sp[147] + sp[179];
    sp[189] = sp[148] + sp[180];
    sp[190] = sp[181] + sp[149];
    sp[191] = sp[150] + sp[182];
    sp[192] = sp[151] + sp[183];
    sp[193] = sp[184] + sp[152];
    sp[194] = sp[128] * sp[34];
    sp[195] = sp[128] * sp[38];
    sp[196] = sp[128] * sp[42];
    sp[197] = sp[95] * sp[64];
    sp[198] = sp[95] * sp[68];
    sp[199] = sp[95] * sp[72];
    sp[200] = sp[194] + sp[197];
    sp[201] = sp[195] + sp[198];
    sp[202] = sp[199] + sp[196];
    sp[203] = (1 + sp[106]) * sp[64];
    sp[204] = (1 + sp[106]) * sp[68];
    sp[205] = (1 + sp[106]) * sp[72];
    sp[206] = sp[134] * sp[34];
    sp[207] = sp[134] * sp[38];
    sp[208] = sp[134] * sp[42];
    sp[209] = sp[206] + sp[203];
    sp[210] = sp[207] + sp[204];
    sp[211] = sp[205] + sp[208];
    sp[212] = (1 + sp[141]) * sp[34];
    sp[213] = (1 + sp[141]) * sp[38];
    sp[214] = (1 + sp[141]) * sp[42];
    sp[215] = sp[117] * sp[64];
    sp[216] = sp[117] * sp[68];
    sp[217] = sp[117] * sp[72];
    sp[218] = sp[212] + sp[215];
    sp[219] = sp[213] + sp[216];
    sp[220] = sp[217] + sp[214];
    sp[221] = (1 + sp[106]) * sp[134];
    sp[222] = sp[128] * sp[95];
    sp[223] = sp[221] + sp[222];
    sp[224] = (1 + sp[141]) * sp[117];
    sp[225] = sp[223] + sp[224];
    sp[226] = sp[225] * sp[200];
    sp[227] = sp[225] * sp[201];
    sp[228] = sp[225] * sp[202];
    sp[229] = sp[225] * sp[209];
    sp[230] = sp[225] * sp[210];
    sp[231] = sp[225] * sp[211];
    sp[232] = sp[225] * sp[218];
    sp[233] = sp[225] * sp[219];
    sp[234] = sp[225] * sp[220];
    sp[235] = sp[226] + sp[226];
    sp[236] = sp[227] + sp[227];
    sp[237] = sp[228] + sp[228];
    sp[238] = sp[229] + sp[229];
    sp[239] = sp[230] + sp[230];
    sp[240] = sp[231] + sp[231];
    sp[241] = sp[232] + sp[232];
    sp[242] = sp[233] + sp[233];
    sp[243] = sp[234] + sp[234];
    sp[244] = sp[185] + -1 * sp[235];
    sp[245] = sp[186] + -1 * sp[236];
    sp[246] = sp[187] + -1 * sp[237];
    sp[247] = sp[188] + -1 * sp[238];
    sp[248] = sp[189] + -1 * sp[239];
    sp[249] = sp[190] + -1 * sp[240];
    sp[250] = sp[191] + -1 * sp[241];
    sp[251] = sp[192] + -1 * sp[242];
    sp[252] = sp[193] + -1 * sp[243];
    sp[253] = w0_d0_c0 * sp[14];
    sp[254] = w0_d1_c0 * sp[17];
    sp[255] = sp[253] + sp[254];
    sp[256] = w0_d2_c0 * sp[18];
    sp[257] = sp[255] + sp[256];
    sp[258] = (1 + sp[257]) * (1 + sp[257]);
    sp[259] = w0_d0_c1 * sp[14];
    sp[260] = w0_d1_c1 * sp[17];
    sp[261] = sp[259] + sp[260];
    sp[262] = w0_d2_c1 * sp[18];
    sp[263] = sp[261] + sp[262];
    sp[264] = sp[263] * sp[263];
    sp[265] = sp[258] + sp[264];
    sp[266] = w0_d0_c2 * sp[14];
    sp[267] = w0_d1_c2 * sp[17];
    sp[268] = sp[266] + sp[267];
    sp[269] = w0_d2_c2 * sp[18];
    sp[270] = sp[268] + sp[269];
    sp[271] = sp[270] * sp[270];
    sp[272] = sp[265] + sp[271];
    sp[273] = sp[244] * sp[272];
    sp[274] = sp[245] * sp[272];
    sp[275] = sp[246] * sp[272];
    sp[276] = sp[247] * sp[272];
    sp[277] = sp[248] * sp[272];
    sp[278] = sp[249] * sp[272];
    sp[279] = sp[250] * sp[272];
    sp[280] = sp[251] * sp[272];
    sp[281] = sp[252] * sp[272];
    sp[282] = (1 + sp[257]) * sp[14];
    sp[283] = (1 + sp[257]) * sp[17];
    sp[284] = (1 + sp[257]) * sp[18];
    sp[285] = sp[282] + sp[282];
    sp[286] = sp[283] + sp[283];
    sp[287] = sp[284] + sp[284];
    sp[288] = sp[263] * sp[14];
    sp[289] = sp[263] * sp[17];
    sp[290] = sp[263] * sp[18];
    sp[291] = sp[288] + sp[288];
    sp[292] = sp[289] + sp[289];
    sp[293] = sp[290] + sp[290];
    sp[294] = sp[270] * sp[14];
    sp[295] = sp[270] * sp[17];
    sp[296] = sp[270] * sp[18];
    sp[297] = sp[294] + sp[294];
    sp[298] = sp[295] + sp[295];
    sp[299] = sp[296] + sp[296];
    sp[300] = sp[143] * sp[175];
    sp[301] = sp[225] * sp[225];
    sp[302] = sp[300] + -1 * sp[301];
    sp[303] = sp[302] * sp[285];
    sp[304] = sp[302] * sp[286];
    sp[305] = sp[302] * sp[287];
    sp[306] = sp[302] * sp[291];
    sp[307] = sp[302] * sp[292];
    sp[308] = sp[302] * sp[293];
    sp[309] = sp[302] * sp[297];
    sp[310] = sp[302] * sp[298];
    sp[311] = sp[302] * sp[299];
    sp[312] = sp[273] + sp[303];
    sp[313] = sp[274] + sp[304];
    sp[314] = sp[275] + sp[305];
    sp[315] = sp[276] + sp[306];
    sp[316] = sp[277] + sp[307];
    sp[317] = sp[278] + sp[308];
    sp[318] = sp[279] + sp[309];
    sp[319] = sp[280] + sp[310];
    sp[320] = sp[281] + sp[311];
    sp[321] = (1 + sp[257]) * sp[128];
    sp[322] = sp[134] * sp[263];
    sp[323] = sp[321] + sp[322];
    sp[324] = (1 + sp[141]) * sp[270];
    sp[325] = sp[323] + sp[324];
    sp[326] = sp[325] * sp[200];
    sp[327] = sp[325] * sp[201];
    sp[328] = sp[325] * sp[202];
    sp[329] = sp[325] * sp[209];
    sp[330] = sp[325] * sp[210];
    sp[331] = sp[325] * sp[211];
    sp[332] = sp[325] * sp[218];
    sp[333] = sp[325] * sp[219];
    sp[334] = sp[325] * sp[220];
    sp[335] = (1 + sp[257]) * sp[64];
    sp[336] = (1 + sp[257]) * sp[68];
    sp[337] = (1 + sp[257]) * sp[72];
    sp[338] = sp[128] * sp[14];
    sp[339] = sp[128] * sp[17];
    sp[340] = sp[128] * sp[18];
    sp[341] = sp[335] + sp[338];
    sp[342] = sp[336] + sp[339];
    sp[343] = sp[337] + sp[340];
    sp[344] = sp[134] * sp[14];
    sp[345] = sp[134] * sp[17];
    sp[346] = sp[134] * sp[18];
    sp[347] = sp[263] * sp[64];
    sp[348] = sp[263] * sp[68];
    sp[349] = sp[263] * sp[72];
    sp[350] = sp[347] + sp[344];
    sp[351] = sp[348] + sp[345];
    sp[352] = sp[349] + sp[346];
    sp[353] = (1 + sp[141]) * sp[14];
    sp[354] = (1 + sp[141]) * sp[17];
    sp[355] = (1 + sp[141]) * sp[18];
    sp[356] = sp[270] * sp[64];
    sp[357] = sp[270] * sp[68];
    sp[358] = sp[270] * sp[72];
    sp[359] = sp[356] + sp[353];
    sp[360] = sp[357] + sp[354];
    sp[361] = sp[358] + sp[355];
    sp[362] = sp[225] * sp[341];
    sp[363] = sp[225] * sp[342];
    sp[364] = sp[225] * sp[343];
    sp[365] = sp[225] * sp[350];
    sp[366] = sp[225] * sp[351];
    sp[367] = sp[225] * sp[352];
    sp[368] = sp[225] * sp[359];
    sp[369] = sp[225] * sp[360];
    sp[370] = sp[225] * sp[361];
    sp[371] = sp[326] + sp[362];
    sp[372] = sp[327] + sp[363];
    sp[373] = sp[364] + sp[328];
    sp[374] = sp[329] + sp[365];
    sp[375] = sp[330] + sp[366];
    sp[376] = sp[367] + sp[331];
    sp[377] = sp[332] + sp[368];
    sp[378] = sp[333] + sp[369];
    sp[379] = sp[370] + sp[334];
    sp[380] = (1 + sp[257]) * sp[34];
    sp[381] = (1 + sp[257]) * sp[38];
    sp[382] = (1 + sp[257]) * sp[42];
    sp[383] = sp[95] * sp[14];
    sp[384] = sp[95] * sp[17];
    sp[385] = sp[95] * sp[18];
    sp[386] = sp[380] + sp[383];
    sp[387] = sp[381] + sp[384];
    sp[388] = sp[385] + sp[382];
    sp[389] = (1 + sp[106]) * sp[14];
    sp[390] = (1 + sp[106]) * sp[17];
    sp[391] = (1 + sp[106]) * sp[18];
    sp[392] = sp[263] * sp[34];
    sp[393] = sp[263] * sp[38];
    sp[394] = sp[263] * sp[42];
    sp[395] = sp[392] + sp[389];
    sp[396] = sp[393] + sp[390];
    sp[397] = sp[391] + sp[394];
    sp[398] = sp[270] * sp[34];
    sp[399] = sp[270] * sp[38];
    sp[400] = sp[270] * sp[42];
    sp[401] = sp[117] * sp[14];
    sp[402] = sp[117] * sp[17];
    sp[403] = sp[117] * sp[18];
    sp[404] = sp[398] + sp[401];
    sp[405] = sp[399] + sp[402];
    sp[406] = sp[403] + sp[400];
    sp[407] = sp[143] * sp[386];
    sp[408] = sp[143] * sp[387];
    sp[409] = sp[143] * sp[388];
    sp[410] = sp[143] * sp[395];
    sp[411] = sp[143] * sp[396];
    sp[412] = sp[143] * sp[397];
    sp[413] = sp[143] * sp[404];
    sp[414] = sp[143] * sp[405];
    sp[415] = sp[143] * sp[406];
    sp[416] = (1 + sp[106]) * sp[263];
    sp[417] = (1 + sp[257]) * sp[95];
    sp[418] = sp[416] + sp[417];
    sp[419] = sp[270] * sp[117];
    sp[420] = sp[418] + sp[419];
    sp[421] = sp[420] * sp[156];
    sp[422] = sp[420] * sp[157];
    sp[423] = sp[420] * sp[158];
    sp[424] = sp[420] * sp[162];
    sp[425] = sp[420] * sp[163];
    sp[426] = sp[420] * sp[164];
    sp[427] = sp[420] * sp[168];
    sp[428] = sp[420] * sp[169];
    sp[429] = sp[420] * sp[170];
    sp[430] = sp[421] + sp[407];
    sp[431] = sp[422] + sp[408];
    sp[432] = sp[423] + sp[409];
    sp[433] = sp[424] + sp[410];
    sp[434] = sp[425] + sp[411];
    sp[435] = sp[426] + sp[412];
    sp[436] = sp[427] + sp[413];
    sp[437] = sp[428] + sp[414];
    sp[438] = sp[429] + sp[415];
    sp[439] = sp[371] + -1 * sp[430];
    sp[440] = sp[372] + -1 * sp[431];
    sp[441] = sp[373] + -1 * sp[432];
    sp[442] = sp[374] + -1 * sp[433];
    sp[443] = sp[375] + -1 * sp[434];
    sp[444] = sp[376] + -1 * sp[435];
    sp[445] = sp[377] + -1 * sp[436];
    sp[446] = sp[378] + -1 * sp[437];
    sp[447] = sp[379] + -1 * sp[438];
    sp[448] = sp[439] * sp[420];
    sp[449] = sp[440] * sp[420];
    sp[450] = sp[441] * sp[420];
    sp[451] = sp[442] * sp[420];
    sp[452] = sp[443] * sp[420];
    sp[453] = sp[444] * sp[420];
    sp[454] = sp[445] * sp[420];
    sp[455] = sp[446] * sp[420];
    sp[456] = sp[447] * sp[420];
    sp[457] = sp[325] * sp[225];
    sp[458] = sp[143] * sp[420];
    sp[459] = sp[457] + -1 * sp[458];
    sp[460] = sp[459] * sp[386];
    sp[461] = sp[459] * sp[387];
    sp[462] = sp[459] * sp[388];
    sp[463] = sp[459] * sp[395];
    sp[464] = sp[459] * sp[396];
    sp[465] = sp[459] * sp[397];
    sp[466] = sp[459] * sp[404];
    sp[467] = sp[459] * sp[405];
    sp[468] = sp[459] * sp[406];
    sp[469] = sp[448] + sp[460];
    sp[470] = sp[449] + sp[461];
    sp[471] = sp[450] + sp[462];
    sp[472] = sp[451] + sp[463];
    sp[473] = sp[452] + sp[464];
    sp[474] = sp[453] + sp[465];
    sp[475] = sp[454] + sp[466];
    sp[476] = sp[455] + sp[467];
    sp[477] = sp[456] + sp[468];
    sp[478] = sp[312] + sp[469];
    sp[479] = sp[313] + sp[470];
    sp[480] = sp[314] + sp[471];
    sp[481] = sp[472] + sp[315];
    sp[482] = sp[473] + sp[316];
    sp[483] = sp[317] + sp[474];
    sp[484] = sp[318] + sp[475];
    sp[485] = sp[319] + sp[476];
    sp[486] = sp[320] + sp[477];
    sp[487] = sp[225] * sp[386];
    sp[488] = sp[225] * sp[387];
    sp[489] = sp[225] * sp[388];
    sp[490] = sp[225] * sp[395];
    sp[491] = sp[225] * sp[396];
    sp[492] = sp[225] * sp[397];
    sp[493] = sp[225] * sp[404];
    sp[494] = sp[225] * sp[405];
    sp[495] = sp[225] * sp[406];
    sp[496] = sp[420] * sp[200];
    sp[497] = sp[420] * sp[201];
    sp[498] = sp[420] * sp[202];
    sp[499] = sp[420] * sp[209];
    sp[500] = sp[420] * sp[210];
    sp[501] = sp[420] * sp[211];
    sp[502] = sp[420] * sp[218];
    sp[503] = sp[420] * sp[219];
    sp[504] = sp[420] * sp[220];
    sp[505] = sp[496] + sp[487];
    sp[506] = sp[497] + sp[488];
    sp[507] = sp[489] + sp[498];
    sp[508] = sp[499] + sp[490];
    sp[509] = sp[500] + sp[491];
    sp[510] = sp[501] + sp[492];
    sp[511] = sp[502] + sp[493];
    sp[512] = sp[503] + sp[494];
    sp[513] = sp[504] + sp[495];
    sp[514] = sp[325] * sp[99];
    sp[515] = sp[325] * sp[100];
    sp[516] = sp[325] * sp[101];
    sp[517] = sp[325] * sp[110];
    sp[518] = sp[325] * sp[111];
    sp[519] = sp[325] * sp[112];
    sp[520] = sp[325] * sp[121];
    sp[521] = sp[325] * sp[122];
    sp[522] = sp[325] * sp[123];
    sp[523] = sp[175] * sp[341];
    sp[524] = sp[175] * sp[342];
    sp[525] = sp[175] * sp[343];
    sp[526] = sp[175] * sp[350];
    sp[527] = sp[175] * sp[351];
    sp[528] = sp[175] * sp[352];
    sp[529] = sp[175] * sp[359];
    sp[530] = sp[175] * sp[360];
    sp[531] = sp[175] * sp[361];
    sp[532] = sp[514] + sp[523];
    sp[533] = sp[515] + sp[524];
    sp[534] = sp[525] + sp[516];
    sp[535] = sp[517] + sp[526];
    sp[536] = sp[518] + sp[527];
    sp[537] = sp[528] + sp[519];
    sp[538] = sp[520] + sp[529];
    sp[539] = sp[521] + sp[530];
    sp[540] = sp[531] + sp[522];
    sp[541] = sp[505] + -1 * sp[532];
    sp[542] = sp[506] + -1 * sp[533];
    sp[543] = sp[507] + -1 * sp[534];
    sp[544] = sp[508] + -1 * sp[535];
    sp[545] = sp[509] + -1 * sp[536];
    sp[546] = sp[510] + -1 * sp[537];
    sp[547] = sp[511] + -1 * sp[538];
    sp[548] = sp[512] + -1 * sp[539];
    sp[549] = sp[513] + -1 * sp[540];
    sp[550] = sp[541] * sp[325];
    sp[551] = sp[542] * sp[325];
    sp[552] = sp[543] * sp[325];
    sp[553] = sp[544] * sp[325];
    sp[554] = sp[545] * sp[325];
    sp[555] = sp[546] * sp[325];
    sp[556] = sp[547] * sp[325];
    sp[557] = sp[548] * sp[325];
    sp[558] = sp[549] * sp[325];
    sp[559] = sp[225] * sp[420];
    sp[560] = sp[325] * sp[175];
    sp[561] = sp[559] + -1 * sp[560];
    sp[562] = sp[561] * sp[341];
    sp[563] = sp[561] * sp[342];
    sp[564] = sp[561] * sp[343];
    sp[565] = sp[561] * sp[350];
    sp[566] = sp[561] * sp[351];
    sp[567] = sp[561] * sp[352];
    sp[568] = sp[561] * sp[359];
    sp[569] = sp[561] * sp[360];
    sp[570] = sp[561] * sp[361];
    sp[571] = sp[550] + sp[562];
    sp[572] = sp[551] + sp[563];
    sp[573] = sp[552] + sp[564];
    sp[574] = sp[553] + sp[565];
    sp[575] = sp[554] + sp[566];
    sp[576] = sp[555] + sp[567];
    sp[577] = sp[556] + sp[568];
    sp[578] = sp[557] + sp[569];
    sp[579] = sp[558] + sp[570];
    sp[580] = sp[478] + sp[571];
    sp[581] = sp[479] + sp[572];
    sp[582] = sp[480] + sp[573];
    sp[583] = sp[481] + sp[574];
    sp[584] = sp[482] + sp[575];
    sp[585] = sp[483] + sp[576];
    sp[586] = sp[484] + sp[577];
    sp[587] = sp[485] + sp[578];
    sp[588] = sp[486] + sp[579];
    sp[589] = sp[272] * sp[302];
    sp[590] = sp[420] * sp[459];
    sp[591] = sp[589] + sp[590];
    sp[592] = sp[325] * sp[561];
    sp[593] = sp[591] + sp[592];
    sp[594] = -0.6666666666666667 * sp[580] * std::pow(sp[593], -1.666666666666667);
    sp[595] = -0.6666666666666667 * sp[581] * std::pow(sp[593], -1.666666666666667);
    sp[596] = -0.6666666666666667 * sp[582] * std::pow(sp[593], -1.666666666666667);
    sp[597] = -0.6666666666666667 * sp[583] * std::pow(sp[593], -1.666666666666667);
    sp[598] = -0.6666666666666667 * sp[584] * std::pow(sp[593], -1.666666666666667);
    sp[599] = -0.6666666666666667 * sp[585] * std::pow(sp[593], -1.666666666666667);
    sp[600] = -0.6666666666666667 * sp[586] * std::pow(sp[593], -1.666666666666667);
    sp[601] = -0.6666666666666667 * sp[587] * std::pow(sp[593], -1.666666666666667);
    sp[602] = -0.6666666666666667 * sp[588] * std::pow(sp[593], -1.666666666666667);
    sp[603] = 0.3333333333333333 * sp[580] * sp[594];
    sp[604] = 0.3333333333333333 * sp[580] * sp[595];
    sp[605] = 0.3333333333333333 * sp[580] * sp[596];
    sp[606] = 0.3333333333333333 * sp[580] * sp[597];
    sp[607] = 0.3333333333333333 * sp[580] * sp[598];
    sp[608] = 0.3333333333333333 * sp[580] * sp[599];
    sp[609] = 0.3333333333333333 * sp[580] * sp[600];
    sp[610] = 0.3333333333333333 * sp[580] * sp[601];
    sp[611] = 0.3333333333333333 * sp[580] * sp[602];
    sp[612] = 0.3333333333333333 * sp[581] * sp[594];
    sp[613] = 0.3333333333333333 * sp[581] * sp[595];
    sp[614] = 0.3333333333333333 * sp[581] * sp[596];
    sp[615] = 0.3333333333333333 * sp[581] * sp[597];
    sp[616] = 0.3333333333333333 * sp[581] * sp[598];
    sp[617] = 0.3333333333333333 * sp[581] * sp[599];
    sp[618] = 0.3333333333333333 * sp[581] * sp[600];
    sp[619] = 0.3333333333333333 * sp[581] * sp[601];
    sp[620] = 0.3333333333333333 * sp[581] * sp[602];
    sp[621] = 0.3333333333333333 * sp[582] * sp[594];
    sp[622] = 0.3333333333333333 * sp[582] * sp[595];
    sp[623] = 0.3333333333333333 * sp[582] * sp[596];
    sp[624] = 0.3333333333333333 * sp[582] * sp[597];
    sp[625] = 0.3333333333333333 * sp[582] * sp[598];
    sp[626] = 0.3333333333333333 * sp[582] * sp[599];
    sp[627] = 0.3333333333333333 * sp[582] * sp[600];
    sp[628] = 0.3333333333333333 * sp[582] * sp[601];
    sp[629] = 0.3333333333333333 * sp[582] * sp[602];
    sp[630] = 0.3333333333333333 * sp[583] * sp[594];
    sp[631] = 0.3333333333333333 * sp[583] * sp[595];
    sp[632] = 0.3333333333333333 * sp[583] * sp[596];
    sp[633] = 0.3333333333333333 * sp[583] * sp[597];
    sp[634] = 0.3333333333333333 * sp[583] * sp[598];
    sp[635] = 0.3333333333333333 * sp[583] * sp[599];
    sp[636] = 0.3333333333333333 * sp[583] * sp[600];
    sp[637] = 0.3333333333333333 * sp[583] * sp[601];
    sp[638] = 0.3333333333333333 * sp[583] * sp[602];
    sp[639] = 0.3333333333333333 * sp[584] * sp[594];
    sp[640] = 0.3333333333333333 * sp[584] * sp[595];
    sp[641] = 0.3333333333333333 * sp[584] * sp[596];
    sp[642] = 0.3333333333333333 * sp[584] * sp[597];
    sp[643] = 0.3333333333333333 * sp[584] * sp[598];
    sp[644] = 0.3333333333333333 * sp[584] * sp[599];
    sp[645] = 0.3333333333333333 * sp[584] * sp[600];
    sp[646] = 0.3333333333333333 * sp[584] * sp[601];
    sp[647] = 0.3333333333333333 * sp[584] * sp[602];
    sp[648] = 0.3333333333333333 * sp[585] * sp[594];
    sp[649] = 0.3333333333333333 * sp[585] * sp[595];
    sp[650] = 0.3333333333333333 * sp[585] * sp[596];
    sp[651] = 0.3333333333333333 * sp[585] * sp[597];
    sp[652] = 0.3333333333333333 * sp[585] * sp[598];
    sp[653] = 0.3333333333333333 * sp[585] * sp[599];
    sp[654] = 0.3333333333333333 * sp[585] * sp[600];
    sp[655] = 0.3333333333333333 * sp[585] * sp[601];
    sp[656] = 0.3333333333333333 * sp[585] * sp[602];
    sp[657] = 0.3333333333333333 * sp[586] * sp[594];
    sp[658] = 0.3333333333333333 * sp[586] * sp[595];
    sp[659] = 0.3333333333333333 * sp[586] * sp[596];
    sp[660] = 0.3333333333333333 * sp[586] * sp[597];
    sp[661] = 0.3333333333333333 * sp[586] * sp[598];
    sp[662] = 0.3333333333333333 * sp[586] * sp[599];
    sp[663] = 0.3333333333333333 * sp[586] * sp[600];
    sp[664] = 0.3333333333333333 * sp[586] * sp[601];
    sp[665] = 0.3333333333333333 * sp[586] * sp[602];
    sp[666] = 0.3333333333333333 * sp[587] * sp[594];
    sp[667] = 0.3333333333333333 * sp[587] * sp[595];
    sp[668] = 0.3333333333333333 * sp[587] * sp[596];
    sp[669] = 0.3333333333333333 * sp[587] * sp[597];
    sp[670] = 0.3333333333333333 * sp[587] * sp[598];
    sp[671] = 0.3333333333333333 * sp[587] * sp[599];
    sp[672] = 0.3333333333333333 * sp[587] * sp[600];
    sp[673] = 0.3333333333333333 * sp[587] * sp[601];
    sp[674] = 0.3333333333333333 * sp[587] * sp[602];
    sp[675] = 0.3333333333333333 * sp[588] * sp[594];
    sp[676] = 0.3333333333333333 * sp[588] * sp[595];
    sp[677] = 0.3333333333333333 * sp[588] * sp[596];
    sp[678] = 0.3333333333333333 * sp[588] * sp[597];
    sp[679] = 0.3333333333333333 * sp[588] * sp[598];
    sp[680] = 0.3333333333333333 * sp[588] * sp[599];
    sp[681] = 0.3333333333333333 * sp[588] * sp[600];
    sp[682] = 0.3333333333333333 * sp[588] * sp[601];
    sp[683] = 0.3333333333333333 * sp[588] * sp[602];
    sp[684] = sp[244] * sp[285];
    sp[685] = sp[245] * sp[285];
    sp[686] = sp[246] * sp[285];
    sp[687] = sp[247] * sp[285];
    sp[688] = sp[248] * sp[285];
    sp[689] = sp[249] * sp[285];
    sp[690] = sp[250] * sp[285];
    sp[691] = sp[251] * sp[285];
    sp[692] = sp[252] * sp[285];
    sp[693] = sp[244] * sp[286];
    sp[694] = sp[245] * sp[286];
    sp[695] = sp[246] * sp[286];
    sp[696] = sp[247] * sp[286];
    sp[697] = sp[248] * sp[286];
    sp[698] = sp[249] * sp[286];
    sp[699] = sp[250] * sp[286];
    sp[700] = sp[251] * sp[286];
    sp[701] = sp[252] * sp[286];
    sp[702] = sp[244] * sp[287];
    sp[703] = sp[245] * sp[287];
    sp[704] = sp[246] * sp[287];
    sp[705] = sp[247] * sp[287];
    sp[706] = sp[248] * sp[287];
    sp[707] = sp[249] * sp[287];
    sp[708] = sp[250] * sp[287];
    sp[709] = sp[251] * sp[287];
    sp[710] = sp[252] * sp[287];
    sp[711] = sp[244] * sp[291];
    sp[712] = sp[245] * sp[291];
    sp[713] = sp[246] * sp[291];
    sp[714] = sp[247] * sp[291];
    sp[715] = sp[248] * sp[291];
    sp[716] = sp[249] * sp[291];
    sp[717] = sp[250] * sp[291];
    sp[718] = sp[251] * sp[291];
    sp[719] = sp[252] * sp[291];
    sp[720] = sp[244] * sp[292];
    sp[721] = sp[245] * sp[292];
    sp[722] = sp[246] * sp[292];
    sp[723] = sp[247] * sp[292];
    sp[724] = sp[248] * sp[292];
    sp[725] = sp[249] * sp[292];
    sp[726] = sp[250] * sp[292];
    sp[727] = sp[251] * sp[292];
    sp[728] = sp[252] * sp[292];
    sp[729] = sp[244] * sp[293];
    sp[730] = sp[245] * sp[293];
    sp[731] = sp[246] * sp[293];
    sp[732] = sp[247] * sp[293];
    sp[733] = sp[248] * sp[293];
    sp[734] = sp[249] * sp[293];
    sp[735] = sp[250] * sp[293];
    sp[736] = sp[251] * sp[293];
    sp[737] = sp[252] * sp[293];
    sp[738] = sp[244] * sp[297];
    sp[739] = sp[245] * sp[297];
    sp[740] = sp[246] * sp[297];
    sp[741] = sp[247] * sp[297];
    sp[742] = sp[248] * sp[297];
    sp[743] = sp[249] * sp[297];
    sp[744] = sp[250] * sp[297];
    sp[745] = sp[251] * sp[297];
    sp[746] = sp[252] * sp[297];
    sp[747] = sp[244] * sp[298];
    sp[748] = sp[245] * sp[298];
    sp[749] = sp[246] * sp[298];
    sp[750] = sp[247] * sp[298];
    sp[751] = sp[248] * sp[298];
    sp[752] = sp[249] * sp[298];
    sp[753] = sp[250] * sp[298];
    sp[754] = sp[251] * sp[298];
    sp[755] = sp[252] * sp[298];
    sp[756] = sp[244] * sp[299];
    sp[757] = sp[245] * sp[299];
    sp[758] = sp[246] * sp[299];
    sp[759] = sp[247] * sp[299];
    sp[760] = sp[248] * sp[299];
    sp[761] = sp[249] * sp[299];
    sp[762] = sp[250] * sp[299];
    sp[763] = sp[251] * sp[299];
    sp[764] = sp[252] * sp[299];
    sp[765] = sp[99] * sp[156];
    sp[766] = sp[100] * sp[156];
    sp[767] = sp[156] * sp[101];
    sp[768] = sp[110] * sp[156];
    sp[769] = sp[111] * sp[156];
    sp[770] = sp[156] * sp[112];
    sp[771] = sp[121] * sp[156];
    sp[772] = sp[122] * sp[156];
    sp[773] = sp[156] * sp[123];
    sp[774] = sp[99] * sp[157];
    sp[775] = sp[100] * sp[157];
    sp[776] = sp[157] * sp[101];
    sp[777] = sp[110] * sp[157];
    sp[778] = sp[111] * sp[157];
    sp[779] = sp[157] * sp[112];
    sp[780] = sp[121] * sp[157];
    sp[781] = sp[122] * sp[157];
    sp[782] = sp[157] * sp[123];
    sp[783] = sp[99] * sp[158];
    sp[784] = sp[100] * sp[158];
    sp[785] = sp[158] * sp[101];
    sp[786] = sp[110] * sp[158];
    sp[787] = sp[111] * sp[158];
    sp[788] = sp[158] * sp[112];
    sp[789] = sp[121] * sp[158];
    sp[790] = sp[122] * sp[158];
    sp[791] = sp[158] * sp[123];
    sp[792] = sp[99] * sp[162];
    sp[793] = sp[100] * sp[162];
    sp[794] = sp[162] * sp[101];
    sp[795] = sp[110] * sp[162];
    sp[796] = sp[111] * sp[162];
    sp[797] = sp[162] * sp[112];
    sp[798] = sp[121] * sp[162];
    sp[799] = sp[122] * sp[162];
    sp[800] = sp[162] * sp[123];
    sp[801] = sp[99] * sp[163];
    sp[802] = sp[100] * sp[163];
    sp[803] = sp[163] * sp[101];
    sp[804] = sp[110] * sp[163];
    sp[805] = sp[111] * sp[163];
    sp[806] = sp[163] * sp[112];
    sp[807] = sp[121] * sp[163];
    sp[808] = sp[122] * sp[163];
    sp[809] = sp[163] * sp[123];
    sp[810] = sp[99] * sp[164];
    sp[811] = sp[100] * sp[164];
    sp[812] = sp[164] * sp[101];
    sp[813] = sp[110] * sp[164];
    sp[814] = sp[111] * sp[164];
    sp[815] = sp[164] * sp[112];
    sp[816] = sp[121] * sp[164];
    sp[817] = sp[122] * sp[164];
    sp[818] = sp[164] * sp[123];
    sp[819] = sp[99] * sp[168];
    sp[820] = sp[100] * sp[168];
    sp[821] = sp[168] * sp[101];
    sp[822] = sp[110] * sp[168];
    sp[823] = sp[111] * sp[168];
    sp[824] = sp[168] * sp[112];
    sp[825] = sp[121] * sp[168];
    sp[826] = sp[122] * sp[168];
    sp[827] = sp[168] * sp[123];
    sp[828] = sp[99] * sp[169];
    sp[829] = sp[100] * sp[169];
    sp[830] = sp[169] * sp[101];
    sp[831] = sp[110] * sp[169];
    sp[832] = sp[111] * sp[169];
    sp[833] = sp[169] * sp[112];
    sp[834] = sp[121] * sp[169];
    sp[835] = sp[122] * sp[169];
    sp[836] = sp[169] * sp[123];
    sp[837] = sp[99] * sp[170];
    sp[838] = sp[100] * sp[170];
    sp[839] = sp[170] * sp[101];
    sp[840] = sp[110] * sp[170];
    sp[841] = sp[111] * sp[170];
    sp[842] = sp[170] * sp[112];
    sp[843] = sp[121] * sp[170];
    sp[844] = sp[122] * sp[170];
    sp[845] = sp[170] * sp[123];
    sp[846] = sp[143] * sp[49];
    sp[847] = sp[143] * sp[50];
    sp[848] = sp[143] * sp[51];
    sp[849] = sp[143] * sp[52];
    sp[850] = sp[143] * sp[53];
    sp[851] = sp[143] * sp[54];
    sp[852] = sp[846] + sp[765];
    sp[853] = sp[847] + sp[774];
    sp[854] = sp[783] + sp[848];
    sp[855] = sp[847] + sp[766];
    sp[856] = sp[849] + sp[775];
    sp[857] = sp[784] + sp[850];
    sp[858] = sp[767] + sp[848];
    sp[859] = sp[776] + sp[850];
    sp[860] = sp[785] + sp[851];
    sp[861] = sp[846] + sp[795];
    sp[862] = sp[847] + sp[804];
    sp[863] = sp[813] + sp[848];
    sp[864] = sp[847] + sp[796];
    sp[865] = sp[849] + sp[805];
    sp[866] = sp[814] + sp[850];
    sp[867] = sp[797] + sp[848];
    sp[868] = sp[806] + sp[850];
    sp[869] = sp[815] + sp[851];
    sp[870] = sp[846] + sp[825];
    sp[871] = sp[847] + sp[834];
    sp[872] = sp[843] + sp[848];
    sp[873] = sp[847] + sp[826];
    sp[874] = sp[849] + sp[835];
    sp[875] = sp[844] + sp[850];
    sp[876] = sp[827] + sp[848];
    sp[877] = sp[836] + sp[850];
    sp[878] = sp[845] + sp[851];
    sp[879] = sp[175] * sp[79];
    sp[880] = sp[175] * sp[80];
    sp[881] = sp[175] * sp[81];
    sp[882] = sp[175] * sp[82];
    sp[883] = sp[175] * sp[83];
    sp[884] = sp[175] * sp[84];
    sp[885] = sp[765] + sp[879];
    sp[886] = sp[766] + sp[880];
    sp[887] = sp[881] + sp[767];
    sp[888] = sp[774] + sp[880];
    sp[889] = sp[775] + sp[882];
    sp[890] = sp[883] + sp[776];
    sp[891] = sp[783] + sp[881];
    sp[892] = sp[784] + sp[883];
    sp[893] = sp[884] + sp[785];
    sp[894] = sp[795] + sp[879];
    sp[895] = sp[796] + sp[880];
    sp[896] = sp[881] + sp[797];
    sp[897] = sp[804] + sp[880];
    sp[898] = sp[805] + sp[882];
    sp[899] = sp[883] + sp[806];
    sp[900] = sp[813] + sp[881];
    sp[901] = sp[814] + sp[883];
    sp[902] = sp[884] + sp[815];
    sp[903] = sp[825] + sp[879];
    sp[904] = sp[826] + sp[880];
    sp[905] = sp[881] + sp[827];
    sp[906] = sp[834] + sp[880];
    sp[907] = sp[835] + sp[882];
    sp[908] = sp[883] + sp[836];
    sp[909] = sp[843] + sp[881];
    sp[910] = sp[844] + sp[883];
    sp[911] = sp[884] + sp[845];
    sp[912] = sp[852] + sp[885];
    sp[913] = sp[853] + sp[886];
    sp[914] = sp[887] + sp[854];
    sp[915] = sp[768] + sp[792];
    sp[916] = sp[769] + sp[801];
    sp[917] = sp[810] + sp[770];
    sp[918] = sp[819] + sp[771];
    sp[919] = sp[772] + sp[828];
    sp[920] = sp[837] + sp[773];
    sp[921] = sp[855] + sp[888];
    sp[922] = sp[856] + sp[889];
    sp[923] = sp[890] + sp[857];
    sp[924] = sp[793] + sp[777];
    sp[925] = sp[778] + sp[802];
    sp[926] = sp[811] + sp[779];
    sp[927] = sp[820] + sp[780];
    sp[928] = sp[829] + sp[781];
    sp[929] = sp[838] + sp[782];
    sp[930] = sp[891] + sp[858];
    sp[931] = sp[892] + sp[859];
    sp[932] = sp[893] + sp[860];
    sp[933] = sp[786] + sp[794];
    sp[934] = sp[787] + sp[803];
    sp[935] = sp[788] + sp[812];
    sp[936] = sp[789] + sp[821];
    sp[937] = sp[790] + sp[830];
    sp[938] = sp[839] + sp[791];
    sp[939] = sp[861] + sp[894];
    sp[940] = sp[862] + sp[895];
    sp[941] = sp[896] + sp[863];
    sp[942] = sp[822] + sp[798];
    sp[943] = sp[799] + sp[831];
    sp[944] = sp[840] + sp[800];
    sp[945] = sp[864] + sp[897];
    sp[946] = sp[865] + sp[898];
    sp[947] = sp[899] + sp[866];
    sp[948] = sp[823] + sp[807];
    sp[949] = sp[832] + sp[808];
    sp[950] = sp[841] + sp[809];
    sp[951] = sp[900] + sp[867];
    sp[952] = sp[901] + sp[868];
    sp[953] = sp[902] + sp[869];
    sp[954] = sp[816] + sp[824];
    sp[955] = sp[817] + sp[833];
    sp[956] = sp[842] + sp[818];
    sp[957] = sp[870] + sp[903];
    sp[958] = sp[871] + sp[904];
    sp[959] = sp[905] + sp[872];
    sp[960] = sp[873] + sp[906];
    sp[961] = sp[874] + sp[907];
    sp[962] = sp[908] + sp[875];
    sp[963] = sp[909] + sp[876];
    sp[964] = sp[910] + sp[877];
    sp[965] = sp[911] + sp[878];
    sp[966] = sp[200] * sp[200];
    sp[967] = sp[200] * sp[201];
    sp[968] = sp[200] * sp[202];
    sp[969] = sp[209] * sp[200];
    sp[970] = sp[200] * sp[210];
    sp[971] = sp[200] * sp[211];
    sp[972] = sp[200] * sp[218];
    sp[973] = sp[200] * sp[219];
    sp[974] = sp[200] * sp[220];
    sp[975] = sp[201] * sp[201];
    sp[976] = sp[201] * sp[202];
    sp[977] = sp[209] * sp[201];
    sp[978] = sp[210] * sp[201];
    sp[979] = sp[201] * sp[211];
    sp[980] = sp[218] * sp[201];
    sp[981] = sp[201] * sp[219];
    sp[982] = sp[201] * sp[220];
    sp[983] = sp[202] * sp[202];
    sp[984] = sp[209] * sp[202];
    sp[985] = sp[210] * sp[202];
    sp[986] = sp[202] * sp[211];
    sp[987] = sp[218] * sp[202];
    sp[988] = sp[219] * sp[202];
    sp[989] = sp[220] * sp[202];
    sp[990] = sp[209] * sp[209];
    sp[991] = sp[209] * sp[210];
    sp[992] = sp[209] * sp[211];
    sp[993] = sp[209] * sp[218];
    sp[994] = sp[209] * sp[219];
    sp[995] = sp[209] * sp[220];
    sp[996] = sp[210] * sp[210];
    sp[997] = sp[210] * sp[211];
    sp[998] = sp[218] * sp[210];
    sp[999] = sp[210] * sp[219];
    sp[1000] = sp[210] * sp[220];
    sp[1001] = sp[211] * sp[211];
    sp[1002] = sp[218] * sp[211];
    sp[1003] = sp[219] * sp[211];
    sp[1004] = sp[220] * sp[211];
    sp[1005] = sp[218] * sp[218];
    sp[1006] = sp[218] * sp[219];
    sp[1007] = sp[218] * sp[220];
    sp[1008] = sp[219] * sp[219];
    sp[1009] = sp[219] * sp[220];
    sp[1010] = sp[220] * sp[220];
    sp[1011] = sp[34] * sp[64];
    sp[1012] = sp[38] * sp[64];
    sp[1013] = sp[64] * sp[42];
    sp[1014] = sp[34] * sp[68];
    sp[1015] = sp[38] * sp[68];
    sp[1016] = sp[68] * sp[42];
    sp[1017] = sp[34] * sp[72];
    sp[1018] = sp[38] * sp[72];
    sp[1019] = sp[72] * sp[42];
    sp[1020] = sp[1011] + sp[1011];
    sp[1021] = sp[1012] + sp[1014];
    sp[1022] = sp[1017] + sp[1013];
    sp[1023] = sp[1015] + sp[1015];
    sp[1024] = sp[1018] + sp[1016];
    sp[1025] = sp[1019] + sp[1019];
    sp[1026] = sp[225] * sp[1020];
    sp[1027] = sp[225] * sp[1021];
    sp[1028] = sp[225] * sp[1022];
    sp[1029] = sp[225] * sp[1023];
    sp[1030] = sp[225] * sp[1024];
    sp[1031] = sp[225] * sp[1025];
    sp[1032] = sp[966] + sp[1026];
    sp[1033] = sp[967] + sp[1027];
    sp[1034] = sp[968] + sp[1028];
    sp[1035] = sp[975] + sp[1029];
    sp[1036] = sp[976] + sp[1030];
    sp[1037] = sp[983] + sp[1031];
    sp[1038] = sp[990] + sp[1026];
    sp[1039] = sp[991] + sp[1027];
    sp[1040] = sp[992] + sp[1028];
    sp[1041] = sp[996] + sp[1029];
    sp[1042] = sp[997] + sp[1030];
    sp[1043] = sp[1001] + sp[1031];
    sp[1044] = sp[1005] + sp[1026];
    sp[1045] = sp[1006] + sp[1027];
    sp[1046] = sp[1007] + sp[1028];
    sp[1047] = sp[1008] + sp[1029];
    sp[1048] = sp[1009] + sp[1030];
    sp[1049] = sp[1010] + sp[1031];
    sp[1050] = sp[1032] + sp[1032];
    sp[1051] = sp[1033] + sp[1033];
    sp[1052] = sp[1034] + sp[1034];
    sp[1053] = sp[969] + sp[969];
    sp[1054] = sp[970] + sp[970];
    sp[1055] = sp[971] + sp[971];
    sp[1056] = sp[972] + sp[972];
    sp[1057] = sp[973] + sp[973];
    sp[1058] = sp[974] + sp[974];
    sp[1059] = sp[1035] + sp[1035];
    sp[1060] = sp[1036] + sp[1036];
    sp[1061] = sp[977] + sp[977];
    sp[1062] = sp[978] + sp[978];
    sp[1063] = sp[979] + sp[979];
    sp[1064] = sp[980] + sp[980];
    sp[1065] = sp[981] + sp[981];
    sp[1066] = sp[982] + sp[982];
    sp[1067] = sp[1037] + sp[1037];
    sp[1068] = sp[984] + sp[984];
    sp[1069] = sp[985] + sp[985];
    sp[1070] = sp[986] + sp[986];
    sp[1071] = sp[987] + sp[987];
    sp[1072] = sp[988] + sp[988];
    sp[1073] = sp[989] + sp[989];
    sp[1074] = sp[1038] + sp[1038];
    sp[1075] = sp[1039] + sp[1039];
    sp[1076] = sp[1040] + sp[1040];
    sp[1077] = sp[993] + sp[993];
    sp[1078] = sp[994] + sp[994];
    sp[1079] = sp[995] + sp[995];
    sp[1080] = sp[1041] + sp[1041];
    sp[1081] = sp[1042] + sp[1042];
    sp[1082] = sp[998] + sp[998];
    sp[1083] = sp[999] + sp[999];
    sp[1084] = sp[1000] + sp[1000];
    sp[1085] = sp[1043] + sp[1043];
    sp[1086] = sp[1002] + sp[1002];
    sp[1087] = sp[1003] + sp[1003];
    sp[1088] = sp[1004] + sp[1004];
    sp[1089] = sp[1044] + sp[1044];
    sp[1090] = sp[1045] + sp[1045];
    sp[1091] = sp[1046] + sp[1046];
    sp[1092] = sp[1047] + sp[1047];
    sp[1093] = sp[1048] + sp[1048];
    sp[1094] = sp[1049] + sp[1049];
    sp[1095] = sp[912] + -1 * sp[1050];
    sp[1096] = sp[913] + -1 * sp[1051];
    sp[1097] = sp[914] + -1 * sp[1052];
    sp[1098] = sp[915] + -1 * sp[1053];
    sp[1099] = sp[916] + -1 * sp[1054];
    sp[1100] = sp[917] + -1 * sp[1055];
    sp[1101] = sp[918] + -1 * sp[1056];
    sp[1102] = sp[919] + -1 * sp[1057];
    sp[1103] = sp[920] + -1 * sp[1058];
    sp[1104] = sp[921] + -1 * sp[1051];
    sp[1105] = sp[922] + -1 * sp[1059];
    sp[1106] = sp[923] + -1 * sp[1060];
    sp[1107] = sp[924] + -1 * sp[1061];
    sp[1108] = sp[925] + -1 * sp[1062];
    sp[1109] = sp[926] + -1 * sp[1063];
    sp[1110] = sp[927] + -1 * sp[1064];
    sp[1111] = sp[928] + -1 * sp[1065];
    sp[1112] = sp[929] + -1 * sp[1066];
    sp[1113] = sp[930] + -1 * sp[1052];
    sp[1114] = sp[931] + -1 * sp[1060];
    sp[1115] = sp[932] + -1 * sp[1067];
    sp[1116] = sp[933] + -1 * sp[1068];
    sp[1117] = sp[934] + -1 * sp[1069];
    sp[1118] = sp[935] + -1 * sp[1070];
    sp[1119] = sp[936] + -1 * sp[1071];
    sp[1120] = sp[937] + -1 * sp[1072];
    sp[1121] = sp[938] + -1 * sp[1073];
    sp[1122] = sp[939] + -1 * sp[1074];
    sp[1123] = sp[940] + -1 * sp[1075];
    sp[1124] = sp[941] + -1 * sp[1076];
    sp[1125] = sp[942] + -1 * sp[1077];
    sp[1126] = sp[943] + -1 * sp[1078];
    sp[1127] = sp[944] + -1 * sp[1079];
    sp[1128] = sp[945] + -1 * sp[1075];
    sp[1129] = sp[946] + -1 * sp[1080];
    sp[1130] = sp[947] + -1 * sp[1081];
    sp[1131] = sp[948] + -1 * sp[1082];
    sp[1132] = sp[949] + -1 * sp[1083];
    sp[1133] = sp[950] + -1 * sp[1084];
    sp[1134] = sp[951] + -1 * sp[1076];
    sp[1135] = sp[952] + -1 * sp[1081];
    sp[1136] = sp[953] + -1 * sp[1085];
    sp[1137] = sp[954] + -1 * sp[1086];
    sp[1138] = sp[955] + -1 * sp[1087];
    sp[1139] = sp[956] + -1 * sp[1088];
    sp[1140] = sp[957] + -1 * sp[1089];
    sp[1141] = sp[958] + -1 * sp[1090];
    sp[1142] = sp[959] + -1 * sp[1091];
    sp[1143] = sp[960] + -1 * sp[1090];
    sp[1144] = sp[961] + -1 * sp[1092];
    sp[1145] = sp[962] + -1 * sp[1093];
    sp[1146] = sp[963] + -1 * sp[1091];
    sp[1147] = sp[964] + -1 * sp[1093];
    sp[1148] = sp[965] + -1 * sp[1094];
    sp[1149] = sp[1095] * sp[272];
    sp[1150] = sp[1096] * sp[272];
    sp[1151] = sp[1097] * sp[272];
    sp[1152] = sp[1098] * sp[272];
    sp[1153] = sp[1099] * sp[272];
    sp[1154] = sp[1100] * sp[272];
    sp[1155] = sp[1101] * sp[272];
    sp[1156] = sp[1102] * sp[272];
    sp[1157] = sp[1103] * sp[272];
    sp[1158] = sp[1104] * sp[272];
    sp[1159] = sp[1105] * sp[272];
    sp[1160] = sp[1106] * sp[272];
    sp[1161] = sp[1107] * sp[272];
    sp[1162] = sp[1108] * sp[272];
    sp[1163] = sp[1109] * sp[272];
    sp[1164] = sp[1110] * sp[272];
    sp[1165] = sp[1111] * sp[272];
    sp[1166] = sp[1112] * sp[272];
    sp[1167] = sp[1113] * sp[272];
    sp[1168] = sp[1114] * sp[272];
    sp[1169] = sp[1115] * sp[272];
    sp[1170] = sp[1116] * sp[272];
    sp[1171] = sp[1117] * sp[272];
    sp[1172] = sp[1118] * sp[272];
    sp[1173] = sp[1119] * sp[272];
    sp[1174] = sp[1120] * sp[272];
    sp[1175] = sp[1121] * sp[272];
    sp[1176] = sp[1122] * sp[272];
    sp[1177] = sp[1123] * sp[272];
    sp[1178] = sp[1124] * sp[272];
    sp[1179] = sp[1125] * sp[272];
    sp[1180] = sp[1126] * sp[272];
    sp[1181] = sp[1127] * sp[272];
    sp[1182] = sp[1128] * sp[272];
    sp[1183] = sp[1129] * sp[272];
    sp[1184] = sp[1130] * sp[272];
    sp[1185] = sp[1131] * sp[272];
    sp[1186] = sp[1132] * sp[272];
    sp[1187] = sp[1133] * sp[272];
    sp[1188] = sp[1134] * sp[272];
    sp[1189] = sp[1135] * sp[272];
    sp[1190] = sp[1136] * sp[272];
    sp[1191] = sp[1137] * sp[272];
    sp[1192] = sp[1138] * sp[272];
    sp[1193] = sp[1139] * sp[272];
    sp[1194] = sp[1140] * sp[272];
    sp[1195] = sp[1141] * sp[272];
    sp[1196] = sp[1142] * sp[272];
    sp[1197] = sp[1143] * sp[272];
    sp[1198] = sp[1144] * sp[272];
    sp[1199] = sp[1145] * sp[272];
    sp[1200] = sp[1146] * sp[272];
    sp[1201] = sp[1147] * sp[272];
    sp[1202] = sp[1148] * sp[272];
    sp[1203] = sp[1149] + sp[684];
    sp[1204] = sp[1150] + sp[693];
    sp[1205] = sp[1151] + sp[702];
    sp[1206] = sp[1152] + sp[711];
    sp[1207] = sp[1153] + sp[720];
    sp[1208] = sp[1154] + sp[729];
    sp[1209] = sp[1155] + sp[738];
    sp[1210] = sp[1156] + sp[747];
    sp[1211] = sp[1157] + sp[756];
    sp[1212] = sp[1158] + sp[685];
    sp[1213] = sp[1159] + sp[694];
    sp[1214] = sp[1160] + sp[703];
    sp[1215] = sp[1161] + sp[712];
    sp[1216] = sp[1162] + sp[721];
    sp[1217] = sp[1163] + sp[730];
    sp[1218] = sp[1164] + sp[739];
    sp[1219] = sp[1165] + sp[748];
    sp[1220] = sp[1166] + sp[757];
    sp[1221] = sp[1167] + sp[686];
    sp[1222] = sp[1168] + sp[695];
    sp[1223] = sp[1169] + sp[704];
    sp[1224] = sp[1170] + sp[713];
    sp[1225] = sp[1171] + sp[722];
    sp[1226] = sp[1172] + sp[731];
    sp[1227] = sp[1173] + sp[740];
    sp[1228] = sp[1174] + sp[749];
    sp[1229] = sp[1175] + sp[758];
    sp[1230] = sp[1152] + sp[687];
    sp[1231] = sp[1153] + sp[688];
    sp[1232] = sp[1154] + sp[689];
    sp[1233] = sp[1155] + sp[690];
    sp[1234] = sp[1156] + sp[691];
    sp[1235] = sp[1157] + sp[692];
    sp[1236] = sp[1161] + sp[696];
    sp[1237] = sp[1162] + sp[697];
    sp[1238] = sp[1163] + sp[698];
    sp[1239] = sp[1164] + sp[699];
    sp[1240] = sp[1165] + sp[700];
    sp[1241] = sp[1166] + sp[701];
    sp[1242] = sp[1170] + sp[705];
    sp[1243] = sp[1171] + sp[706];
    sp[1244] = sp[1172] + sp[707];
    sp[1245] = sp[1173] + sp[708];
    sp[1246] = sp[1174] + sp[709];
    sp[1247] = sp[1175] + sp[710];
    sp[1248] = sp[1176] + sp[714];
    sp[1249] = sp[1177] + sp[723];
    sp[1250] = sp[1178] + sp[732];
    sp[1251] = sp[1179] + sp[741];
    sp[1252] = sp[1180] + sp[750];
    sp[1253] = sp[1181] + sp[759];
    sp[1254] = sp[1182] + sp[715];
    sp[1255] = sp[1183] + sp[724];
    sp[1256] = sp[1184] + sp[733];
    sp[1257] = sp[1185] + sp[742];
    sp[1258] = sp[1186] + sp[751];
    sp[1259] = sp[1187] + sp[760];
    sp[1260] = sp[1188] + sp[716];
    sp[1261] = sp[1189] + sp[725];
    sp[1262] = sp[1190] + sp[734];
    sp[1263] = sp[1191] + sp[743];
    sp[1264] = sp[1192] + sp[752];
    sp[1265] = sp[1193] + sp[761];
    sp[1266] = sp[1179] + sp[717];
    sp[1267] = sp[1180] + sp[718];
    sp[1268] = sp[1181] + sp[719];
    sp[1269] = sp[1185] + sp[726];
    sp[1270] = sp[1186] + sp[727];
    sp[1271] = sp[1187] + sp[728];
    sp[1272] = sp[1191] + sp[735];
    sp[1273] = sp[1192] + sp[736];
    sp[1274] = sp[1193] + sp[737];
    sp[1275] = sp[1194] + sp[744];
    sp[1276] = sp[1195] + sp[753];
    sp[1277] = sp[1196] + sp[762];
    sp[1278] = sp[1197] + sp[745];
    sp[1279] = sp[1198] + sp[754];
    sp[1280] = sp[1199] + sp[763];
    sp[1281] = sp[1200] + sp[746];
    sp[1282] = sp[1201] + sp[755];
    sp[1283] = sp[1202] + sp[764];
    sp[1284] = sp[302] * sp[25];
    sp[1285] = sp[302] * sp[26];
    sp[1286] = sp[302] * sp[27];
    sp[1287] = sp[302] * sp[28];
    sp[1288] = sp[302] * sp[29];
    sp[1289] = sp[302] * sp[30];
    sp[1290] = sp[684] + sp[1284];
    sp[1291] = sp[685] + sp[1285];
    sp[1292] = sp[686] + sp[1286];
    sp[1293] = sp[693] + sp[1285];
    sp[1294] = sp[694] + sp[1287];
    sp[1295] = sp[695] + sp[1288];
    sp[1296] = sp[702] + sp[1286];
    sp[1297] = sp[703] + sp[1288];
    sp[1298] = sp[704] + sp[1289];
    sp[1299] = sp[714] + sp[1284];
    sp[1300] = sp[715] + sp[1285];
    sp[1301] = sp[716] + sp[1286];
    sp[1302] = sp[723] + sp[1285];
    sp[1303] = sp[724] + sp[1287];
    sp[1304] = sp[725] + sp[1288];
    sp[1305] = sp[732] + sp[1286];
    sp[1306] = sp[733] + sp[1288];
    sp[1307] = sp[734] + sp[1289];
    sp[1308] = sp[744] + sp[1284];
    sp[1309] = sp[745] + sp[1285];
    sp[1310] = sp[746] + sp[1286];
    sp[1311] = sp[753] + sp[1285];
    sp[1312] = sp[754] + sp[1287];
    sp[1313] = sp[755] + sp[1288];
    sp[1314] = sp[762] + sp[1286];
    sp[1315] = sp[763] + sp[1288];
    sp[1316] = sp[764] + sp[1289];
    sp[1317] = sp[1203] + sp[1290];
    sp[1318] = sp[1204] + sp[1291];
    sp[1319] = sp[1205] + sp[1292];
    sp[1320] = sp[1206] + sp[687];
    sp[1321] = sp[1207] + sp[688];
    sp[1322] = sp[1208] + sp[689];
    sp[1323] = sp[1209] + sp[690];
    sp[1324] = sp[1210] + sp[691];
    sp[1325] = sp[1211] + sp[692];
    sp[1326] = sp[1212] + sp[1293];
    sp[1327] = sp[1213] + sp[1294];
    sp[1328] = sp[1214] + sp[1295];
    sp[1329] = sp[1215] + sp[696];
    sp[1330] = sp[1216] + sp[697];
    sp[1331] = sp[1217] + sp[698];
    sp[1332] = sp[1218] + sp[699];
    sp[1333] = sp[1219] + sp[700];
    sp[1334] = sp[1220] + sp[701];
    sp[1335] = sp[1221] + sp[1296];
    sp[1336] = sp[1222] + sp[1297];
    sp[1337] = sp[1223] + sp[1298];
    sp[1338] = sp[1224] + sp[705];
    sp[1339] = sp[1225] + sp[706];
    sp[1340] = sp[1226] + sp[707];
    sp[1341] = sp[1227] + sp[708];
    sp[1342] = sp[1228] + sp[709];
    sp[1343] = sp[1229] + sp[710];
    sp[1344] = sp[1230] + sp[711];
    sp[1345] = sp[1231] + sp[720];
    sp[1346] = sp[1232] + sp[729];
    sp[1347] = sp[1233] + sp[738];
    sp[1348] = sp[1234] + sp[747];
    sp[1349] = sp[1235] + sp[756];
    sp[1350] = sp[1236] + sp[712];
    sp[1351] = sp[1237] + sp[721];
    sp[1352] = sp[1238] + sp[730];
    sp[1353] = sp[1239] + sp[739];
    sp[1354] = sp[1240] + sp[748];
    sp[1355] = sp[1241] + sp[757];
    sp[1356] = sp[1242] + sp[713];
    sp[1357] = sp[1243] + sp[722];
    sp[1358] = sp[1244] + sp[731];
    sp[1359] = sp[1245] + sp[740];
    sp[1360] = sp[1246] + sp[749];
    sp[1361] = sp[1247] + sp[758];
    sp[1362] = sp[1248] + sp[1299];
    sp[1363] = sp[1249] + sp[1300];
    sp[1364] = sp[1250] + sp[1301];
    sp[1365] = sp[1251] + sp[717];
    sp[1366] = sp[1252] + sp[718];
    sp[1367] = sp[1253] + sp[719];
    sp[1368] = sp[1254] + sp[1302];
    sp[1369] = sp[1255] + sp[1303];
    sp[1370] = sp[1256] + sp[1304];
    sp[1371] = sp[1257] + sp[726];
    sp[1372] = sp[1258] + sp[727];
    sp[1373] = sp[1259] + sp[728];
    sp[1374] = sp[1260] + sp[1305];
    sp[1375] = sp[1261] + sp[1306];
    sp[1376] = sp[1262] + sp[1307];
    sp[1377] = sp[1263] + sp[735];
    sp[1378] = sp[1264] + sp[736];
    sp[1379] = sp[1265] + sp[737];
    sp[1380] = sp[1266] + sp[741];
    sp[1381] = sp[1267] + sp[750];
    sp[1382] = sp[1268] + sp[759];
    sp[1383] = sp[1269] + sp[742];
    sp[1384] = sp[1270] + sp[751];
    sp[1385] = sp[1271] + sp[760];
    sp[1386] = sp[1272] + sp[743];
    sp[1387] = sp[1273] + sp[752];
    sp[1388] = sp[1274] + sp[761];
    sp[1389] = sp[1275] + sp[1308];
    sp[1390] = sp[1276] + sp[1309];
    sp[1391] = sp[1277] + sp[1310];
    sp[1392] = sp[1278] + sp[1311];
    sp[1393] = sp[1279] + sp[1312];
    sp[1394] = sp[1280] + sp[1313];
    sp[1395] = sp[1281] + sp[1314];
    sp[1396] = sp[1282] + sp[1315];
    sp[1397] = sp[1283] + sp[1316];
    sp[1398] = sp[439] * sp[386];
    sp[1399] = sp[440] * sp[386];
    sp[1400] = sp[441] * sp[386];
    sp[1401] = sp[442] * sp[386];
    sp[1402] = sp[443] * sp[386];
    sp[1403] = sp[444] * sp[386];
    sp[1404] = sp[445] * sp[386];
    sp[1405] = sp[446] * sp[386];
    sp[1406] = sp[447] * sp[386];
    sp[1407] = sp[439] * sp[387];
    sp[1408] = sp[440] * sp[387];
    sp[1409] = sp[441] * sp[387];
    sp[1410] = sp[442] * sp[387];
    sp[1411] = sp[443] * sp[387];
    sp[1412] = sp[444] * sp[387];
    sp[1413] = sp[445] * sp[387];
    sp[1414] = sp[446] * sp[387];
    sp[1415] = sp[447] * sp[387];
    sp[1416] = sp[439] * sp[388];
    sp[1417] = sp[440] * sp[388];
    sp[1418] = sp[441] * sp[388];
    sp[1419] = sp[442] * sp[388];
    sp[1420] = sp[443] * sp[388];
    sp[1421] = sp[444] * sp[388];
    sp[1422] = sp[445] * sp[388];
    sp[1423] = sp[446] * sp[388];
    sp[1424] = sp[447] * sp[388];
    sp[1425] = sp[439] * sp[395];
    sp[1426] = sp[440] * sp[395];
    sp[1427] = sp[441] * sp[395];
    sp[1428] = sp[442] * sp[395];
    sp[1429] = sp[443] * sp[395];
    sp[1430] = sp[444] * sp[395];
    sp[1431] = sp[445] * sp[395];
    sp[1432] = sp[446] * sp[395];
    sp[1433] = sp[447] * sp[395];
    sp[1434] = sp[439] * sp[396];
    sp[1435] = sp[440] * sp[396];
    sp[1436] = sp[441] * sp[396];
    sp[1437] = sp[442] * sp[396];
    sp[1438] = sp[443] * sp[396];
    sp[1439] = sp[444] * sp[396];
    sp[1440] = sp[445] * sp[396];
    sp[1441] = sp[446] * sp[396];
    sp[1442] = sp[447] * sp[396];
    sp[1443] = sp[439] * sp[397];
    sp[1444] = sp[440] * sp[397];
    sp[1445] = sp[441] * sp[397];
    sp[1446] = sp[442] * sp[397];
    sp[1447] = sp[443] * sp[397];
    sp[1448] = sp[444] * sp[397];
    sp[1449] = sp[445] * sp[397];
    sp[1450] = sp[446] * sp[397];
    sp[1451] = sp[447] * sp[397];
    sp[1452] = sp[439] * sp[404];
    sp[1453] = sp[440] * sp[404];
    sp[1454] = sp[441] * sp[404];
    sp[1455] = sp[442] * sp[404];
    sp[1456] = sp[443] * sp[404];
    sp[1457] = sp[444] * sp[404];
    sp[1458] = sp[445] * sp[404];
    sp[1459] = sp[446] * sp[404];
    sp[1460] = sp[447] * sp[404];
    sp[1461] = sp[439] * sp[405];
    sp[1462] = sp[440] * sp[405];
    sp[1463] = sp[441] * sp[405];
    sp[1464] = sp[442] * sp[405];
    sp[1465] = sp[443] * sp[405];
    sp[1466] = sp[444] * sp[405];
    sp[1467] = sp[445] * sp[405];
    sp[1468] = sp[446] * sp[405];
    sp[1469] = sp[447] * sp[405];
    sp[1470] = sp[439] * sp[406];
    sp[1471] = sp[440] * sp[406];
    sp[1472] = sp[441] * sp[406];
    sp[1473] = sp[442] * sp[406];
    sp[1474] = sp[443] * sp[406];
    sp[1475] = sp[444] * sp[406];
    sp[1476] = sp[445] * sp[406];
    sp[1477] = sp[446] * sp[406];
    sp[1478] = sp[447] * sp[406];
    sp[1479] = sp[200] * sp[341];
    sp[1480] = sp[201] * sp[341];
    sp[1481] = sp[202] * sp[341];
    sp[1482] = sp[209] * sp[341];
    sp[1483] = sp[210] * sp[341];
    sp[1484] = sp[211] * sp[341];
    sp[1485] = sp[218] * sp[341];
    sp[1486] = sp[219] * sp[341];
    sp[1487] = sp[220] * sp[341];
    sp[1488] = sp[200] * sp[342];
    sp[1489] = sp[201] * sp[342];
    sp[1490] = sp[202] * sp[342];
    sp[1491] = sp[209] * sp[342];
    sp[1492] = sp[210] * sp[342];
    sp[1493] = sp[211] * sp[342];
    sp[1494] = sp[218] * sp[342];
    sp[1495] = sp[219] * sp[342];
    sp[1496] = sp[220] * sp[342];
    sp[1497] = sp[200] * sp[343];
    sp[1498] = sp[201] * sp[343];
    sp[1499] = sp[343] * sp[202];
    sp[1500] = sp[209] * sp[343];
    sp[1501] = sp[210] * sp[343];
    sp[1502] = sp[343] * sp[211];
    sp[1503] = sp[218] * sp[343];
    sp[1504] = sp[219] * sp[343];
    sp[1505] = sp[343] * sp[220];
    sp[1506] = sp[200] * sp[350];
    sp[1507] = sp[201] * sp[350];
    sp[1508] = sp[202] * sp[350];
    sp[1509] = sp[209] * sp[350];
    sp[1510] = sp[210] * sp[350];
    sp[1511] = sp[211] * sp[350];
    sp[1512] = sp[218] * sp[350];
    sp[1513] = sp[219] * sp[350];
    sp[1514] = sp[220] * sp[350];
    sp[1515] = sp[200] * sp[351];
    sp[1516] = sp[201] * sp[351];
    sp[1517] = sp[202] * sp[351];
    sp[1518] = sp[209] * sp[351];
    sp[1519] = sp[210] * sp[351];
    sp[1520] = sp[211] * sp[351];
    sp[1521] = sp[218] * sp[351];
    sp[1522] = sp[219] * sp[351];
    sp[1523] = sp[220] * sp[351];
    sp[1524] = sp[200] * sp[352];
    sp[1525] = sp[201] * sp[352];
    sp[1526] = sp[352] * sp[202];
    sp[1527] = sp[209] * sp[352];
    sp[1528] = sp[210] * sp[352];
    sp[1529] = sp[352] * sp[211];
    sp[1530] = sp[218] * sp[352];
    sp[1531] = sp[219] * sp[352];
    sp[1532] = sp[352] * sp[220];
    sp[1533] = sp[200] * sp[359];
    sp[1534] = sp[201] * sp[359];
    sp[1535] = sp[202] * sp[359];
    sp[1536] = sp[209] * sp[359];
    sp[1537] = sp[210] * sp[359];
    sp[1538] = sp[211] * sp[359];
    sp[1539] = sp[218] * sp[359];
    sp[1540] = sp[219] * sp[359];
    sp[1541] = sp[220] * sp[359];
    sp[1542] = sp[200] * sp[360];
    sp[1543] = sp[201] * sp[360];
    sp[1544] = sp[202] * sp[360];
    sp[1545] = sp[209] * sp[360];
    sp[1546] = sp[210] * sp[360];
    sp[1547] = sp[211] * sp[360];
    sp[1548] = sp[218] * sp[360];
    sp[1549] = sp[219] * sp[360];
    sp[1550] = sp[220] * sp[360];
    sp[1551] = sp[200] * sp[361];
    sp[1552] = sp[201] * sp[361];
    sp[1553] = sp[361] * sp[202];
    sp[1554] = sp[209] * sp[361];
    sp[1555] = sp[210] * sp[361];
    sp[1556] = sp[361] * sp[211];
    sp[1557] = sp[218] * sp[361];
    sp[1558] = sp[219] * sp[361];
    sp[1559] = sp[361] * sp[220];
    sp[1560] = sp[325] * sp[1020];
    sp[1561] = sp[325] * sp[1021];
    sp[1562] = sp[325] * sp[1022];
    sp[1563] = sp[325] * sp[1023];
    sp[1564] = sp[325] * sp[1024];
    sp[1565] = sp[325] * sp[1025];
    sp[1566] = sp[1560] + sp[1479];
    sp[1567] = sp[1561] + sp[1488];
    sp[1568] = sp[1497] + sp[1562];
    sp[1569] = sp[1561] + sp[1480];
    sp[1570] = sp[1563] + sp[1489];
    sp[1571] = sp[1498] + sp[1564];
    sp[1572] = sp[1562] + sp[1481];
    sp[1573] = sp[1564] + sp[1490];
    sp[1574] = sp[1499] + sp[1565];
    sp[1575] = sp[1560] + sp[1509];
    sp[1576] = sp[1561] + sp[1518];
    sp[1577] = sp[1527] + sp[1562];
    sp[1578] = sp[1561] + sp[1510];
    sp[1579] = sp[1563] + sp[1519];
    sp[1580] = sp[1528] + sp[1564];
    sp[1581] = sp[1562] + sp[1511];
    sp[1582] = sp[1564] + sp[1520];
    sp[1583] = sp[1529] + sp[1565];
    sp[1584] = sp[1560] + sp[1539];
    sp[1585] = sp[1561] + sp[1548];
    sp[1586] = sp[1557] + sp[1562];
    sp[1587] = sp[1561] + sp[1540];
    sp[1588] = sp[1563] + sp[1549];
    sp[1589] = sp[1558] + sp[1564];
    sp[1590] = sp[1562] + sp[1541];
    sp[1591] = sp[1564] + sp[1550];
    sp[1592] = sp[1559] + sp[1565];
    sp[1593] = sp[64] * sp[14];
    sp[1594] = sp[64] * sp[17];
    sp[1595] = sp[64] * sp[18];
    sp[1596] = sp[68] * sp[14];
    sp[1597] = sp[68] * sp[17];
    sp[1598] = sp[68] * sp[18];
    sp[1599] = sp[72] * sp[14];
    sp[1600] = sp[72] * sp[17];
    sp[1601] = sp[72] * sp[18];
    sp[1602] = sp[1593] + sp[1593];
    sp[1603] = sp[1596] + sp[1594];
    sp[1604] = sp[1595] + sp[1599];
    sp[1605] = sp[1597] + sp[1597];
    sp[1606] = sp[1598] + sp[1600];
    sp[1607] = sp[1601] + sp[1601];
    sp[1608] = sp[225] * sp[1602];
    sp[1609] = sp[225] * sp[1603];
    sp[1610] = sp[225] * sp[1604];
    sp[1611] = sp[225] * sp[1605];
    sp[1612] = sp[225] * sp[1606];
    sp[1613] = sp[225] * sp[1607];
    sp[1614] = sp[1479] + sp[1608];
    sp[1615] = sp[1480] + sp[1609];
    sp[1616] = sp[1481] + sp[1610];
    sp[1617] = sp[1488] + sp[1609];
    sp[1618] = sp[1489] + sp[1611];
    sp[1619] = sp[1490] + sp[1612];
    sp[1620] = sp[1497] + sp[1610];
    sp[1621] = sp[1498] + sp[1612];
    sp[1622] = sp[1613] + sp[1499];
    sp[1623] = sp[1509] + sp[1608];
    sp[1624] = sp[1510] + sp[1609];
    sp[1625] = sp[1511] + sp[1610];
    sp[1626] = sp[1518] + sp[1609];
    sp[1627] = sp[1519] + sp[1611];
    sp[1628] = sp[1520] + sp[1612];
    sp[1629] = sp[1527] + sp[1610];
    sp[1630] = sp[1528] + sp[1612];
    sp[1631] = sp[1613] + sp[1529];
    sp[1632] = sp[1539] + sp[1608];
    sp[1633] = sp[1540] + sp[1609];
    sp[1634] = sp[1541] + sp[1610];
    sp[1635] = sp[1548] + sp[1609];
    sp[1636] = sp[1549] + sp[1611];
    sp[1637] = sp[1550] + sp[1612];
    sp[1638] = sp[1557] + sp[1610];
    sp[1639] = sp[1558] + sp[1612];
    sp[1640] = sp[1613] + sp[1559];
    sp[1641] = sp[1566] + sp[1614];
    sp[1642] = sp[1567] + sp[1615];
    sp[1643] = sp[1568] + sp[1616];
    sp[1644] = sp[1482] + sp[1506];
    sp[1645] = sp[1483] + sp[1515];
    sp[1646] = sp[1524] + sp[1484];
    sp[1647] = sp[1533] + sp[1485];
    sp[1648] = sp[1486] + sp[1542];
    sp[1649] = sp[1551] + sp[1487];
    sp[1650] = sp[1569] + sp[1617];
    sp[1651] = sp[1570] + sp[1618];
    sp[1652] = sp[1571] + sp[1619];
    sp[1653] = sp[1507] + sp[1491];
    sp[1654] = sp[1492] + sp[1516];
    sp[1655] = sp[1525] + sp[1493];
    sp[1656] = sp[1534] + sp[1494];
    sp[1657] = sp[1543] + sp[1495];
    sp[1658] = sp[1552] + sp[1496];
    sp[1659] = sp[1572] + sp[1620];
    sp[1660] = sp[1573] + sp[1621];
    sp[1661] = sp[1622] + sp[1574];
    sp[1662] = sp[1500] + sp[1508];
    sp[1663] = sp[1501] + sp[1517];
    sp[1664] = sp[1526] + sp[1502];
    sp[1665] = sp[1503] + sp[1535];
    sp[1666] = sp[1504] + sp[1544];
    sp[1667] = sp[1505] + sp[1553];
    sp[1668] = sp[1575] + sp[1623];
    sp[1669] = sp[1576] + sp[1624];
    sp[1670] = sp[1577] + sp[1625];
    sp[1671] = sp[1536] + sp[1512];
    sp[1672] = sp[1513] + sp[1545];
    sp[1673] = sp[1554] + sp[1514];
    sp[1674] = sp[1578] + sp[1626];
    sp[1675] = sp[1579] + sp[1627];
    sp[1676] = sp[1580] + sp[1628];
    sp[1677] = sp[1537] + sp[1521];
    sp[1678] = sp[1546] + sp[1522];
    sp[1679] = sp[1555] + sp[1523];
    sp[1680] = sp[1581] + sp[1629];
    sp[1681] = sp[1582] + sp[1630];
    sp[1682] = sp[1631] + sp[1583];
    sp[1683] = sp[1530] + sp[1538];
    sp[1684] = sp[1531] + sp[1547];
    sp[1685] = sp[1532] + sp[1556];
    sp[1686] = sp[1584] + sp[1632];
    sp[1687] = sp[1585] + sp[1633];
    sp[1688] = sp[1586] + sp[1634];
    sp[1689] = sp[1587] + sp[1635];
    sp[1690] = sp[1588] + sp[1636];
    sp[1691] = sp[1589] + sp[1637];
    sp[1692] = sp[1590] + sp[1638];
    sp[1693] = sp[1591] + sp[1639];
    sp[1694] = sp[1640] + sp[1592];
    sp[1695] = sp[156] * sp[386];
    sp[1696] = sp[156] * sp[387];
    sp[1697] = sp[156] * sp[388];
    sp[1698] = sp[156] * sp[395];
    sp[1699] = sp[156] * sp[396];
    sp[1700] = sp[156] * sp[397];
    sp[1701] = sp[156] * sp[404];
    sp[1702] = sp[156] * sp[405];
    sp[1703] = sp[156] * sp[406];
    sp[1704] = sp[157] * sp[386];
    sp[1705] = sp[157] * sp[387];
    sp[1706] = sp[157] * sp[388];
    sp[1707] = sp[157] * sp[395];
    sp[1708] = sp[157] * sp[396];
    sp[1709] = sp[157] * sp[397];
    sp[1710] = sp[157] * sp[404];
    sp[1711] = sp[157] * sp[405];
    sp[1712] = sp[157] * sp[406];
    sp[1713] = sp[158] * sp[386];
    sp[1714] = sp[158] * sp[387];
    sp[1715] = sp[158] * sp[388];
    sp[1716] = sp[158] * sp[395];
    sp[1717] = sp[158] * sp[396];
    sp[1718] = sp[158] * sp[397];
    sp[1719] = sp[158] * sp[404];
    sp[1720] = sp[158] * sp[405];
    sp[1721] = sp[158] * sp[406];
    sp[1722] = sp[162] * sp[386];
    sp[1723] = sp[162] * sp[387];
    sp[1724] = sp[162] * sp[388];
    sp[1725] = sp[162] * sp[395];
    sp[1726] = sp[162] * sp[396];
    sp[1727] = sp[162] * sp[397];
    sp[1728] = sp[162] * sp[404];
    sp[1729] = sp[162] * sp[405];
    sp[1730] = sp[162] * sp[406];
    sp[1731] = sp[163] * sp[386];
    sp[1732] = sp[163] * sp[387];
    sp[1733] = sp[163] * sp[388];
    sp[1734] = sp[163] * sp[395];
    sp[1735] = sp[163] * sp[396];
    sp[1736] = sp[163] * sp[397];
    sp[1737] = sp[163] * sp[404];
    sp[1738] = sp[163] * sp[405];
    sp[1739] = sp[163] * sp[406];
    sp[1740] = sp[164] * sp[386];
    sp[1741] = sp[164] * sp[387];
    sp[1742] = sp[164] * sp[388];
    sp[1743] = sp[164] * sp[395];
    sp[1744] = sp[164] * sp[396];
    sp[1745] = sp[164] * sp[397];
    sp[1746] = sp[164] * sp[404];
    sp[1747] = sp[164] * sp[405];
    sp[1748] = sp[164] * sp[406];
    sp[1749] = sp[168] * sp[386];
    sp[1750] = sp[168] * sp[387];
    sp[1751] = sp[168] * sp[388];
    sp[1752] = sp[168] * sp[395];
    sp[1753] = sp[168] * sp[396];
    sp[1754] = sp[168] * sp[397];
    sp[1755] = sp[168] * sp[404];
    sp[1756] = sp[168] * sp[405];
    sp[1757] = sp[168] * sp[406];
    sp[1758] = sp[169] * sp[386];
    sp[1759] = sp[169] * sp[387];
    sp[1760] = sp[169] * sp[388];
    sp[1761] = sp[169] * sp[395];
    sp[1762] = sp[169] * sp[396];
    sp[1763] = sp[169] * sp[397];
    sp[1764] = sp[169] * sp[404];
    sp[1765] = sp[169] * sp[405];
    sp[1766] = sp[169] * sp[406];
    sp[1767] = sp[170] * sp[386];
    sp[1768] = sp[170] * sp[387];
    sp[1769] = sp[170] * sp[388];
    sp[1770] = sp[170] * sp[395];
    sp[1771] = sp[170] * sp[396];
    sp[1772] = sp[170] * sp[397];
    sp[1773] = sp[170] * sp[404];
    sp[1774] = sp[170] * sp[405];
    sp[1775] = sp[170] * sp[406];
    sp[1776] = sp[34] * sp[14];
    sp[1777] = sp[38] * sp[14];
    sp[1778] = sp[42] * sp[14];
    sp[1779] = sp[34] * sp[17];
    sp[1780] = sp[38] * sp[17];
    sp[1781] = sp[42] * sp[17];
    sp[1782] = sp[34] * sp[18];
    sp[1783] = sp[38] * sp[18];
    sp[1784] = sp[18] * sp[42];
    sp[1785] = sp[1776] + sp[1776];
    sp[1786] = sp[1777] + sp[1779];
    sp[1787] = sp[1782] + sp[1778];
    sp[1788] = sp[1780] + sp[1780];
    sp[1789] = sp[1783] + sp[1781];
    sp[1790] = sp[1784] + sp[1784];
    sp[1791] = sp[143] * sp[1785];
    sp[1792] = sp[143] * sp[1786];
    sp[1793] = sp[143] * sp[1787];
    sp[1794] = sp[143] * sp[1788];
    sp[1795] = sp[143] * sp[1789];
    sp[1796] = sp[143] * sp[1790];
    sp[1797] = sp[1695] + sp[1791];
    sp[1798] = sp[1704] + sp[1792];
    sp[1799] = sp[1713] + sp[1793];
    sp[1800] = sp[1696] + sp[1792];
    sp[1801] = sp[1705] + sp[1794];
    sp[1802] = sp[1714] + sp[1795];
    sp[1803] = sp[1697] + sp[1793];
    sp[1804] = sp[1706] + sp[1795];
    sp[1805] = sp[1715] + sp[1796];
    sp[1806] = sp[1725] + sp[1791];
    sp[1807] = sp[1734] + sp[1792];
    sp[1808] = sp[1743] + sp[1793];
    sp[1809] = sp[1726] + sp[1792];
    sp[1810] = sp[1735] + sp[1794];
    sp[1811] = sp[1744] + sp[1795];
    sp[1812] = sp[1727] + sp[1793];
    sp[1813] = sp[1736] + sp[1795];
    sp[1814] = sp[1745] + sp[1796];
    sp[1815] = sp[1755] + sp[1791];
    sp[1816] = sp[1764] + sp[1792];
    sp[1817] = sp[1773] + sp[1793];
    sp[1818] = sp[1756] + sp[1792];
    sp[1819] = sp[1765] + sp[1794];
    sp[1820] = sp[1774] + sp[1795];
    sp[1821] = sp[1757] + sp[1793];
    sp[1822] = sp[1766] + sp[1795];
    sp[1823] = sp[1775] + sp[1796];
    sp[1824] = sp[420] * sp[79];
    sp[1825] = sp[420] * sp[80];
    sp[1826] = sp[420] * sp[81];
    sp[1827] = sp[420] * sp[82];
    sp[1828] = sp[420] * sp[83];
    sp[1829] = sp[420] * sp[84];
    sp[1830] = sp[1824] + sp[1695];
    sp[1831] = sp[1825] + sp[1696];
    sp[1832] = sp[1826] + sp[1697];
    sp[1833] = sp[1825] + sp[1704];
    sp[1834] = sp[1827] + sp[1705];
    sp[1835] = sp[1828] + sp[1706];
    sp[1836] = sp[1826] + sp[1713];
    sp[1837] = sp[1828] + sp[1714];
    sp[1838] = sp[1829] + sp[1715];
    sp[1839] = sp[1824] + sp[1725];
    sp[1840] = sp[1825] + sp[1726];
    sp[1841] = sp[1826] + sp[1727];
    sp[1842] = sp[1825] + sp[1734];
    sp[1843] = sp[1827] + sp[1735];
    sp[1844] = sp[1828] + sp[1736];
    sp[1845] = sp[1826] + sp[1743];
    sp[1846] = sp[1828] + sp[1744];
    sp[1847] = sp[1829] + sp[1745];
    sp[1848] = sp[1824] + sp[1755];
    sp[1849] = sp[1825] + sp[1756];
    sp[1850] = sp[1826] + sp[1757];
    sp[1851] = sp[1825] + sp[1764];
    sp[1852] = sp[1827] + sp[1765];
    sp[1853] = sp[1828] + sp[1766];
    sp[1854] = sp[1826] + sp[1773];
    sp[1855] = sp[1828] + sp[1774];
    sp[1856] = sp[1829] + sp[1775];
    sp[1857] = sp[1830] + sp[1797];
    sp[1858] = sp[1831] + sp[1798];
    sp[1859] = sp[1832] + sp[1799];
    sp[1860] = sp[1698] + sp[1722];
    sp[1861] = sp[1731] + sp[1699];
    sp[1862] = sp[1700] + sp[1740];
    sp[1863] = sp[1749] + sp[1701];
    sp[1864] = sp[1758] + sp[1702];
    sp[1865] = sp[1703] + sp[1767];
    sp[1866] = sp[1833] + sp[1800];
    sp[1867] = sp[1834] + sp[1801];
    sp[1868] = sp[1835] + sp[1802];
    sp[1869] = sp[1707] + sp[1723];
    sp[1870] = sp[1708] + sp[1732];
    sp[1871] = sp[1709] + sp[1741];
    sp[1872] = sp[1710] + sp[1750];
    sp[1873] = sp[1759] + sp[1711];
    sp[1874] = sp[1712] + sp[1768];
    sp[1875] = sp[1836] + sp[1803];
    sp[1876] = sp[1837] + sp[1804];
    sp[1877] = sp[1838] + sp[1805];
    sp[1878] = sp[1724] + sp[1716];
    sp[1879] = sp[1733] + sp[1717];
    sp[1880] = sp[1742] + sp[1718];
    sp[1881] = sp[1751] + sp[1719];
    sp[1882] = sp[1760] + sp[1720];
    sp[1883] = sp[1769] + sp[1721];
    sp[1884] = sp[1839] + sp[1806];
    sp[1885] = sp[1840] + sp[1807];
    sp[1886] = sp[1841] + sp[1808];
    sp[1887] = sp[1752] + sp[1728];
    sp[1888] = sp[1761] + sp[1729];
    sp[1889] = sp[1730] + sp[1770];
    sp[1890] = sp[1842] + sp[1809];
    sp[1891] = sp[1843] + sp[1810];
    sp[1892] = sp[1844] + sp[1811];
    sp[1893] = sp[1737] + sp[1753];
    sp[1894] = sp[1762] + sp[1738];
    sp[1895] = sp[1739] + sp[1771];
    sp[1896] = sp[1845] + sp[1812];
    sp[1897] = sp[1846] + sp[1813];
    sp[1898] = sp[1847] + sp[1814];
    sp[1899] = sp[1754] + sp[1746];
    sp[1900] = sp[1763] + sp[1747];
    sp[1901] = sp[1772] + sp[1748];
    sp[1902] = sp[1848] + sp[1815];
    sp[1903] = sp[1849] + sp[1816];
    sp[1904] = sp[1850] + sp[1817];
    sp[1905] = sp[1851] + sp[1818];
    sp[1906] = sp[1852] + sp[1819];
    sp[1907] = sp[1853] + sp[1820];
    sp[1908] = sp[1854] + sp[1821];
    sp[1909] = sp[1855] + sp[1822];
    sp[1910] = sp[1856] + sp[1823];
    sp[1911] = sp[1641] + -1 * sp[1857];
    sp[1912] = sp[1642] + -1 * sp[1858];
    sp[1913] = sp[1643] + -1 * sp[1859];
    sp[1914] = sp[1644] + -1 * sp[1860];
    sp[1915] = sp[1645] + -1 * sp[1861];
    sp[1916] = sp[1646] + -1 * sp[1862];
    sp[1917] = sp[1647] + -1 * sp[1863];
    sp[1918] = sp[1648] + -1 * sp[1864];
    sp[1919] = sp[1649] + -1 * sp[1865];
    sp[1920] = sp[1650] + -1 * sp[1866];
    sp[1921] = sp[1651] + -1 * sp[1867];
    sp[1922] = sp[1652] + -1 * sp[1868];
    sp[1923] = sp[1653] + -1 * sp[1869];
    sp[1924] = sp[1654] + -1 * sp[1870];
    sp[1925] = sp[1655] + -1 * sp[1871];
    sp[1926] = sp[1656] + -1 * sp[1872];
    sp[1927] = sp[1657] + -1 * sp[1873];
    sp[1928] = sp[1658] + -1 * sp[1874];
    sp[1929] = sp[1659] + -1 * sp[1875];
    sp[1930] = sp[1660] + -1 * sp[1876];
    sp[1931] = sp[1661] + -1 * sp[1877];
    sp[1932] = sp[1662] + -1 * sp[1878];
    sp[1933] = sp[1663] + -1 * sp[1879];
    sp[1934] = sp[1664] + -1 * sp[1880];
    sp[1935] = sp[1665] + -1 * sp[1881];
    sp[1936] = sp[1666] + -1 * sp[1882];
    sp[1937] = sp[1667] + -1 * sp[1883];
    sp[1938] = sp[1668] + -1 * sp[1884];
    sp[1939] = sp[1669] + -1 * sp[1885];
    sp[1940] = sp[1670] + -1 * sp[1886];
    sp[1941] = sp[1671] + -1 * sp[1887];
    sp[1942] = sp[1672] + -1 * sp[1888];
    sp[1943] = sp[1673] + -1 * sp[1889];
    sp[1944] = sp[1674] + -1 * sp[1890];
    sp[1945] = sp[1675] + -1 * sp[1891];
    sp[1946] = sp[1676] + -1 * sp[1892];
    sp[1947] = sp[1677] + -1 * sp[1893];
    sp[1948] = sp[1678] + -1 * sp[1894];
    sp[1949] = sp[1679] + -1 * sp[1895];
    sp[1950] = sp[1680] + -1 * sp[1896];
    sp[1951] = sp[1681] + -1 * sp[1897];
    sp[1952] = sp[1682] + -1 * sp[1898];
    sp[1953] = sp[1683] + -1 * sp[1899];
    sp[1954] = sp[1684] + -1 * sp[1900];
    sp[1955] = sp[1685] + -1 * sp[1901];
    sp[1956] = sp[1686] + -1 * sp[1902];
    sp[1957] = sp[1687] + -1 * sp[1903];
    sp[1958] = sp[1688] + -1 * sp[1904];
    sp[1959] = sp[1689] + -1 * sp[1905];
    sp[1960] = sp[1690] + -1 * sp[1906];
    sp[1961] = sp[1691] + -1 * sp[1907];
    sp[1962] = sp[1692] + -1 * sp[1908];
    sp[1963] = sp[1693] + -1 * sp[1909];
    sp[1964] = sp[1694] + -1 * sp[1910];
    sp[1965] = sp[1911] * sp[420];
    sp[1966] = sp[1912] * sp[420];
    sp[1967] = sp[1913] * sp[420];
    sp[1968] = sp[1914] * sp[420];
    sp[1969] = sp[1915] * sp[420];
    sp[1970] = sp[1916] * sp[420];
    sp[1971] = sp[1917] * sp[420];
    sp[1972] = sp[1918] * sp[420];
    sp[1973] = sp[1919] * sp[420];
    sp[1974] = sp[1920] * sp[420];
    sp[1975] = sp[1921] * sp[420];
    sp[1976] = sp[1922] * sp[420];
    sp[1977] = sp[1923] * sp[420];
    sp[1978] = sp[1924] * sp[420];
    sp[1979] = sp[1925] * sp[420];
    sp[1980] = sp[1926] * sp[420];
    sp[1981] = sp[1927] * sp[420];
    sp[1982] = sp[1928] * sp[420];
    sp[1983] = sp[1929] * sp[420];
    sp[1984] = sp[1930] * sp[420];
    sp[1985] = sp[1931] * sp[420];
    sp[1986] = sp[1932] * sp[420];
    sp[1987] = sp[1933] * sp[420];
    sp[1988] = sp[1934] * sp[420];
    sp[1989] = sp[1935] * sp[420];
    sp[1990] = sp[1936] * sp[420];
    sp[1991] = sp[1937] * sp[420];
    sp[1992] = sp[1938] * sp[420];
    sp[1993] = sp[1939] * sp[420];
    sp[1994] = sp[1940] * sp[420];
    sp[1995] = sp[1941] * sp[420];
    sp[1996] = sp[1942] * sp[420];
    sp[1997] = sp[1943] * sp[420];
    sp[1998] = sp[1944] * sp[420];
    sp[1999] = sp[1945] * sp[420];
    sp[2000] = sp[1946] * sp[420];
    sp[2001] = sp[1947] * sp[420];
    sp[2002] = sp[1948] * sp[420];
    sp[2003] = sp[1949] * sp[420];
    sp[2004] = sp[1950] * sp[420];
    sp[2005] = sp[1951] * sp[420];
    sp[2006] = sp[1952] * sp[420];
    sp[2007] = sp[1953] * sp[420];
    sp[2008] = sp[1954] * sp[420];
    sp[2009] = sp[1955] * sp[420];
    sp[2010] = sp[1956] * sp[420];
    sp[2011] = sp[1957] * sp[420];
    sp[2012] = sp[1958] * sp[420];
    sp[2013] = sp[1959] * sp[420];
    sp[2014] = sp[1960] * sp[420];
    sp[2015] = sp[1961] * sp[420];
    sp[2016] = sp[1962] * sp[420];
    sp[2017] = sp[1963] * sp[420];
    sp[2018] = sp[1964] * sp[420];
    sp[2019] = sp[1965] + sp[1398];
    sp[2020] = sp[1966] + sp[1407];
    sp[2021] = sp[1967] + sp[1416];
    sp[2022] = sp[1968] + sp[1425];
    sp[2023] = sp[1969] + sp[1434];
    sp[2024] = sp[1970] + sp[1443];
    sp[2025] = sp[1971] + sp[1452];
    sp[2026] = sp[1972] + sp[1461];
    sp[2027] = sp[1973] + sp[1470];
    sp[2028] = sp[1974] + sp[1399];
    sp[2029] = sp[1975] + sp[1408];
    sp[2030] = sp[1976] + sp[1417];
    sp[2031] = sp[1977] + sp[1426];
    sp[2032] = sp[1978] + sp[1435];
    sp[2033] = sp[1979] + sp[1444];
    sp[2034] = sp[1980] + sp[1453];
    sp[2035] = sp[1981] + sp[1462];
    sp[2036] = sp[1982] + sp[1471];
    sp[2037] = sp[1983] + sp[1400];
    sp[2038] = sp[1984] + sp[1409];
    sp[2039] = sp[1985] + sp[1418];
    sp[2040] = sp[1986] + sp[1427];
    sp[2041] = sp[1987] + sp[1436];
    sp[2042] = sp[1988] + sp[1445];
    sp[2043] = sp[1989] + sp[1454];
    sp[2044] = sp[1990] + sp[1463];
    sp[2045] = sp[1991] + sp[1472];
    sp[2046] = sp[1968] + sp[1401];
    sp[2047] = sp[1969] + sp[1402];
    sp[2048] = sp[1970] + sp[1403];
    sp[2049] = sp[1971] + sp[1404];
    sp[2050] = sp[1972] + sp[1405];
    sp[2051] = sp[1973] + sp[1406];
    sp[2052] = sp[1977] + sp[1410];
    sp[2053] = sp[1978] + sp[1411];
    sp[2054] = sp[1979] + sp[1412];
    sp[2055] = sp[1980] + sp[1413];
    sp[2056] = sp[1981] + sp[1414];
    sp[2057] = sp[1982] + sp[1415];
    sp[2058] = sp[1986] + sp[1419];
    sp[2059] = sp[1987] + sp[1420];
    sp[2060] = sp[1988] + sp[1421];
    sp[2061] = sp[1989] + sp[1422];
    sp[2062] = sp[1990] + sp[1423];
    sp[2063] = sp[1991] + sp[1424];
    sp[2064] = sp[1992] + sp[1428];
    sp[2065] = sp[1993] + sp[1437];
    sp[2066] = sp[1994] + sp[1446];
    sp[2067] = sp[1995] + sp[1455];
    sp[2068] = sp[1996] + sp[1464];
    sp[2069] = sp[1997] + sp[1473];
    sp[2070] = sp[1998] + sp[1429];
    sp[2071] = sp[1999] + sp[1438];
    sp[2072] = sp[2000] + sp[1447];
    sp[2073] = sp[2001] + sp[1456];
    sp[2074] = sp[2002] + sp[1465];
    sp[2075] = sp[2003] + sp[1474];
    sp[2076] = sp[2004] + sp[1430];
    sp[2077] = sp[2005] + sp[1439];
    sp[2078] = sp[2006] + sp[1448];
    sp[2079] = sp[2007] + sp[1457];
    sp[2080] = sp[2008] + sp[1466];
    sp[2081] = sp[2009] + sp[1475];
    sp[2082] = sp[1995] + sp[1431];
    sp[2083] = sp[1996] + sp[1432];
    sp[2084] = sp[1997] + sp[1433];
    sp[2085] = sp[2001] + sp[1440];
    sp[2086] = sp[2002] + sp[1441];
    sp[2087] = sp[2003] + sp[1442];
    sp[2088] = sp[2007] + sp[1449];
    sp[2089] = sp[2008] + sp[1450];
    sp[2090] = sp[2009] + sp[1451];
    sp[2091] = sp[2010] + sp[1458];
    sp[2092] = sp[2011] + sp[1467];
    sp[2093] = sp[2012] + sp[1476];
    sp[2094] = sp[2013] + sp[1459];
    sp[2095] = sp[2014] + sp[1468];
    sp[2096] = sp[2015] + sp[1477];
    sp[2097] = sp[2016] + sp[1460];
    sp[2098] = sp[2017] + sp[1469];
    sp[2099] = sp[2018] + sp[1478];
    sp[2100] = sp[459] * sp[1785];
    sp[2101] = sp[459] * sp[1786];
    sp[2102] = sp[459] * sp[1787];
    sp[2103] = sp[459] * sp[1788];
    sp[2104] = sp[459] * sp[1789];
    sp[2105] = sp[459] * sp[1790];
    sp[2106] = sp[1398] + sp[2100];
    sp[2107] = sp[1399] + sp[2101];
    sp[2108] = sp[1400] + sp[2102];
    sp[2109] = sp[1407] + sp[2101];
    sp[2110] = sp[1408] + sp[2103];
    sp[2111] = sp[1409] + sp[2104];
    sp[2112] = sp[1416] + sp[2102];
    sp[2113] = sp[1417] + sp[2104];
    sp[2114] = sp[1418] + sp[2105];
    sp[2115] = sp[1428] + sp[2100];
    sp[2116] = sp[1429] + sp[2101];
    sp[2117] = sp[1430] + sp[2102];
    sp[2118] = sp[1437] + sp[2101];
    sp[2119] = sp[1438] + sp[2103];
    sp[2120] = sp[1439] + sp[2104];
    sp[2121] = sp[1446] + sp[2102];
    sp[2122] = sp[1447] + sp[2104];
    sp[2123] = sp[1448] + sp[2105];
    sp[2124] = sp[1458] + sp[2100];
    sp[2125] = sp[1459] + sp[2101];
    sp[2126] = sp[1460] + sp[2102];
    sp[2127] = sp[1467] + sp[2101];
    sp[2128] = sp[1468] + sp[2103];
    sp[2129] = sp[1469] + sp[2104];
    sp[2130] = sp[1476] + sp[2102];
    sp[2131] = sp[1477] + sp[2104];
    sp[2132] = sp[1478] + sp[2105];
    sp[2133] = sp[2019] + sp[2106];
    sp[2134] = sp[2020] + sp[2107];
    sp[2135] = sp[2021] + sp[2108];
    sp[2136] = sp[2022] + sp[1401];
    sp[2137] = sp[2023] + sp[1402];
    sp[2138] = sp[2024] + sp[1403];
    sp[2139] = sp[2025] + sp[1404];
    sp[2140] = sp[2026] + sp[1405];
    sp[2141] = sp[2027] + sp[1406];
    sp[2142] = sp[2028] + sp[2109];
    sp[2143] = sp[2029] + sp[2110];
    sp[2144] = sp[2030] + sp[2111];
    sp[2145] = sp[2031] + sp[1410];
    sp[2146] = sp[2032] + sp[1411];
    sp[2147] = sp[2033] + sp[1412];
    sp[2148] = sp[2034] + sp[1413];
    sp[2149] = sp[2035] + sp[1414];
    sp[2150] = sp[2036] + sp[1415];
    sp[2151] = sp[2037] + sp[2112];
    sp[2152] = sp[2038] + sp[2113];
    sp[2153] = sp[2039] + sp[2114];
    sp[2154] = sp[2040] + sp[1419];
    sp[2155] = sp[2041] + sp[1420];
    sp[2156] = sp[2042] + sp[1421];
    sp[2157] = sp[2043] + sp[1422];
    sp[2158] = sp[2044] + sp[1423];
    sp[2159] = sp[2045] + sp[1424];
    sp[2160] = sp[2046] + sp[1425];
    sp[2161] = sp[2047] + sp[1434];
    sp[2162] = sp[2048] + sp[1443];
    sp[2163] = sp[2049] + sp[1452];
    sp[2164] = sp[2050] + sp[1461];
    sp[2165] = sp[2051] + sp[1470];
    sp[2166] = sp[2052] + sp[1426];
    sp[2167] = sp[2053] + sp[1435];
    sp[2168] = sp[2054] + sp[1444];
    sp[2169] = sp[2055] + sp[1453];
    sp[2170] = sp[2056] + sp[1462];
    sp[2171] = sp[2057] + sp[1471];
    sp[2172] = sp[2058] + sp[1427];
    sp[2173] = sp[2059] + sp[1436];
    sp[2174] = sp[2060] + sp[1445];
    sp[2175] = sp[2061] + sp[1454];
    sp[2176] = sp[2062] + sp[1463];
    sp[2177] = sp[2063] + sp[1472];
    sp[2178] = sp[2064] + sp[2115];
    sp[2179] = sp[2065] + sp[2116];
    sp[2180] = sp[2066] + sp[2117];
    sp[2181] = sp[2067] + sp[1431];
    sp[2182] = sp[2068] + sp[1432];
    sp[2183] = sp[2069] + sp[1433];
    sp[2184] = sp[2070] + sp[2118];
    sp[2185] = sp[2071] + sp[2119];
    sp[2186] = sp[2072] + sp[2120];
    sp[2187] = sp[2073] + sp[1440];
    sp[2188] = sp[2074] + sp[1441];
    sp[2189] = sp[2075] + sp[1442];
    sp[2190] = sp[2076] + sp[2121];
    sp[2191] = sp[2077] + sp[2122];
    sp[2192] = sp[2078] + sp[2123];
    sp[2193] = sp[2079] + sp[1449];
    sp[2194] = sp[2080] + sp[1450];
    sp[2195] = sp[2081] + sp[1451];
    sp[2196] = sp[2082] + sp[1455];
    sp[2197] = sp[2083] + sp[1464];
    sp[2198] = sp[2084] + sp[1473];
    sp[2199] = sp[2085] + sp[1456];
    sp[2200] = sp[2086] + sp[1465];
    sp[2201] = sp[2087] + sp[1474];
    sp[2202] = sp[2088] + sp[1457];
    sp[2203] = sp[2089] + sp[1466];
    sp[2204] = sp[2090] + sp[1475];
    sp[2205] = sp[2091] + sp[2124];
    sp[2206] = sp[2092] + sp[2125];
    sp[2207] = sp[2093] + sp[2126];
    sp[2208] = sp[2094] + sp[2127];
    sp[2209] = sp[2095] + sp[2128];
    sp[2210] = sp[2096] + sp[2129];
    sp[2211] = sp[2097] + sp[2130];
    sp[2212] = sp[2098] + sp[2131];
    sp[2213] = sp[2099] + sp[2132];
    sp[2214] = sp[2133] + sp[1317];
    sp[2215] = sp[2134] + sp[1318];
    sp[2216] = sp[1319] + sp[2135];
    sp[2217] = sp[1320] + sp[2136];
    sp[2218] = sp[1321] + sp[2137];
    sp[2219] = sp[1322] + sp[2138];
    sp[2220] = sp[1323] + sp[2139];
    sp[2221] = sp[1324] + sp[2140];
    sp[2222] = sp[1325] + sp[2141];
    sp[2223] = sp[2142] + sp[1326];
    sp[2224] = sp[2143] + sp[1327];
    sp[2225] = sp[1328] + sp[2144];
    sp[2226] = sp[1329] + sp[2145];
    sp[2227] = sp[1330] + sp[2146];
    sp[2228] = sp[1331] + sp[2147];
    sp[2229] = sp[1332] + sp[2148];
    sp[2230] = sp[1333] + sp[2149];
    sp[2231] = sp[1334] + sp[2150];
    sp[2232] = sp[1335] + sp[2151];
    sp[2233] = sp[1336] + sp[2152];
    sp[2234] = sp[1337] + sp[2153];
    sp[2235] = sp[1338] + sp[2154];
    sp[2236] = sp[1339] + sp[2155];
    sp[2237] = sp[1340] + sp[2156];
    sp[2238] = sp[1341] + sp[2157];
    sp[2239] = sp[1342] + sp[2158];
    sp[2240] = sp[1343] + sp[2159];
    sp[2241] = sp[2160] + sp[1344];
    sp[2242] = sp[2161] + sp[1345];
    sp[2243] = sp[1346] + sp[2162];
    sp[2244] = sp[1347] + sp[2163];
    sp[2245] = sp[1348] + sp[2164];
    sp[2246] = sp[1349] + sp[2165];
    sp[2247] = sp[2166] + sp[1350];
    sp[2248] = sp[2167] + sp[1351];
    sp[2249] = sp[1352] + sp[2168];
    sp[2250] = sp[1353] + sp[2169];
    sp[2251] = sp[1354] + sp[2170];
    sp[2252] = sp[1355] + sp[2171];
    sp[2253] = sp[2172] + sp[1356];
    sp[2254] = sp[2173] + sp[1357];
    sp[2255] = sp[1358] + sp[2174];
    sp[2256] = sp[1359] + sp[2175];
    sp[2257] = sp[1360] + sp[2176];
    sp[2258] = sp[1361] + sp[2177];
    sp[2259] = sp[2178] + sp[1362];
    sp[2260] = sp[2179] + sp[1363];
    sp[2261] = sp[1364] + sp[2180];
    sp[2262] = sp[2181] + sp[1365];
    sp[2263] = sp[2182] + sp[1366];
    sp[2264] = sp[2183] + sp[1367];
    sp[2265] = sp[2184] + sp[1368];
    sp[2266] = sp[2185] + sp[1369];
    sp[2267] = sp[1370] + sp[2186];
    sp[2268] = sp[2187] + sp[1371];
    sp[2269] = sp[2188] + sp[1372];
    sp[2270] = sp[2189] + sp[1373];
    sp[2271] = sp[1374] + sp[2190];
    sp[2272] = sp[1375] + sp[2191];
    sp[2273] = sp[1376] + sp[2192];
    sp[2274] = sp[1377] + sp[2193];
    sp[2275] = sp[1378] + sp[2194];
    sp[2276] = sp[1379] + sp[2195];
    sp[2277] = sp[1380] + sp[2196];
    sp[2278] = sp[1381] + sp[2197];
    sp[2279] = sp[1382] + sp[2198];
    sp[2280] = sp[1383] + sp[2199];
    sp[2281] = sp[1384] + sp[2200];
    sp[2282] = sp[1385] + sp[2201];
    sp[2283] = sp[1386] + sp[2202];
    sp[2284] = sp[1387] + sp[2203];
    sp[2285] = sp[1388] + sp[2204];
    sp[2286] = sp[2205] + sp[1389];
    sp[2287] = sp[2206] + sp[1390];
    sp[2288] = sp[1391] + sp[2207];
    sp[2289] = sp[2208] + sp[1392];
    sp[2290] = sp[2209] + sp[1393];
    sp[2291] = sp[1394] + sp[2210];
    sp[2292] = sp[1395] + sp[2211];
    sp[2293] = sp[1396] + sp[2212];
    sp[2294] = sp[1397] + sp[2213];
    sp[2295] = sp[541] * sp[341];
    sp[2296] = sp[542] * sp[341];
    sp[2297] = sp[543] * sp[341];
    sp[2298] = sp[544] * sp[341];
    sp[2299] = sp[545] * sp[341];
    sp[2300] = sp[546] * sp[341];
    sp[2301] = sp[547] * sp[341];
    sp[2302] = sp[548] * sp[341];
    sp[2303] = sp[549] * sp[341];
    sp[2304] = sp[541] * sp[342];
    sp[2305] = sp[542] * sp[342];
    sp[2306] = sp[543] * sp[342];
    sp[2307] = sp[544] * sp[342];
    sp[2308] = sp[545] * sp[342];
    sp[2309] = sp[546] * sp[342];
    sp[2310] = sp[547] * sp[342];
    sp[2311] = sp[548] * sp[342];
    sp[2312] = sp[549] * sp[342];
    sp[2313] = sp[541] * sp[343];
    sp[2314] = sp[542] * sp[343];
    sp[2315] = sp[543] * sp[343];
    sp[2316] = sp[544] * sp[343];
    sp[2317] = sp[545] * sp[343];
    sp[2318] = sp[546] * sp[343];
    sp[2319] = sp[547] * sp[343];
    sp[2320] = sp[548] * sp[343];
    sp[2321] = sp[549] * sp[343];
    sp[2322] = sp[541] * sp[350];
    sp[2323] = sp[542] * sp[350];
    sp[2324] = sp[543] * sp[350];
    sp[2325] = sp[544] * sp[350];
    sp[2326] = sp[545] * sp[350];
    sp[2327] = sp[546] * sp[350];
    sp[2328] = sp[547] * sp[350];
    sp[2329] = sp[548] * sp[350];
    sp[2330] = sp[549] * sp[350];
    sp[2331] = sp[541] * sp[351];
    sp[2332] = sp[542] * sp[351];
    sp[2333] = sp[543] * sp[351];
    sp[2334] = sp[544] * sp[351];
    sp[2335] = sp[545] * sp[351];
    sp[2336] = sp[546] * sp[351];
    sp[2337] = sp[547] * sp[351];
    sp[2338] = sp[548] * sp[351];
    sp[2339] = sp[549] * sp[351];
    sp[2340] = sp[541] * sp[352];
    sp[2341] = sp[542] * sp[352];
    sp[2342] = sp[543] * sp[352];
    sp[2343] = sp[544] * sp[352];
    sp[2344] = sp[545] * sp[352];
    sp[2345] = sp[546] * sp[352];
    sp[2346] = sp[547] * sp[352];
    sp[2347] = sp[548] * sp[352];
    sp[2348] = sp[549] * sp[352];
    sp[2349] = sp[541] * sp[359];
    sp[2350] = sp[542] * sp[359];
    sp[2351] = sp[543] * sp[359];
    sp[2352] = sp[544] * sp[359];
    sp[2353] = sp[545] * sp[359];
    sp[2354] = sp[546] * sp[359];
    sp[2355] = sp[547] * sp[359];
    sp[2356] = sp[548] * sp[359];
    sp[2357] = sp[549] * sp[359];
    sp[2358] = sp[541] * sp[360];
    sp[2359] = sp[542] * sp[360];
    sp[2360] = sp[543] * sp[360];
    sp[2361] = sp[544] * sp[360];
    sp[2362] = sp[545] * sp[360];
    sp[2363] = sp[546] * sp[360];
    sp[2364] = sp[547] * sp[360];
    sp[2365] = sp[548] * sp[360];
    sp[2366] = sp[549] * sp[360];
    sp[2367] = sp[541] * sp[361];
    sp[2368] = sp[542] * sp[361];
    sp[2369] = sp[543] * sp[361];
    sp[2370] = sp[544] * sp[361];
    sp[2371] = sp[545] * sp[361];
    sp[2372] = sp[546] * sp[361];
    sp[2373] = sp[547] * sp[361];
    sp[2374] = sp[548] * sp[361];
    sp[2375] = sp[549] * sp[361];
    sp[2376] = sp[200] * sp[386];
    sp[2377] = sp[200] * sp[387];
    sp[2378] = sp[200] * sp[388];
    sp[2379] = sp[200] * sp[395];
    sp[2380] = sp[200] * sp[396];
    sp[2381] = sp[200] * sp[397];
    sp[2382] = sp[200] * sp[404];
    sp[2383] = sp[200] * sp[405];
    sp[2384] = sp[200] * sp[406];
    sp[2385] = sp[201] * sp[386];
    sp[2386] = sp[201] * sp[387];
    sp[2387] = sp[201] * sp[388];
    sp[2388] = sp[201] * sp[395];
    sp[2389] = sp[201] * sp[396];
    sp[2390] = sp[201] * sp[397];
    sp[2391] = sp[201] * sp[404];
    sp[2392] = sp[201] * sp[405];
    sp[2393] = sp[201] * sp[406];
    sp[2394] = sp[202] * sp[386];
    sp[2395] = sp[202] * sp[387];
    sp[2396] = sp[388] * sp[202];
    sp[2397] = sp[202] * sp[395];
    sp[2398] = sp[202] * sp[396];
    sp[2399] = sp[202] * sp[397];
    sp[2400] = sp[202] * sp[404];
    sp[2401] = sp[202] * sp[405];
    sp[2402] = sp[202] * sp[406];
    sp[2403] = sp[209] * sp[386];
    sp[2404] = sp[209] * sp[387];
    sp[2405] = sp[209] * sp[388];
    sp[2406] = sp[209] * sp[395];
    sp[2407] = sp[209] * sp[396];
    sp[2408] = sp[209] * sp[397];
    sp[2409] = sp[209] * sp[404];
    sp[2410] = sp[209] * sp[405];
    sp[2411] = sp[209] * sp[406];
    sp[2412] = sp[210] * sp[386];
    sp[2413] = sp[210] * sp[387];
    sp[2414] = sp[210] * sp[388];
    sp[2415] = sp[210] * sp[395];
    sp[2416] = sp[210] * sp[396];
    sp[2417] = sp[210] * sp[397];
    sp[2418] = sp[210] * sp[404];
    sp[2419] = sp[210] * sp[405];
    sp[2420] = sp[210] * sp[406];
    sp[2421] = sp[211] * sp[386];
    sp[2422] = sp[211] * sp[387];
    sp[2423] = sp[388] * sp[211];
    sp[2424] = sp[211] * sp[395];
    sp[2425] = sp[211] * sp[396];
    sp[2426] = sp[211] * sp[397];
    sp[2427] = sp[211] * sp[404];
    sp[2428] = sp[211] * sp[405];
    sp[2429] = sp[211] * sp[406];
    sp[2430] = sp[218] * sp[386];
    sp[2431] = sp[218] * sp[387];
    sp[2432] = sp[218] * sp[388];
    sp[2433] = sp[218] * sp[395];
    sp[2434] = sp[218] * sp[396];
    sp[2435] = sp[218] * sp[397];
    sp[2436] = sp[218] * sp[404];
    sp[2437] = sp[218] * sp[405];
    sp[2438] = sp[218] * sp[406];
    sp[2439] = sp[219] * sp[386];
    sp[2440] = sp[219] * sp[387];
    sp[2441] = sp[219] * sp[388];
    sp[2442] = sp[219] * sp[395];
    sp[2443] = sp[219] * sp[396];
    sp[2444] = sp[219] * sp[397];
    sp[2445] = sp[219] * sp[404];
    sp[2446] = sp[219] * sp[405];
    sp[2447] = sp[219] * sp[406];
    sp[2448] = sp[220] * sp[386];
    sp[2449] = sp[220] * sp[387];
    sp[2450] = sp[220] * sp[388];
    sp[2451] = sp[220] * sp[395];
    sp[2452] = sp[220] * sp[396];
    sp[2453] = sp[220] * sp[397];
    sp[2454] = sp[220] * sp[404];
    sp[2455] = sp[220] * sp[405];
    sp[2456] = sp[220] * sp[406];
    sp[2457] = sp[225] * sp[1785];
    sp[2458] = sp[225] * sp[1786];
    sp[2459] = sp[225] * sp[1787];
    sp[2460] = sp[225] * sp[1788];
    sp[2461] = sp[225] * sp[1789];
    sp[2462] = sp[225] * sp[1790];
    sp[2463] = sp[2376] + sp[2457];
    sp[2464] = sp[2385] + sp[2458];
    sp[2465] = sp[2394] + sp[2459];
    sp[2466] = sp[2377] + sp[2458];
    sp[2467] = sp[2386] + sp[2460];
    sp[2468] = sp[2395] + sp[2461];
    sp[2469] = sp[2378] + sp[2459];
    sp[2470] = sp[2387] + sp[2461];
    sp[2471] = sp[2396] + sp[2462];
    sp[2472] = sp[2406] + sp[2457];
    sp[2473] = sp[2415] + sp[2458];
    sp[2474] = sp[2424] + sp[2459];
    sp[2475] = sp[2407] + sp[2458];
    sp[2476] = sp[2416] + sp[2460];
    sp[2477] = sp[2425] + sp[2461];
    sp[2478] = sp[2408] + sp[2459];
    sp[2479] = sp[2417] + sp[2461];
    sp[2480] = sp[2426] + sp[2462];
    sp[2481] = sp[2436] + sp[2457];
    sp[2482] = sp[2445] + sp[2458];
    sp[2483] = sp[2454] + sp[2459];
    sp[2484] = sp[2437] + sp[2458];
    sp[2485] = sp[2446] + sp[2460];
    sp[2486] = sp[2455] + sp[2461];
    sp[2487] = sp[2438] + sp[2459];
    sp[2488] = sp[2447] + sp[2461];
    sp[2489] = sp[2456] + sp[2462];
    sp[2490] = sp[420] * sp[1020];
    sp[2491] = sp[420] * sp[1021];
    sp[2492] = sp[420] * sp[1022];
    sp[2493] = sp[420] * sp[1023];
    sp[2494] = sp[420] * sp[1024];
    sp[2495] = sp[420] * sp[1025];
    sp[2496] = sp[2490] + sp[2376];
    sp[2497] = sp[2491] + sp[2377];
    sp[2498] = sp[2378] + sp[2492];
    sp[2499] = sp[2491] + sp[2385];
    sp[2500] = sp[2493] + sp[2386];
    sp[2501] = sp[2387] + sp[2494];
    sp[2502] = sp[2492] + sp[2394];
    sp[2503] = sp[2494] + sp[2395];
    sp[2504] = sp[2396] + sp[2495];
    sp[2505] = sp[2490] + sp[2406];
    sp[2506] = sp[2491] + sp[2407];
    sp[2507] = sp[2408] + sp[2492];
    sp[2508] = sp[2491] + sp[2415];
    sp[2509] = sp[2493] + sp[2416];
    sp[2510] = sp[2417] + sp[2494];
    sp[2511] = sp[2492] + sp[2424];
    sp[2512] = sp[2494] + sp[2425];
    sp[2513] = sp[2426] + sp[2495];
    sp[2514] = sp[2490] + sp[2436];
    sp[2515] = sp[2491] + sp[2437];
    sp[2516] = sp[2438] + sp[2492];
    sp[2517] = sp[2491] + sp[2445];
    sp[2518] = sp[2493] + sp[2446];
    sp[2519] = sp[2447] + sp[2494];
    sp[2520] = sp[2492] + sp[2454];
    sp[2521] = sp[2494] + sp[2455];
    sp[2522] = sp[2456] + sp[2495];
    sp[2523] = sp[2496] + sp[2463];
    sp[2524] = sp[2497] + sp[2464];
    sp[2525] = sp[2498] + sp[2465];
    sp[2526] = sp[2379] + sp[2403];
    sp[2527] = sp[2412] + sp[2380];
    sp[2528] = sp[2381] + sp[2421];
    sp[2529] = sp[2430] + sp[2382];
    sp[2530] = sp[2439] + sp[2383];
    sp[2531] = sp[2384] + sp[2448];
    sp[2532] = sp[2499] + sp[2466];
    sp[2533] = sp[2500] + sp[2467];
    sp[2534] = sp[2501] + sp[2468];
    sp[2535] = sp[2388] + sp[2404];
    sp[2536] = sp[2389] + sp[2413];
    sp[2537] = sp[2390] + sp[2422];
    sp[2538] = sp[2391] + sp[2431];
    sp[2539] = sp[2440] + sp[2392];
    sp[2540] = sp[2393] + sp[2449];
    sp[2541] = sp[2502] + sp[2469];
    sp[2542] = sp[2503] + sp[2470];
    sp[2543] = sp[2504] + sp[2471];
    sp[2544] = sp[2405] + sp[2397];
    sp[2545] = sp[2414] + sp[2398];
    sp[2546] = sp[2423] + sp[2399];
    sp[2547] = sp[2432] + sp[2400];
    sp[2548] = sp[2441] + sp[2401];
    sp[2549] = sp[2450] + sp[2402];
    sp[2550] = sp[2505] + sp[2472];
    sp[2551] = sp[2506] + sp[2473];
    sp[2552] = sp[2507] + sp[2474];
    sp[2553] = sp[2433] + sp[2409];
    sp[2554] = sp[2442] + sp[2410];
    sp[2555] = sp[2411] + sp[2451];
    sp[2556] = sp[2508] + sp[2475];
    sp[2557] = sp[2509] + sp[2476];
    sp[2558] = sp[2510] + sp[2477];
    sp[2559] = sp[2418] + sp[2434];
    sp[2560] = sp[2443] + sp[2419];
    sp[2561] = sp[2420] + sp[2452];
    sp[2562] = sp[2511] + sp[2478];
    sp[2563] = sp[2512] + sp[2479];
    sp[2564] = sp[2513] + sp[2480];
    sp[2565] = sp[2435] + sp[2427];
    sp[2566] = sp[2444] + sp[2428];
    sp[2567] = sp[2453] + sp[2429];
    sp[2568] = sp[2514] + sp[2481];
    sp[2569] = sp[2515] + sp[2482];
    sp[2570] = sp[2516] + sp[2483];
    sp[2571] = sp[2517] + sp[2484];
    sp[2572] = sp[2518] + sp[2485];
    sp[2573] = sp[2519] + sp[2486];
    sp[2574] = sp[2520] + sp[2487];
    sp[2575] = sp[2521] + sp[2488];
    sp[2576] = sp[2522] + sp[2489];
    sp[2577] = sp[99] * sp[341];
    sp[2578] = sp[100] * sp[341];
    sp[2579] = sp[101] * sp[341];
    sp[2580] = sp[110] * sp[341];
    sp[2581] = sp[111] * sp[341];
    sp[2582] = sp[112] * sp[341];
    sp[2583] = sp[121] * sp[341];
    sp[2584] = sp[122] * sp[341];
    sp[2585] = sp[123] * sp[341];
    sp[2586] = sp[99] * sp[342];
    sp[2587] = sp[100] * sp[342];
    sp[2588] = sp[101] * sp[342];
    sp[2589] = sp[110] * sp[342];
    sp[2590] = sp[111] * sp[342];
    sp[2591] = sp[112] * sp[342];
    sp[2592] = sp[121] * sp[342];
    sp[2593] = sp[122] * sp[342];
    sp[2594] = sp[123] * sp[342];
    sp[2595] = sp[99] * sp[343];
    sp[2596] = sp[100] * sp[343];
    sp[2597] = sp[343] * sp[101];
    sp[2598] = sp[110] * sp[343];
    sp[2599] = sp[111] * sp[343];
    sp[2600] = sp[343] * sp[112];
    sp[2601] = sp[121] * sp[343];
    sp[2602] = sp[122] * sp[343];
    sp[2603] = sp[343] * sp[123];
    sp[2604] = sp[99] * sp[350];
    sp[2605] = sp[100] * sp[350];
    sp[2606] = sp[101] * sp[350];
    sp[2607] = sp[110] * sp[350];
    sp[2608] = sp[111] * sp[350];
    sp[2609] = sp[112] * sp[350];
    sp[2610] = sp[121] * sp[350];
    sp[2611] = sp[122] * sp[350];
    sp[2612] = sp[123] * sp[350];
    sp[2613] = sp[99] * sp[351];
    sp[2614] = sp[100] * sp[351];
    sp[2615] = sp[101] * sp[351];
    sp[2616] = sp[110] * sp[351];
    sp[2617] = sp[111] * sp[351];
    sp[2618] = sp[112] * sp[351];
    sp[2619] = sp[121] * sp[351];
    sp[2620] = sp[122] * sp[351];
    sp[2621] = sp[123] * sp[351];
    sp[2622] = sp[99] * sp[352];
    sp[2623] = sp[100] * sp[352];
    sp[2624] = sp[352] * sp[101];
    sp[2625] = sp[110] * sp[352];
    sp[2626] = sp[111] * sp[352];
    sp[2627] = sp[352] * sp[112];
    sp[2628] = sp[121] * sp[352];
    sp[2629] = sp[122] * sp[352];
    sp[2630] = sp[352] * sp[123];
    sp[2631] = sp[99] * sp[359];
    sp[2632] = sp[100] * sp[359];
    sp[2633] = sp[101] * sp[359];
    sp[2634] = sp[110] * sp[359];
    sp[2635] = sp[111] * sp[359];
    sp[2636] = sp[112] * sp[359];
    sp[2637] = sp[121] * sp[359];
    sp[2638] = sp[122] * sp[359];
    sp[2639] = sp[123] * sp[359];
    sp[2640] = sp[99] * sp[360];
    sp[2641] = sp[100] * sp[360];
    sp[2642] = sp[101] * sp[360];
    sp[2643] = sp[110] * sp[360];
    sp[2644] = sp[111] * sp[360];
    sp[2645] = sp[112] * sp[360];
    sp[2646] = sp[121] * sp[360];
    sp[2647] = sp[122] * sp[360];
    sp[2648] = sp[123] * sp[360];
    sp[2649] = sp[99] * sp[361];
    sp[2650] = sp[100] * sp[361];
    sp[2651] = sp[361] * sp[101];
    sp[2652] = sp[110] * sp[361];
    sp[2653] = sp[111] * sp[361];
    sp[2654] = sp[361] * sp[112];
    sp[2655] = sp[121] * sp[361];
    sp[2656] = sp[122] * sp[361];
    sp[2657] = sp[361] * sp[123];
    sp[2658] = sp[325] * sp[49];
    sp[2659] = sp[325] * sp[50];
    sp[2660] = sp[325] * sp[51];
    sp[2661] = sp[325] * sp[52];
    sp[2662] = sp[325] * sp[53];
    sp[2663] = sp[325] * sp[54];
    sp[2664] = sp[2658] + sp[2577];
    sp[2665] = sp[2659] + sp[2586];
    sp[2666] = sp[2595] + sp[2660];
    sp[2667] = sp[2659] + sp[2578];
    sp[2668] = sp[2661] + sp[2587];
    sp[2669] = sp[2596] + sp[2662];
    sp[2670] = sp[2660] + sp[2579];
    sp[2671] = sp[2662] + sp[2588];
    sp[2672] = sp[2597] + sp[2663];
    sp[2673] = sp[2658] + sp[2607];
    sp[2674] = sp[2659] + sp[2616];
    sp[2675] = sp[2625] + sp[2660];
    sp[2676] = sp[2659] + sp[2608];
    sp[2677] = sp[2661] + sp[2617];
    sp[2678] = sp[2626] + sp[2662];
    sp[2679] = sp[2660] + sp[2609];
    sp[2680] = sp[2662] + sp[2618];
    sp[2681] = sp[2627] + sp[2663];
    sp[2682] = sp[2658] + sp[2637];
    sp[2683] = sp[2659] + sp[2646];
    sp[2684] = sp[2655] + sp[2660];
    sp[2685] = sp[2659] + sp[2638];
    sp[2686] = sp[2661] + sp[2647];
    sp[2687] = sp[2656] + sp[2662];
    sp[2688] = sp[2660] + sp[2639];
    sp[2689] = sp[2662] + sp[2648];
    sp[2690] = sp[2657] + sp[2663];
    sp[2691] = sp[175] * sp[1602];
    sp[2692] = sp[175] * sp[1603];
    sp[2693] = sp[175] * sp[1604];
    sp[2694] = sp[175] * sp[1605];
    sp[2695] = sp[175] * sp[1606];
    sp[2696] = sp[175] * sp[1607];
    sp[2697] = sp[2577] + sp[2691];
    sp[2698] = sp[2578] + sp[2692];
    sp[2699] = sp[2579] + sp[2693];
    sp[2700] = sp[2586] + sp[2692];
    sp[2701] = sp[2587] + sp[2694];
    sp[2702] = sp[2588] + sp[2695];
    sp[2703] = sp[2595] + sp[2693];
    sp[2704] = sp[2596] + sp[2695];
    sp[2705] = sp[2696] + sp[2597];
    sp[2706] = sp[2607] + sp[2691];
    sp[2707] = sp[2608] + sp[2692];
    sp[2708] = sp[2609] + sp[2693];
    sp[2709] = sp[2616] + sp[2692];
    sp[2710] = sp[2617] + sp[2694];
    sp[2711] = sp[2618] + sp[2695];
    sp[2712] = sp[2625] + sp[2693];
    sp[2713] = sp[2626] + sp[2695];
    sp[2714] = sp[2696] + sp[2627];
    sp[2715] = sp[2637] + sp[2691];
    sp[2716] = sp[2638] + sp[2692];
    sp[2717] = sp[2639] + sp[2693];
    sp[2718] = sp[2646] + sp[2692];
    sp[2719] = sp[2647] + sp[2694];
    sp[2720] = sp[2648] + sp[2695];
    sp[2721] = sp[2655] + sp[2693];
    sp[2722] = sp[2656] + sp[2695];
    sp[2723] = sp[2696] + sp[2657];
    sp[2724] = sp[2664] + sp[2697];
    sp[2725] = sp[2665] + sp[2698];
    sp[2726] = sp[2666] + sp[2699];
    sp[2727] = sp[2580] + sp[2604];
    sp[2728] = sp[2581] + sp[2613];
    sp[2729] = sp[2622] + sp[2582];
    sp[2730] = sp[2631] + sp[2583];
    sp[2731] = sp[2584] + sp[2640];
    sp[2732] = sp[2649] + sp[2585];
    sp[2733] = sp[2667] + sp[2700];
    sp[2734] = sp[2668] + sp[2701];
    sp[2735] = sp[2669] + sp[2702];
    sp[2736] = sp[2605] + sp[2589];
    sp[2737] = sp[2590] + sp[2614];
    sp[2738] = sp[2623] + sp[2591];
    sp[2739] = sp[2632] + sp[2592];
    sp[2740] = sp[2641] + sp[2593];
    sp[2741] = sp[2650] + sp[2594];
    sp[2742] = sp[2670] + sp[2703];
    sp[2743] = sp[2671] + sp[2704];
    sp[2744] = sp[2705] + sp[2672];
    sp[2745] = sp[2598] + sp[2606];
    sp[2746] = sp[2599] + sp[2615];
    sp[2747] = sp[2600] + sp[2624];
    sp[2748] = sp[2601] + sp[2633];
    sp[2749] = sp[2602] + sp[2642];
    sp[2750] = sp[2651] + sp[2603];
    sp[2751] = sp[2673] + sp[2706];
    sp[2752] = sp[2674] + sp[2707];
    sp[2753] = sp[2675] + sp[2708];
    sp[2754] = sp[2634] + sp[2610];
    sp[2755] = sp[2611] + sp[2643];
    sp[2756] = sp[2652] + sp[2612];
    sp[2757] = sp[2676] + sp[2709];
    sp[2758] = sp[2677] + sp[2710];
    sp[2759] = sp[2678] + sp[2711];
    sp[2760] = sp[2635] + sp[2619];
    sp[2761] = sp[2644] + sp[2620];
    sp[2762] = sp[2653] + sp[2621];
    sp[2763] = sp[2679] + sp[2712];
    sp[2764] = sp[2680] + sp[2713];
    sp[2765] = sp[2714] + sp[2681];
    sp[2766] = sp[2628] + sp[2636];
    sp[2767] = sp[2629] + sp[2645];
    sp[2768] = sp[2654] + sp[2630];
    sp[2769] = sp[2682] + sp[2715];
    sp[2770] = sp[2683] + sp[2716];
    sp[2771] = sp[2684] + sp[2717];
    sp[2772] = sp[2685] + sp[2718];
    sp[2773] = sp[2686] + sp[2719];
    sp[2774] = sp[2687] + sp[2720];
    sp[2775] = sp[2688] + sp[2721];
    sp[2776] = sp[2689] + sp[2722];
    sp[2777] = sp[2723] + sp[2690];
    sp[2778] = sp[2523] + -1 * sp[2724];
    sp[2779] = sp[2524] + -1 * sp[2725];
    sp[2780] = sp[2525] + -1 * sp[2726];
    sp[2781] = sp[2526] + -1 * sp[2727];
    sp[2782] = sp[2527] + -1 * sp[2728];
    sp[2783] = sp[2528] + -1 * sp[2729];
    sp[2784] = sp[2529] + -1 * sp[2730];
    sp[2785] = sp[2530] + -1 * sp[2731];
    sp[2786] = sp[2531] + -1 * sp[2732];
    sp[2787] = sp[2532] + -1 * sp[2733];
    sp[2788] = sp[2533] + -1 * sp[2734];
    sp[2789] = sp[2534] + -1 * sp[2735];
    sp[2790] = sp[2535] + -1 * sp[2736];
    sp[2791] = sp[2536] + -1 * sp[2737];
    sp[2792] = sp[2537] + -1 * sp[2738];
    sp[2793] = sp[2538] + -1 * sp[2739];
    sp[2794] = sp[2539] + -1 * sp[2740];
    sp[2795] = sp[2540] + -1 * sp[2741];
    sp[2796] = sp[2541] + -1 * sp[2742];
    sp[2797] = sp[2542] + -1 * sp[2743];
    sp[2798] = sp[2543] + -1 * sp[2744];
    sp[2799] = sp[2544] + -1 * sp[2745];
    sp[2800] = sp[2545] + -1 * sp[2746];
    sp[2801] = sp[2546] + -1 * sp[2747];
    sp[2802] = sp[2547] + -1 * sp[2748];
    sp[2803] = sp[2548] + -1 * sp[2749];
    sp[2804] = sp[2549] + -1 * sp[2750];
    sp[2805] = sp[2550] + -1 * sp[2751];
    sp[2806] = sp[2551] + -1 * sp[2752];
    sp[2807] = sp[2552] + -1 * sp[2753];
    sp[2808] = sp[2553] + -1 * sp[2754];
    sp[2809] = sp[2554] + -1 * sp[2755];
    sp[2810] = sp[2555] + -1 * sp[2756];
    sp[2811] = sp[2556] + -1 * sp[2757];
    sp[2812] = sp[2557] + -1 * sp[2758];
    sp[2813] = sp[2558] + -1 * sp[2759];
    sp[2814] = sp[2559] + -1 * sp[2760];
    sp[2815] = sp[2560] + -1 * sp[2761];
    sp[2816] = sp[2561] + -1 * sp[2762];
    sp[2817] = sp[2562] + -1 * sp[2763];
    sp[2818] = sp[2563] + -1 * sp[2764];
    sp[2819] = sp[2564] + -1 * sp[2765];
    sp[2820] = sp[2565] + -1 * sp[2766];
    sp[2821] = sp[2566] + -1 * sp[2767];
    sp[2822] = sp[2567] + -1 * sp[2768];
    sp[2823] = sp[2568] + -1 * sp[2769];
    sp[2824] = sp[2569] + -1 * sp[2770];
    sp[2825] = sp[2570] + -1 * sp[2771];
    sp[2826] = sp[2571] + -1 * sp[2772];
    sp[2827] = sp[2572] + -1 * sp[2773];
    sp[2828] = sp[2573] + -1 * sp[2774];
    sp[2829] = sp[2574] + -1 * sp[2775];
    sp[2830] = sp[2575] + -1 * sp[2776];
    sp[2831] = sp[2576] + -1 * sp[2777];
    sp[2832] = sp[2778] * sp[325];
    sp[2833] = sp[2779] * sp[325];
    sp[2834] = sp[2780] * sp[325];
    sp[2835] = sp[2781] * sp[325];
    sp[2836] = sp[2782] * sp[325];
    sp[2837] = sp[2783] * sp[325];
    sp[2838] = sp[2784] * sp[325];
    sp[2839] = sp[2785] * sp[325];
    sp[2840] = sp[2786] * sp[325];
    sp[2841] = sp[2787] * sp[325];
    sp[2842] = sp[2788] * sp[325];
    sp[2843] = sp[2789] * sp[325];
    sp[2844] = sp[2790] * sp[325];
    sp[2845] = sp[2791] * sp[325];
    sp[2846] = sp[2792] * sp[325];
    sp[2847] = sp[2793] * sp[325];
    sp[2848] = sp[2794] * sp[325];
    sp[2849] = sp[2795] * sp[325];
    sp[2850] = sp[2796] * sp[325];
    sp[2851] = sp[2797] * sp[325];
    sp[2852] = sp[2798] * sp[325];
    sp[2853] = sp[2799] * sp[325];
    sp[2854] = sp[2800] * sp[325];
    sp[2855] = sp[2801] * sp[325];
    sp[2856] = sp[2802] * sp[325];
    sp[2857] = sp[2803] * sp[325];
    sp[2858] = sp[2804] * sp[325];
    sp[2859] = sp[2805] * sp[325];
    sp[2860] = sp[2806] * sp[325];
    sp[2861] = sp[2807] * sp[325];
    sp[2862] = sp[2808] * sp[325];
    sp[2863] = sp[2809] * sp[325];
    sp[2864] = sp[2810] * sp[325];
    sp[2865] = sp[2811] * sp[325];
    sp[2866] = sp[2812] * sp[325];
    sp[2867] = sp[2813] * sp[325];
    sp[2868] = sp[2814] * sp[325];
    sp[2869] = sp[2815] * sp[325];
    sp[2870] = sp[2816] * sp[325];
    sp[2871] = sp[2817] * sp[325];
    sp[2872] = sp[2818] * sp[325];
    sp[2873] = sp[2819] * sp[325];
    sp[2874] = sp[2820] * sp[325];
    sp[2875] = sp[2821] * sp[325];
    sp[2876] = sp[2822] * sp[325];
    sp[2877] = sp[2823] * sp[325];
    sp[2878] = sp[2824] * sp[325];
    sp[2879] = sp[2825] * sp[325];
    sp[2880] = sp[2826] * sp[325];
    sp[2881] = sp[2827] * sp[325];
    sp[2882] = sp[2828] * sp[325];
    sp[2883] = sp[2829] * sp[325];
    sp[2884] = sp[2830] * sp[325];
    sp[2885] = sp[2831] * sp[325];
    sp[2886] = sp[2832] + sp[2295];
    sp[2887] = sp[2833] + sp[2304];
    sp[2888] = sp[2834] + sp[2313];
    sp[2889] = sp[2835] + sp[2322];
    sp[2890] = sp[2836] + sp[2331];
    sp[2891] = sp[2837] + sp[2340];
    sp[2892] = sp[2838] + sp[2349];
    sp[2893] = sp[2839] + sp[2358];
    sp[2894] = sp[2840] + sp[2367];
    sp[2895] = sp[2841] + sp[2296];
    sp[2896] = sp[2842] + sp[2305];
    sp[2897] = sp[2843] + sp[2314];
    sp[2898] = sp[2844] + sp[2323];
    sp[2899] = sp[2845] + sp[2332];
    sp[2900] = sp[2846] + sp[2341];
    sp[2901] = sp[2847] + sp[2350];
    sp[2902] = sp[2848] + sp[2359];
    sp[2903] = sp[2849] + sp[2368];
    sp[2904] = sp[2850] + sp[2297];
    sp[2905] = sp[2851] + sp[2306];
    sp[2906] = sp[2852] + sp[2315];
    sp[2907] = sp[2853] + sp[2324];
    sp[2908] = sp[2854] + sp[2333];
    sp[2909] = sp[2855] + sp[2342];
    sp[2910] = sp[2856] + sp[2351];
    sp[2911] = sp[2857] + sp[2360];
    sp[2912] = sp[2858] + sp[2369];
    sp[2913] = sp[2835] + sp[2298];
    sp[2914] = sp[2836] + sp[2299];
    sp[2915] = sp[2837] + sp[2300];
    sp[2916] = sp[2838] + sp[2301];
    sp[2917] = sp[2839] + sp[2302];
    sp[2918] = sp[2840] + sp[2303];
    sp[2919] = sp[2844] + sp[2307];
    sp[2920] = sp[2845] + sp[2308];
    sp[2921] = sp[2846] + sp[2309];
    sp[2922] = sp[2847] + sp[2310];
    sp[2923] = sp[2848] + sp[2311];
    sp[2924] = sp[2849] + sp[2312];
    sp[2925] = sp[2853] + sp[2316];
    sp[2926] = sp[2854] + sp[2317];
    sp[2927] = sp[2855] + sp[2318];
    sp[2928] = sp[2856] + sp[2319];
    sp[2929] = sp[2857] + sp[2320];
    sp[2930] = sp[2858] + sp[2321];
    sp[2931] = sp[2859] + sp[2325];
    sp[2932] = sp[2860] + sp[2334];
    sp[2933] = sp[2861] + sp[2343];
    sp[2934] = sp[2862] + sp[2352];
    sp[2935] = sp[2863] + sp[2361];
    sp[2936] = sp[2864] + sp[2370];
    sp[2937] = sp[2865] + sp[2326];
    sp[2938] = sp[2866] + sp[2335];
    sp[2939] = sp[2867] + sp[2344];
    sp[2940] = sp[2868] + sp[2353];
    sp[2941] = sp[2869] + sp[2362];
    sp[2942] = sp[2870] + sp[2371];
    sp[2943] = sp[2871] + sp[2327];
    sp[2944] = sp[2872] + sp[2336];
    sp[2945] = sp[2873] + sp[2345];
    sp[2946] = sp[2874] + sp[2354];
    sp[2947] = sp[2875] + sp[2363];
    sp[2948] = sp[2876] + sp[2372];
    sp[2949] = sp[2862] + sp[2328];
    sp[2950] = sp[2863] + sp[2329];
    sp[2951] = sp[2864] + sp[2330];
    sp[2952] = sp[2868] + sp[2337];
    sp[2953] = sp[2869] + sp[2338];
    sp[2954] = sp[2870] + sp[2339];
    sp[2955] = sp[2874] + sp[2346];
    sp[2956] = sp[2875] + sp[2347];
    sp[2957] = sp[2876] + sp[2348];
    sp[2958] = sp[2877] + sp[2355];
    sp[2959] = sp[2878] + sp[2364];
    sp[2960] = sp[2879] + sp[2373];
    sp[2961] = sp[2880] + sp[2356];
    sp[2962] = sp[2881] + sp[2365];
    sp[2963] = sp[2882] + sp[2374];
    sp[2964] = sp[2883] + sp[2357];
    sp[2965] = sp[2884] + sp[2366];
    sp[2966] = sp[2885] + sp[2375];
    sp[2967] = sp[561] * sp[1602];
    sp[2968] = sp[561] * sp[1603];
    sp[2969] = sp[561] * sp[1604];
    sp[2970] = sp[561] * sp[1605];
    sp[2971] = sp[561] * sp[1606];
    sp[2972] = sp[561] * sp[1607];
    sp[2973] = sp[2295] + sp[2967];
    sp[2974] = sp[2296] + sp[2968];
    sp[2975] = sp[2297] + sp[2969];
    sp[2976] = sp[2304] + sp[2968];
    sp[2977] = sp[2305] + sp[2970];
    sp[2978] = sp[2306] + sp[2971];
    sp[2979] = sp[2313] + sp[2969];
    sp[2980] = sp[2314] + sp[2971];
    sp[2981] = sp[2315] + sp[2972];
    sp[2982] = sp[2325] + sp[2967];
    sp[2983] = sp[2326] + sp[2968];
    sp[2984] = sp[2327] + sp[2969];
    sp[2985] = sp[2334] + sp[2968];
    sp[2986] = sp[2335] + sp[2970];
    sp[2987] = sp[2336] + sp[2971];
    sp[2988] = sp[2343] + sp[2969];
    sp[2989] = sp[2344] + sp[2971];
    sp[2990] = sp[2345] + sp[2972];
    sp[2991] = sp[2355] + sp[2967];
    sp[2992] = sp[2356] + sp[2968];
    sp[2993] = sp[2357] + sp[2969];
    sp[2994] = sp[2364] + sp[2968];
    sp[2995] = sp[2365] + sp[2970];
    sp[2996] = sp[2366] + sp[2971];
    sp[2997] = sp[2373] + sp[2969];
    sp[2998] = sp[2374] + sp[2971];
    sp[2999] = sp[2375] + sp[2972];
    sp[3000] = sp[2886] + sp[2973];
    sp[3001] = sp[2887] + sp[2974];
    sp[3002] = sp[2888] + sp[2975];
    sp[3003] = sp[2889] + sp[2298];
    sp[3004] = sp[2890] + sp[2299];
    sp[3005] = sp[2891] + sp[2300];
    sp[3006] = sp[2892] + sp[2301];
    sp[3007] = sp[2893] + sp[2302];
    sp[3008] = sp[2894] + sp[2303];
    sp[3009] = sp[2895] + sp[2976];
    sp[3010] = sp[2896] + sp[2977];
    sp[3011] = sp[2897] + sp[2978];
    sp[3012] = sp[2898] + sp[2307];
    sp[3013] = sp[2899] + sp[2308];
    sp[3014] = sp[2900] + sp[2309];
    sp[3015] = sp[2901] + sp[2310];
    sp[3016] = sp[2902] + sp[2311];
    sp[3017] = sp[2903] + sp[2312];
    sp[3018] = sp[2904] + sp[2979];
    sp[3019] = sp[2905] + sp[2980];
    sp[3020] = sp[2906] + sp[2981];
    sp[3021] = sp[2907] + sp[2316];
    sp[3022] = sp[2908] + sp[2317];
    sp[3023] = sp[2909] + sp[2318];
    sp[3024] = sp[2910] + sp[2319];
    sp[3025] = sp[2911] + sp[2320];
    sp[3026] = sp[2912] + sp[2321];
    sp[3027] = sp[2913] + sp[2322];
    sp[3028] = sp[2914] + sp[2331];
    sp[3029] = sp[2915] + sp[2340];
    sp[3030] = sp[2916] + sp[2349];
    sp[3031] = sp[2917] + sp[2358];
    sp[3032] = sp[2918] + sp[2367];
    sp[3033] = sp[2919] + sp[2323];
    sp[3034] = sp[2920] + sp[2332];
    sp[3035] = sp[2921] + sp[2341];
    sp[3036] = sp[2922] + sp[2350];
    sp[3037] = sp[2923] + sp[2359];
    sp[3038] = sp[2924] + sp[2368];
    sp[3039] = sp[2925] + sp[2324];
    sp[3040] = sp[2926] + sp[2333];
    sp[3041] = sp[2927] + sp[2342];
    sp[3042] = sp[2928] + sp[2351];
    sp[3043] = sp[2929] + sp[2360];
    sp[3044] = sp[2930] + sp[2369];
    sp[3045] = sp[2931] + sp[2982];
    sp[3046] = sp[2932] + sp[2983];
    sp[3047] = sp[2933] + sp[2984];
    sp[3048] = sp[2934] + sp[2328];
    sp[3049] = sp[2935] + sp[2329];
    sp[3050] = sp[2936] + sp[2330];
    sp[3051] = sp[2937] + sp[2985];
    sp[3052] = sp[2938] + sp[2986];
    sp[3053] = sp[2939] + sp[2987];
    sp[3054] = sp[2940] + sp[2337];
    sp[3055] = sp[2941] + sp[2338];
    sp[3056] = sp[2942] + sp[2339];
    sp[3057] = sp[2943] + sp[2988];
    sp[3058] = sp[2944] + sp[2989];
    sp[3059] = sp[2945] + sp[2990];
    sp[3060] = sp[2946] + sp[2346];
    sp[3061] = sp[2947] + sp[2347];
    sp[3062] = sp[2948] + sp[2348];
    sp[3063] = sp[2949] + sp[2352];
    sp[3064] = sp[2950] + sp[2361];
    sp[3065] = sp[2951] + sp[2370];
    sp[3066] = sp[2952] + sp[2353];
    sp[3067] = sp[2953] + sp[2362];
    sp[3068] = sp[2954] + sp[2371];
    sp[3069] = sp[2955] + sp[2354];
    sp[3070] = sp[2956] + sp[2363];
    sp[3071] = sp[2957] + sp[2372];
    sp[3072] = sp[2958] + sp[2991];
    sp[3073] = sp[2959] + sp[2992];
    sp[3074] = sp[2960] + sp[2993];
    sp[3075] = sp[2961] + sp[2994];
    sp[3076] = sp[2962] + sp[2995];
    sp[3077] = sp[2963] + sp[2996];
    sp[3078] = sp[2964] + sp[2997];
    sp[3079] = sp[2965] + sp[2998];
    sp[3080] = sp[2966] + sp[2999];
    sp[3081] = sp[2214] + sp[3000];
    sp[3082] = sp[2215] + sp[3001];
    sp[3083] = sp[2216] + sp[3002];
    sp[3084] = sp[2217] + sp[3003];
    sp[3085] = sp[2218] + sp[3004];
    sp[3086] = sp[2219] + sp[3005];
    sp[3087] = sp[2220] + sp[3006];
    sp[3088] = sp[2221] + sp[3007];
    sp[3089] = sp[2222] + sp[3008];
    sp[3090] = sp[2223] + sp[3009];
    sp[3091] = sp[2224] + sp[3010];
    sp[3092] = sp[2225] + sp[3011];
    sp[3093] = sp[2226] + sp[3012];
    sp[3094] = sp[2227] + sp[3013];
    sp[3095] = sp[2228] + sp[3014];
    sp[3096] = sp[2229] + sp[3015];
    sp[3097] = sp[2230] + sp[3016];
    sp[3098] = sp[2231] + sp[3017];
    sp[3099] = sp[2232] + sp[3018];
    sp[3100] = sp[2233] + sp[3019];
    sp[3101] = sp[2234] + sp[3020];
    sp[3102] = sp[2235] + sp[3021];
    sp[3103] = sp[2236] + sp[3022];
    sp[3104] = sp[2237] + sp[3023];
    sp[3105] = sp[2238] + sp[3024];
    sp[3106] = sp[2239] + sp[3025];
    sp[3107] = sp[2240] + sp[3026];
    sp[3108] = sp[2241] + sp[3027];
    sp[3109] = sp[2242] + sp[3028];
    sp[3110] = sp[2243] + sp[3029];
    sp[3111] = sp[2244] + sp[3030];
    sp[3112] = sp[2245] + sp[3031];
    sp[3113] = sp[2246] + sp[3032];
    sp[3114] = sp[2247] + sp[3033];
    sp[3115] = sp[2248] + sp[3034];
    sp[3116] = sp[2249] + sp[3035];
    sp[3117] = sp[2250] + sp[3036];
    sp[3118] = sp[2251] + sp[3037];
    sp[3119] = sp[2252] + sp[3038];
    sp[3120] = sp[2253] + sp[3039];
    sp[3121] = sp[2254] + sp[3040];
    sp[3122] = sp[2255] + sp[3041];
    sp[3123] = sp[2256] + sp[3042];
    sp[3124] = sp[2257] + sp[3043];
    sp[3125] = sp[2258] + sp[3044];
    sp[3126] = sp[2259] + sp[3045];
    sp[3127] = sp[2260] + sp[3046];
    sp[3128] = sp[2261] + sp[3047];
    sp[3129] = sp[2262] + sp[3048];
    sp[3130] = sp[2263] + sp[3049];
    sp[3131] = sp[2264] + sp[3050];
    sp[3132] = sp[2265] + sp[3051];
    sp[3133] = sp[2266] + sp[3052];
    sp[3134] = sp[2267] + sp[3053];
    sp[3135] = sp[2268] + sp[3054];
    sp[3136] = sp[2269] + sp[3055];
    sp[3137] = sp[2270] + sp[3056];
    sp[3138] = sp[2271] + sp[3057];
    sp[3139] = sp[2272] + sp[3058];
    sp[3140] = sp[2273] + sp[3059];
    sp[3141] = sp[2274] + sp[3060];
    sp[3142] = sp[2275] + sp[3061];
    sp[3143] = sp[2276] + sp[3062];
    sp[3144] = sp[2277] + sp[3063];
    sp[3145] = sp[2278] + sp[3064];
    sp[3146] = sp[2279] + sp[3065];
    sp[3147] = sp[2280] + sp[3066];
    sp[3148] = sp[2281] + sp[3067];
    sp[3149] = sp[2282] + sp[3068];
    sp[3150] = sp[2283] + sp[3069];
    sp[3151] = sp[2284] + sp[3070];
    sp[3152] = sp[2285] + sp[3071];
    sp[3153] = sp[2286] + sp[3072];
    sp[3154] = sp[2287] + sp[3073];
    sp[3155] = sp[2288] + sp[3074];
    sp[3156] = sp[2289] + sp[3075];
    sp[3157] = sp[2290] + sp[3076];
    sp[3158] = sp[2291] + sp[3077];
    sp[3159] = sp[2292] + sp[3078];
    sp[3160] = sp[2293] + sp[3079];
    sp[3161] = sp[2294] + sp[3080];
    sp[3162] = 0.3333333333333333 * sp[3081] * std::pow(sp[593], -0.6666666666666667);
    sp[3163] = 0.3333333333333333 * sp[3082] * std::pow(sp[593], -0.6666666666666667);
    sp[3164] = 0.3333333333333333 * sp[3083] * std::pow(sp[593], -0.6666666666666667);
    sp[3165] = 0.3333333333333333 * sp[3084] * std::pow(sp[593], -0.6666666666666667);
    sp[3166] = 0.3333333333333333 * sp[3085] * std::pow(sp[593], -0.6666666666666667);
    sp[3167] = 0.3333333333333333 * sp[3086] * std::pow(sp[593], -0.6666666666666667);
    sp[3168] = 0.3333333333333333 * sp[3087] * std::pow(sp[593], -0.6666666666666667);
    sp[3169] = 0.3333333333333333 * sp[3088] * std::pow(sp[593], -0.6666666666666667);
    sp[3170] = 0.3333333333333333 * sp[3089] * std::pow(sp[593], -0.6666666666666667);
    sp[3171] = 0.3333333333333333 * sp[3090] * std::pow(sp[593], -0.6666666666666667);
    sp[3172] = 0.3333333333333333 * sp[3091] * std::pow(sp[593], -0.6666666666666667);
    sp[3173] = 0.3333333333333333 * sp[3092] * std::pow(sp[593], -0.6666666666666667);
    sp[3174] = 0.3333333333333333 * sp[3093] * std::pow(sp[593], -0.6666666666666667);
    sp[3175] = 0.3333333333333333 * sp[3094] * std::pow(sp[593], -0.6666666666666667);
    sp[3176] = 0.3333333333333333 * sp[3095] * std::pow(sp[593], -0.6666666666666667);
    sp[3177] = 0.3333333333333333 * sp[3096] * std::pow(sp[593], -0.6666666666666667);
    sp[3178] = 0.3333333333333333 * sp[3097] * std::pow(sp[593], -0.6666666666666667);
    sp[3179] = 0.3333333333333333 * sp[3098] * std::pow(sp[593], -0.6666666666666667);
    sp[3180] = 0.3333333333333333 * sp[3099] * std::pow(sp[593], -0.6666666666666667);
    sp[3181] = 0.3333333333333333 * sp[3100] * std::pow(sp[593], -0.6666666666666667);
    sp[3182] = 0.3333333333333333 * sp[3101] * std::pow(sp[593], -0.6666666666666667);
    sp[3183] = 0.3333333333333333 * sp[3102] * std::pow(sp[593], -0.6666666666666667);
    sp[3184] = 0.3333333333333333 * sp[3103] * std::pow(sp[593], -0.6666666666666667);
    sp[3185] = 0.3333333333333333 * sp[3104] * std::pow(sp[593], -0.6666666666666667);
    sp[3186] = 0.3333333333333333 * sp[3105] * std::pow(sp[593], -0.6666666666666667);
    sp[3187] = 0.3333333333333333 * sp[3106] * std::pow(sp[593], -0.6666666666666667);
    sp[3188] = 0.3333333333333333 * sp[3107] * std::pow(sp[593], -0.6666666666666667);
    sp[3189] = 0.3333333333333333 * sp[3108] * std::pow(sp[593], -0.6666666666666667);
    sp[3190] = 0.3333333333333333 * sp[3109] * std::pow(sp[593], -0.6666666666666667);
    sp[3191] = 0.3333333333333333 * sp[3110] * std::pow(sp[593], -0.6666666666666667);
    sp[3192] = 0.3333333333333333 * sp[3111] * std::pow(sp[593], -0.6666666666666667);
    sp[3193] = 0.3333333333333333 * sp[3112] * std::pow(sp[593], -0.6666666666666667);
    sp[3194] = 0.3333333333333333 * sp[3113] * std::pow(sp[593], -0.6666666666666667);
    sp[3195] = 0.3333333333333333 * sp[3114] * std::pow(sp[593], -0.6666666666666667);
    sp[3196] = 0.3333333333333333 * sp[3115] * std::pow(sp[593], -0.6666666666666667);
    sp[3197] = 0.3333333333333333 * sp[3116] * std::pow(sp[593], -0.6666666666666667);
    sp[3198] = 0.3333333333333333 * sp[3117] * std::pow(sp[593], -0.6666666666666667);
    sp[3199] = 0.3333333333333333 * sp[3118] * std::pow(sp[593], -0.6666666666666667);
    sp[3200] = 0.3333333333333333 * sp[3119] * std::pow(sp[593], -0.6666666666666667);
    sp[3201] = 0.3333333333333333 * sp[3120] * std::pow(sp[593], -0.6666666666666667);
    sp[3202] = 0.3333333333333333 * sp[3121] * std::pow(sp[593], -0.6666666666666667);
    sp[3203] = 0.3333333333333333 * sp[3122] * std::pow(sp[593], -0.6666666666666667);
    sp[3204] = 0.3333333333333333 * sp[3123] * std::pow(sp[593], -0.6666666666666667);
    sp[3205] = 0.3333333333333333 * sp[3124] * std::pow(sp[593], -0.6666666666666667);
    sp[3206] = 0.3333333333333333 * sp[3125] * std::pow(sp[593], -0.6666666666666667);
    sp[3207] = 0.3333333333333333 * sp[3126] * std::pow(sp[593], -0.6666666666666667);
    sp[3208] = 0.3333333333333333 * sp[3127] * std::pow(sp[593], -0.6666666666666667);
    sp[3209] = 0.3333333333333333 * sp[3128] * std::pow(sp[593], -0.6666666666666667);
    sp[3210] = 0.3333333333333333 * sp[3129] * std::pow(sp[593], -0.6666666666666667);
    sp[3211] = 0.3333333333333333 * sp[3130] * std::pow(sp[593], -0.6666666666666667);
    sp[3212] = 0.3333333333333333 * sp[3131] * std::pow(sp[593], -0.6666666666666667);
    sp[3213] = 0.3333333333333333 * sp[3132] * std::pow(sp[593], -0.6666666666666667);
    sp[3214] = 0.3333333333333333 * sp[3133] * std::pow(sp[593], -0.6666666666666667);
    sp[3215] = 0.3333333333333333 * sp[3134] * std::pow(sp[593], -0.6666666666666667);
    sp[3216] = 0.3333333333333333 * sp[3135] * std::pow(sp[593], -0.6666666666666667);
    sp[3217] = 0.3333333333333333 * sp[3136] * std::pow(sp[593], -0.6666666666666667);
    sp[3218] = 0.3333333333333333 * sp[3137] * std::pow(sp[593], -0.6666666666666667);
    sp[3219] = 0.3333333333333333 * sp[3138] * std::pow(sp[593], -0.6666666666666667);
    sp[3220] = 0.3333333333333333 * sp[3139] * std::pow(sp[593], -0.6666666666666667);
    sp[3221] = 0.3333333333333333 * sp[3140] * std::pow(sp[593], -0.6666666666666667);
    sp[3222] = 0.3333333333333333 * sp[3141] * std::pow(sp[593], -0.6666666666666667);
    sp[3223] = 0.3333333333333333 * sp[3142] * std::pow(sp[593], -0.6666666666666667);
    sp[3224] = 0.3333333333333333 * sp[3143] * std::pow(sp[593], -0.6666666666666667);
    sp[3225] = 0.3333333333333333 * sp[3144] * std::pow(sp[593], -0.6666666666666667);
    sp[3226] = 0.3333333333333333 * sp[3145] * std::pow(sp[593], -0.6666666666666667);
    sp[3227] = 0.3333333333333333 * sp[3146] * std::pow(sp[593], -0.6666666666666667);
    sp[3228] = 0.3333333333333333 * sp[3147] * std::pow(sp[593], -0.6666666666666667);
    sp[3229] = 0.3333333333333333 * sp[3148] * std::pow(sp[593], -0.6666666666666667);
    sp[3230] = 0.3333333333333333 * sp[3149] * std::pow(sp[593], -0.6666666666666667);
    sp[3231] = 0.3333333333333333 * sp[3150] * std::pow(sp[593], -0.6666666666666667);
    sp[3232] = 0.3333333333333333 * sp[3151] * std::pow(sp[593], -0.6666666666666667);
    sp[3233] = 0.3333333333333333 * sp[3152] * std::pow(sp[593], -0.6666666666666667);
    sp[3234] = 0.3333333333333333 * sp[3153] * std::pow(sp[593], -0.6666666666666667);
    sp[3235] = 0.3333333333333333 * sp[3154] * std::pow(sp[593], -0.6666666666666667);
    sp[3236] = 0.3333333333333333 * sp[3155] * std::pow(sp[593], -0.6666666666666667);
    sp[3237] = 0.3333333333333333 * sp[3156] * std::pow(sp[593], -0.6666666666666667);
    sp[3238] = 0.3333333333333333 * sp[3157] * std::pow(sp[593], -0.6666666666666667);
    sp[3239] = 0.3333333333333333 * sp[3158] * std::pow(sp[593], -0.6666666666666667);
    sp[3240] = 0.3333333333333333 * sp[3159] * std::pow(sp[593], -0.6666666666666667);
    sp[3241] = 0.3333333333333333 * sp[3160] * std::pow(sp[593], -0.6666666666666667);
    sp[3242] = 0.3333333333333333 * sp[3161] * std::pow(sp[593], -0.6666666666666667);
    sp[3243] = sp[603] + sp[3162];
    sp[3244] = sp[604] + sp[3163];
    sp[3245] = sp[605] + sp[3164];
    sp[3246] = sp[606] + sp[3165];
    sp[3247] = sp[607] + sp[3166];
    sp[3248] = sp[608] + sp[3167];
    sp[3249] = sp[609] + sp[3168];
    sp[3250] = sp[610] + sp[3169];
    sp[3251] = sp[611] + sp[3170];
    sp[3252] = sp[612] + sp[3171];
    sp[3253] = sp[613] + sp[3172];
    sp[3254] = sp[614] + sp[3173];
    sp[3255] = sp[615] + sp[3174];
    sp[3256] = sp[616] + sp[3175];
    sp[3257] = sp[617] + sp[3176];
    sp[3258] = sp[618] + sp[3177];
    sp[3259] = sp[619] + sp[3178];
    sp[3260] = sp[620] + sp[3179];
    sp[3261] = sp[621] + sp[3180];
    sp[3262] = sp[622] + sp[3181];
    sp[3263] = sp[623] + sp[3182];
    sp[3264] = sp[624] + sp[3183];
    sp[3265] = sp[625] + sp[3184];
    sp[3266] = sp[626] + sp[3185];
    sp[3267] = sp[627] + sp[3186];
    sp[3268] = sp[628] + sp[3187];
    sp[3269] = sp[629] + sp[3188];
    sp[3270] = sp[630] + sp[3189];
    sp[3271] = sp[639] + sp[3190];
    sp[3272] = sp[648] + sp[3191];
    sp[3273] = sp[657] + sp[3192];
    sp[3274] = sp[666] + sp[3193];
    sp[3275] = sp[675] + sp[3194];
    sp[3276] = sp[631] + sp[3195];
    sp[3277] = sp[640] + sp[3196];
    sp[3278] = sp[649] + sp[3197];
    sp[3279] = sp[658] + sp[3198];
    sp[3280] = sp[667] + sp[3199];
    sp[3281] = sp[676] + sp[3200];
    sp[3282] = sp[632] + sp[3201];
    sp[3283] = sp[641] + sp[3202];
    sp[3284] = sp[650] + sp[3203];
    sp[3285] = sp[659] + sp[3204];
    sp[3286] = sp[668] + sp[3205];
    sp[3287] = sp[677] + sp[3206];
    sp[3288] = sp[633] + sp[3207];
    sp[3289] = sp[634] + sp[3208];
    sp[3290] = sp[635] + sp[3209];
    sp[3291] = sp[636] + sp[3210];
    sp[3292] = sp[637] + sp[3211];
    sp[3293] = sp[638] + sp[3212];
    sp[3294] = sp[642] + sp[3213];
    sp[3295] = sp[643] + sp[3214];
    sp[3296] = sp[644] + sp[3215];
    sp[3297] = sp[645] + sp[3216];
    sp[3298] = sp[646] + sp[3217];
    sp[3299] = sp[647] + sp[3218];
    sp[3300] = sp[651] + sp[3219];
    sp[3301] = sp[652] + sp[3220];
    sp[3302] = sp[653] + sp[3221];
    sp[3303] = sp[654] + sp[3222];
    sp[3304] = sp[655] + sp[3223];
    sp[3305] = sp[656] + sp[3224];
    sp[3306] = sp[660] + sp[3225];
    sp[3307] = sp[669] + sp[3226];
    sp[3308] = sp[678] + sp[3227];
    sp[3309] = sp[661] + sp[3228];
    sp[3310] = sp[670] + sp[3229];
    sp[3311] = sp[679] + sp[3230];
    sp[3312] = sp[662] + sp[3231];
    sp[3313] = sp[671] + sp[3232];
    sp[3314] = sp[680] + sp[3233];
    sp[3315] = sp[663] + sp[3234];
    sp[3316] = sp[664] + sp[3235];
    sp[3317] = sp[665] + sp[3236];
    sp[3318] = sp[672] + sp[3237];
    sp[3319] = sp[673] + sp[3238];
    sp[3320] = sp[674] + sp[3239];
    sp[3321] = sp[681] + sp[3240];
    sp[3322] = sp[682] + sp[3241];
    sp[3323] = sp[683] + sp[3242];
    sp[3324] = sp[272] + sp[175];
    sp[3325] = sp[3324] + sp[143];
    sp[3326] = sp[3325] / std::pow(sp[593], 0.3333333333333333);
    sp[3327] = sp[3243] * sp[3326];
    sp[3328] = sp[3244] * sp[3326];
    sp[3329] = sp[3245] * sp[3326];
    sp[3330] = sp[3246] * sp[3326];
    sp[3331] = sp[3247] * sp[3326];
    sp[3332] = sp[3248] * sp[3326];
    sp[3333] = sp[3249] * sp[3326];
    sp[3334] = sp[3250] * sp[3326];
    sp[3335] = sp[3251] * sp[3326];
    sp[3336] = sp[3252] * sp[3326];
    sp[3337] = sp[3253] * sp[3326];
    sp[3338] = sp[3254] * sp[3326];
    sp[3339] = sp[3255] * sp[3326];
    sp[3340] = sp[3256] * sp[3326];
    sp[3341] = sp[3257] * sp[3326];
    sp[3342] = sp[3258] * sp[3326];
    sp[3343] = sp[3259] * sp[3326];
    sp[3344] = sp[3260] * sp[3326];
    sp[3345] = sp[3261] * sp[3326];
    sp[3346] = sp[3262] * sp[3326];
    sp[3347] = sp[3263] * sp[3326];
    sp[3348] = sp[3264] * sp[3326];
    sp[3349] = sp[3265] * sp[3326];
    sp[3350] = sp[3266] * sp[3326];
    sp[3351] = sp[3267] * sp[3326];
    sp[3352] = sp[3268] * sp[3326];
    sp[3353] = sp[3269] * sp[3326];
    sp[3354] = sp[3270] * sp[3326];
    sp[3355] = sp[3271] * sp[3326];
    sp[3356] = sp[3272] * sp[3326];
    sp[3357] = sp[3273] * sp[3326];
    sp[3358] = sp[3274] * sp[3326];
    sp[3359] = sp[3275] * sp[3326];
    sp[3360] = sp[3276] * sp[3326];
    sp[3361] = sp[3277] * sp[3326];
    sp[3362] = sp[3278] * sp[3326];
    sp[3363] = sp[3279] * sp[3326];
    sp[3364] = sp[3280] * sp[3326];
    sp[3365] = sp[3281] * sp[3326];
    sp[3366] = sp[3282] * sp[3326];
    sp[3367] = sp[3283] * sp[3326];
    sp[3368] = sp[3284] * sp[3326];
    sp[3369] = sp[3285] * sp[3326];
    sp[3370] = sp[3286] * sp[3326];
    sp[3371] = sp[3287] * sp[3326];
    sp[3372] = sp[3288] * sp[3326];
    sp[3373] = sp[3289] * sp[3326];
    sp[3374] = sp[3290] * sp[3326];
    sp[3375] = sp[3291] * sp[3326];
    sp[3376] = sp[3292] * sp[3326];
    sp[3377] = sp[3293] * sp[3326];
    sp[3378] = sp[3294] * sp[3326];
    sp[3379] = sp[3295] * sp[3326];
    sp[3380] = sp[3296] * sp[3326];
    sp[3381] = sp[3297] * sp[3326];
    sp[3382] = sp[3298] * sp[3326];
    sp[3383] = sp[3299] * sp[3326];
    sp[3384] = sp[3300] * sp[3326];
    sp[3385] = sp[3301] * sp[3326];
    sp[3386] = sp[3302] * sp[3326];
    sp[3387] = sp[3303] * sp[3326];
    sp[3388] = sp[3304] * sp[3326];
    sp[3389] = sp[3305] * sp[3326];
    sp[3390] = sp[3306] * sp[3326];
    sp[3391] = sp[3307] * sp[3326];
    sp[3392] = sp[3308] * sp[3326];
    sp[3393] = sp[3309] * sp[3326];
    sp[3394] = sp[3310] * sp[3326];
    sp[3395] = sp[3311] * sp[3326];
    sp[3396] = sp[3312] * sp[3326];
    sp[3397] = sp[3313] * sp[3326];
    sp[3398] = sp[3314] * sp[3326];
    sp[3399] = sp[3315] * sp[3326];
    sp[3400] = sp[3316] * sp[3326];
    sp[3401] = sp[3317] * sp[3326];
    sp[3402] = sp[3318] * sp[3326];
    sp[3403] = sp[3319] * sp[3326];
    sp[3404] = sp[3320] * sp[3326];
    sp[3405] = sp[3321] * sp[3326];
    sp[3406] = sp[3322] * sp[3326];
    sp[3407] = sp[3323] * sp[3326];
    sp[3408] = 0.3333333333333333 * sp[580] * std::pow(sp[593], -0.6666666666666667);
    sp[3409] = 0.3333333333333333 * sp[581] * std::pow(sp[593], -0.6666666666666667);
    sp[3410] = 0.3333333333333333 * sp[582] * std::pow(sp[593], -0.6666666666666667);
    sp[3411] = 0.3333333333333333 * sp[583] * std::pow(sp[593], -0.6666666666666667);
    sp[3412] = 0.3333333333333333 * sp[584] * std::pow(sp[593], -0.6666666666666667);
    sp[3413] = 0.3333333333333333 * sp[585] * std::pow(sp[593], -0.6666666666666667);
    sp[3414] = 0.3333333333333333 * sp[586] * std::pow(sp[593], -0.6666666666666667);
    sp[3415] = 0.3333333333333333 * sp[587] * std::pow(sp[593], -0.6666666666666667);
    sp[3416] = 0.3333333333333333 * sp[588] * std::pow(sp[593], -0.6666666666666667);
    sp[3417] = sp[99] + sp[285];
    sp[3418] = sp[100] + sp[286];
    sp[3419] = sp[287] + sp[101];
    sp[3420] = sp[110] + sp[291];
    sp[3421] = sp[111] + sp[292];
    sp[3422] = sp[293] + sp[112];
    sp[3423] = sp[121] + sp[297];
    sp[3424] = sp[122] + sp[298];
    sp[3425] = sp[299] + sp[123];
    sp[3426] = sp[3417] + sp[156];
    sp[3427] = sp[3418] + sp[157];
    sp[3428] = sp[3419] + sp[158];
    sp[3429] = sp[3420] + sp[162];
    sp[3430] = sp[3421] + sp[163];
    sp[3431] = sp[3422] + sp[164];
    sp[3432] = sp[3423] + sp[168];
    sp[3433] = sp[3424] + sp[169];
    sp[3434] = sp[3425] + sp[170];
    sp[3435] = sp[3408] * sp[3326];
    sp[3436] = sp[3409] * sp[3326];
    sp[3437] = sp[3410] * sp[3326];
    sp[3438] = sp[3411] * sp[3326];
    sp[3439] = sp[3412] * sp[3326];
    sp[3440] = sp[3413] * sp[3326];
    sp[3441] = sp[3414] * sp[3326];
    sp[3442] = sp[3415] * sp[3326];
    sp[3443] = sp[3416] * sp[3326];
    sp[3444] = sp[3426] + -1 * sp[3435];
    sp[3445] = sp[3427] + -1 * sp[3436];
    sp[3446] = sp[3428] + -1 * sp[3437];
    sp[3447] = sp[3429] + -1 * sp[3438];
    sp[3448] = sp[3430] + -1 * sp[3439];
    sp[3449] = sp[3431] + -1 * sp[3440];
    sp[3450] = sp[3432] + -1 * sp[3441];
    sp[3451] = sp[3433] + -1 * sp[3442];
    sp[3452] = sp[3434] + -1 * sp[3443];
    sp[3453] = sp[3444] / std::pow(sp[593], 0.3333333333333333);
    sp[3454] = sp[3445] / std::pow(sp[593], 0.3333333333333333);
    sp[3455] = sp[3446] / std::pow(sp[593], 0.3333333333333333);
    sp[3456] = sp[3447] / std::pow(sp[593], 0.3333333333333333);
    sp[3457] = sp[3448] / std::pow(sp[593], 0.3333333333333333);
    sp[3458] = sp[3449] / std::pow(sp[593], 0.3333333333333333);
    sp[3459] = sp[3450] / std::pow(sp[593], 0.3333333333333333);
    sp[3460] = sp[3451] / std::pow(sp[593], 0.3333333333333333);
    sp[3461] = sp[3452] / std::pow(sp[593], 0.3333333333333333);
    sp[3462] = sp[3408] * sp[3453];
    sp[3463] = sp[3408] * sp[3454];
    sp[3464] = sp[3408] * sp[3455];
    sp[3465] = sp[3408] * sp[3456];
    sp[3466] = sp[3408] * sp[3457];
    sp[3467] = sp[3408] * sp[3458];
    sp[3468] = sp[3408] * sp[3459];
    sp[3469] = sp[3408] * sp[3460];
    sp[3470] = sp[3408] * sp[3461];
    sp[3471] = sp[3409] * sp[3453];
    sp[3472] = sp[3409] * sp[3454];
    sp[3473] = sp[3409] * sp[3455];
    sp[3474] = sp[3409] * sp[3456];
    sp[3475] = sp[3409] * sp[3457];
    sp[3476] = sp[3409] * sp[3458];
    sp[3477] = sp[3409] * sp[3459];
    sp[3478] = sp[3409] * sp[3460];
    sp[3479] = sp[3409] * sp[3461];
    sp[3480] = sp[3410] * sp[3453];
    sp[3481] = sp[3410] * sp[3454];
    sp[3482] = sp[3410] * sp[3455];
    sp[3483] = sp[3410] * sp[3456];
    sp[3484] = sp[3410] * sp[3457];
    sp[3485] = sp[3410] * sp[3458];
    sp[3486] = sp[3410] * sp[3459];
    sp[3487] = sp[3410] * sp[3460];
    sp[3488] = sp[3410] * sp[3461];
    sp[3489] = sp[3411] * sp[3453];
    sp[3490] = sp[3411] * sp[3454];
    sp[3491] = sp[3411] * sp[3455];
    sp[3492] = sp[3411] * sp[3456];
    sp[3493] = sp[3411] * sp[3457];
    sp[3494] = sp[3411] * sp[3458];
    sp[3495] = sp[3411] * sp[3459];
    sp[3496] = sp[3411] * sp[3460];
    sp[3497] = sp[3411] * sp[3461];
    sp[3498] = sp[3412] * sp[3453];
    sp[3499] = sp[3412] * sp[3454];
    sp[3500] = sp[3412] * sp[3455];
    sp[3501] = sp[3412] * sp[3456];
    sp[3502] = sp[3412] * sp[3457];
    sp[3503] = sp[3412] * sp[3458];
    sp[3504] = sp[3412] * sp[3459];
    sp[3505] = sp[3412] * sp[3460];
    sp[3506] = sp[3412] * sp[3461];
    sp[3507] = sp[3413] * sp[3453];
    sp[3508] = sp[3413] * sp[3454];
    sp[3509] = sp[3413] * sp[3455];
    sp[3510] = sp[3413] * sp[3456];
    sp[3511] = sp[3413] * sp[3457];
    sp[3512] = sp[3413] * sp[3458];
    sp[3513] = sp[3413] * sp[3459];
    sp[3514] = sp[3413] * sp[3460];
    sp[3515] = sp[3413] * sp[3461];
    sp[3516] = sp[3414] * sp[3453];
    sp[3517] = sp[3414] * sp[3454];
    sp[3518] = sp[3414] * sp[3455];
    sp[3519] = sp[3414] * sp[3456];
    sp[3520] = sp[3414] * sp[3457];
    sp[3521] = sp[3414] * sp[3458];
    sp[3522] = sp[3414] * sp[3459];
    sp[3523] = sp[3414] * sp[3460];
    sp[3524] = sp[3414] * sp[3461];
    sp[3525] = sp[3415] * sp[3453];
    sp[3526] = sp[3415] * sp[3454];
    sp[3527] = sp[3415] * sp[3455];
    sp[3528] = sp[3415] * sp[3456];
    sp[3529] = sp[3415] * sp[3457];
    sp[3530] = sp[3415] * sp[3458];
    sp[3531] = sp[3415] * sp[3459];
    sp[3532] = sp[3415] * sp[3460];
    sp[3533] = sp[3415] * sp[3461];
    sp[3534] = sp[3416] * sp[3453];
    sp[3535] = sp[3416] * sp[3454];
    sp[3536] = sp[3416] * sp[3455];
    sp[3537] = sp[3416] * sp[3456];
    sp[3538] = sp[3416] * sp[3457];
    sp[3539] = sp[3416] * sp[3458];
    sp[3540] = sp[3416] * sp[3459];
    sp[3541] = sp[3416] * sp[3460];
    sp[3542] = sp[3416] * sp[3461];
    sp[3543] = sp[3327] + sp[3462];
    sp[3544] = sp[3328] + sp[3463];
    sp[3545] = sp[3329] + sp[3464];
    sp[3546] = sp[3330] + sp[3465];
    sp[3547] = sp[3331] + sp[3466];
    sp[3548] = sp[3332] + sp[3467];
    sp[3549] = sp[3333] + sp[3468];
    sp[3550] = sp[3334] + sp[3469];
    sp[3551] = sp[3335] + sp[3470];
    sp[3552] = sp[3336] + sp[3471];
    sp[3553] = sp[3337] + sp[3472];
    sp[3554] = sp[3338] + sp[3473];
    sp[3555] = sp[3339] + sp[3474];
    sp[3556] = sp[3340] + sp[3475];
    sp[3557] = sp[3341] + sp[3476];
    sp[3558] = sp[3342] + sp[3477];
    sp[3559] = sp[3343] + sp[3478];
    sp[3560] = sp[3344] + sp[3479];
    sp[3561] = sp[3345] + sp[3480];
    sp[3562] = sp[3346] + sp[3481];
    sp[3563] = sp[3347] + sp[3482];
    sp[3564] = sp[3348] + sp[3483];
    sp[3565] = sp[3349] + sp[3484];
    sp[3566] = sp[3350] + sp[3485];
    sp[3567] = sp[3351] + sp[3486];
    sp[3568] = sp[3352] + sp[3487];
    sp[3569] = sp[3353] + sp[3488];
    sp[3570] = sp[3354] + sp[3489];
    sp[3571] = sp[3355] + sp[3498];
    sp[3572] = sp[3356] + sp[3507];
    sp[3573] = sp[3357] + sp[3516];
    sp[3574] = sp[3358] + sp[3525];
    sp[3575] = sp[3359] + sp[3534];
    sp[3576] = sp[3360] + sp[3490];
    sp[3577] = sp[3361] + sp[3499];
    sp[3578] = sp[3362] + sp[3508];
    sp[3579] = sp[3363] + sp[3517];
    sp[3580] = sp[3364] + sp[3526];
    sp[3581] = sp[3365] + sp[3535];
    sp[3582] = sp[3366] + sp[3491];
    sp[3583] = sp[3367] + sp[3500];
    sp[3584] = sp[3368] + sp[3509];
    sp[3585] = sp[3369] + sp[3518];
    sp[3586] = sp[3370] + sp[3527];
    sp[3587] = sp[3371] + sp[3536];
    sp[3588] = sp[3372] + sp[3492];
    sp[3589] = sp[3373] + sp[3493];
    sp[3590] = sp[3374] + sp[3494];
    sp[3591] = sp[3375] + sp[3495];
    sp[3592] = sp[3376] + sp[3496];
    sp[3593] = sp[3377] + sp[3497];
    sp[3594] = sp[3378] + sp[3501];
    sp[3595] = sp[3379] + sp[3502];
    sp[3596] = sp[3380] + sp[3503];
    sp[3597] = sp[3381] + sp[3504];
    sp[3598] = sp[3382] + sp[3505];
    sp[3599] = sp[3383] + sp[3506];
    sp[3600] = sp[3384] + sp[3510];
    sp[3601] = sp[3385] + sp[3511];
    sp[3602] = sp[3386] + sp[3512];
    sp[3603] = sp[3387] + sp[3513];
    sp[3604] = sp[3388] + sp[3514];
    sp[3605] = sp[3389] + sp[3515];
    sp[3606] = sp[3390] + sp[3519];
    sp[3607] = sp[3391] + sp[3528];
    sp[3608] = sp[3392] + sp[3537];
    sp[3609] = sp[3393] + sp[3520];
    sp[3610] = sp[3394] + sp[3529];
    sp[3611] = sp[3395] + sp[3538];
    sp[3612] = sp[3396] + sp[3521];
    sp[3613] = sp[3397] + sp[3530];
    sp[3614] = sp[3398] + sp[3539];
    sp[3615] = sp[3399] + sp[3522];
    sp[3616] = sp[3400] + sp[3523];
    sp[3617] = sp[3401] + sp[3524];
    sp[3618] = sp[3402] + sp[3531];
    sp[3619] = sp[3403] + sp[3532];
    sp[3620] = sp[3404] + sp[3533];
    sp[3621] = sp[3405] + sp[3540];
    sp[3622] = sp[3406] + sp[3541];
    sp[3623] = sp[3407] + sp[3542];
    sp[3624] = sp[85] + -1 * sp[3543];
    sp[3625] = sp[86] + -1 * sp[3544];
    sp[3626] = sp[87] + -1 * sp[3545];
    sp[3627] = sp[86] + -1 * sp[3552];
    sp[3628] = sp[88] + -1 * sp[3553];
    sp[3629] = sp[89] + -1 * sp[3554];
    sp[3630] = sp[87] + -1 * sp[3561];
    sp[3631] = sp[89] + -1 * sp[3562];
    sp[3632] = sp[90] + -1 * sp[3563];
    sp[3633] = sp[85] + -1 * sp[3588];
    sp[3634] = sp[86] + -1 * sp[3589];
    sp[3635] = sp[87] + -1 * sp[3590];
    sp[3636] = sp[86] + -1 * sp[3594];
    sp[3637] = sp[88] + -1 * sp[3595];
    sp[3638] = sp[89] + -1 * sp[3596];
    sp[3639] = sp[87] + -1 * sp[3600];
    sp[3640] = sp[89] + -1 * sp[3601];
    sp[3641] = sp[90] + -1 * sp[3602];
    sp[3642] = sp[85] + -1 * sp[3615];
    sp[3643] = sp[86] + -1 * sp[3616];
    sp[3644] = sp[87] + -1 * sp[3617];
    sp[3645] = sp[86] + -1 * sp[3618];
    sp[3646] = sp[88] + -1 * sp[3619];
    sp[3647] = sp[89] + -1 * sp[3620];
    sp[3648] = sp[87] + -1 * sp[3621];
    sp[3649] = sp[89] + -1 * sp[3622];
    sp[3650] = sp[90] + -1 * sp[3623];
    sp[3651] = sp[3624] + -1 * sp[3462];
    sp[3652] = sp[3625] + -1 * sp[3471];
    sp[3653] = sp[3626] + -1 * sp[3480];
    sp[3654] = -1 * sp[3546] + -1 * sp[3489];
    sp[3655] = -1 * sp[3547] + -1 * sp[3498];
    sp[3656] = -1 * sp[3548] + -1 * sp[3507];
    sp[3657] = -1 * sp[3549] + -1 * sp[3516];
    sp[3658] = -1 * sp[3550] + -1 * sp[3525];
    sp[3659] = -1 * sp[3551] + -1 * sp[3534];
    sp[3660] = sp[3627] + -1 * sp[3463];
    sp[3661] = sp[3628] + -1 * sp[3472];
    sp[3662] = sp[3629] + -1 * sp[3481];
    sp[3663] = -1 * sp[3555] + -1 * sp[3490];
    sp[3664] = -1 * sp[3556] + -1 * sp[3499];
    sp[3665] = -1 * sp[3557] + -1 * sp[3508];
    sp[3666] = -1 * sp[3558] + -1 * sp[3517];
    sp[3667] = -1 * sp[3559] + -1 * sp[3526];
    sp[3668] = -1 * sp[3560] + -1 * sp[3535];
    sp[3669] = sp[3630] + -1 * sp[3464];
    sp[3670] = sp[3631] + -1 * sp[3473];
    sp[3671] = sp[3632] + -1 * sp[3482];
    sp[3672] = -1 * sp[3564] + -1 * sp[3491];
    sp[3673] = -1 * sp[3565] + -1 * sp[3500];
    sp[3674] = -1 * sp[3566] + -1 * sp[3509];
    sp[3675] = -1 * sp[3567] + -1 * sp[3518];
    sp[3676] = -1 * sp[3568] + -1 * sp[3527];
    sp[3677] = -1 * sp[3569] + -1 * sp[3536];
    sp[3678] = -1 * sp[3570] + -1 * sp[3465];
    sp[3679] = -1 * sp[3571] + -1 * sp[3466];
    sp[3680] = -1 * sp[3572] + -1 * sp[3467];
    sp[3681] = -1 * sp[3573] + -1 * sp[3468];
    sp[3682] = -1 * sp[3574] + -1 * sp[3469];
    sp[3683] = -1 * sp[3575] + -1 * sp[3470];
    sp[3684] = -1 * sp[3576] + -1 * sp[3474];
    sp[3685] = -1 * sp[3577] + -1 * sp[3475];
    sp[3686] = -1 * sp[3578] + -1 * sp[3476];
    sp[3687] = -1 * sp[3579] + -1 * sp[3477];
    sp[3688] = -1 * sp[3580] + -1 * sp[3478];
    sp[3689] = -1 * sp[3581] + -1 * sp[3479];
    sp[3690] = -1 * sp[3582] + -1 * sp[3483];
    sp[3691] = -1 * sp[3583] + -1 * sp[3484];
    sp[3692] = -1 * sp[3584] + -1 * sp[3485];
    sp[3693] = -1 * sp[3585] + -1 * sp[3486];
    sp[3694] = -1 * sp[3586] + -1 * sp[3487];
    sp[3695] = -1 * sp[3587] + -1 * sp[3488];
    sp[3696] = sp[3633] + -1 * sp[3492];
    sp[3697] = sp[3634] + -1 * sp[3501];
    sp[3698] = sp[3635] + -1 * sp[3510];
    sp[3699] = -1 * sp[3591] + -1 * sp[3519];
    sp[3700] = -1 * sp[3592] + -1 * sp[3528];
    sp[3701] = -1 * sp[3593] + -1 * sp[3537];
    sp[3702] = sp[3636] + -1 * sp[3493];
    sp[3703] = sp[3637] + -1 * sp[3502];
    sp[3704] = sp[3638] + -1 * sp[3511];
    sp[3705] = -1 * sp[3597] + -1 * sp[3520];
    sp[3706] = -1 * sp[3598] + -1 * sp[3529];
    sp[3707] = -1 * sp[3599] + -1 * sp[3538];
    sp[3708] = sp[3639] + -1 * sp[3494];
    sp[3709] = sp[3640] + -1 * sp[3503];
    sp[3710] = sp[3641] + -1 * sp[3512];
    sp[3711] = -1 * sp[3603] + -1 * sp[3521];
    sp[3712] = -1 * sp[3604] + -1 * sp[3530];
    sp[3713] = -1 * sp[3605] + -1 * sp[3539];
    sp[3714] = -1 * sp[3606] + -1 * sp[3495];
    sp[3715] = -1 * sp[3607] + -1 * sp[3496];
    sp[3716] = -1 * sp[3608] + -1 * sp[3497];
    sp[3717] = -1 * sp[3609] + -1 * sp[3504];
    sp[3718] = -1 * sp[3610] + -1 * sp[3505];
    sp[3719] = -1 * sp[3611] + -1 * sp[3506];
    sp[3720] = -1 * sp[3612] + -1 * sp[3513];
    sp[3721] = -1 * sp[3613] + -1 * sp[3514];
    sp[3722] = -1 * sp[3614] + -1 * sp[3515];
    sp[3723] = sp[3642] + -1 * sp[3522];
    sp[3724] = sp[3643] + -1 * sp[3531];
    sp[3725] = sp[3644] + -1 * sp[3540];
    sp[3726] = sp[3645] + -1 * sp[3523];
    sp[3727] = sp[3646] + -1 * sp[3532];
    sp[3728] = sp[3647] + -1 * sp[3541];
    sp[3729] = sp[3648] + -1 * sp[3524];
    sp[3730] = sp[3649] + -1 * sp[3533];
    sp[3731] = sp[3650] + -1 * sp[3542];
    sp[3732] = sp[3651] / std::pow(sp[593], 0.3333333333333333);
    sp[3733] = sp[3652] / std::pow(sp[593], 0.3333333333333333);
    sp[3734] = sp[3653] / std::pow(sp[593], 0.3333333333333333);
    sp[3735] = sp[3654] / std::pow(sp[593], 0.3333333333333333);
    sp[3736] = sp[3655] / std::pow(sp[593], 0.3333333333333333);
    sp[3737] = sp[3656] / std::pow(sp[593], 0.3333333333333333);
    sp[3738] = sp[3657] / std::pow(sp[593], 0.3333333333333333);
    sp[3739] = sp[3658] / std::pow(sp[593], 0.3333333333333333);
    sp[3740] = sp[3659] / std::pow(sp[593], 0.3333333333333333);
    sp[3741] = sp[3660] / std::pow(sp[593], 0.3333333333333333);
    sp[3742] = sp[3661] / std::pow(sp[593], 0.3333333333333333);
    sp[3743] = sp[3662] / std::pow(sp[593], 0.3333333333333333);
    sp[3744] = sp[3663] / std::pow(sp[593], 0.3333333333333333);
    sp[3745] = sp[3664] / std::pow(sp[593], 0.3333333333333333);
    sp[3746] = sp[3665] / std::pow(sp[593], 0.3333333333333333);
    sp[3747] = sp[3666] / std::pow(sp[593], 0.3333333333333333);
    sp[3748] = sp[3667] / std::pow(sp[593], 0.3333333333333333);
    sp[3749] = sp[3668] / std::pow(sp[593], 0.3333333333333333);
    sp[3750] = sp[3669] / std::pow(sp[593], 0.3333333333333333);
    sp[3751] = sp[3670] / std::pow(sp[593], 0.3333333333333333);
    sp[3752] = sp[3671] / std::pow(sp[593], 0.3333333333333333);
    sp[3753] = sp[3672] / std::pow(sp[593], 0.3333333333333333);
    sp[3754] = sp[3673] / std::pow(sp[593], 0.3333333333333333);
    sp[3755] = sp[3674] / std::pow(sp[593], 0.3333333333333333);
    sp[3756] = sp[3675] / std::pow(sp[593], 0.3333333333333333);
    sp[3757] = sp[3676] / std::pow(sp[593], 0.3333333333333333);
    sp[3758] = sp[3677] / std::pow(sp[593], 0.3333333333333333);
    sp[3759] = sp[3678] / std::pow(sp[593], 0.3333333333333333);
    sp[3760] = sp[3679] / std::pow(sp[593], 0.3333333333333333);
    sp[3761] = sp[3680] / std::pow(sp[593], 0.3333333333333333);
    sp[3762] = sp[3681] / std::pow(sp[593], 0.3333333333333333);
    sp[3763] = sp[3682] / std::pow(sp[593], 0.3333333333333333);
    sp[3764] = sp[3683] / std::pow(sp[593], 0.3333333333333333);
    sp[3765] = sp[3684] / std::pow(sp[593], 0.3333333333333333);
    sp[3766] = sp[3685] / std::pow(sp[593], 0.3333333333333333);
    sp[3767] = sp[3686] / std::pow(sp[593], 0.3333333333333333);
    sp[3768] = sp[3687] / std::pow(sp[593], 0.3333333333333333);
    sp[3769] = sp[3688] / std::pow(sp[593], 0.3333333333333333);
    sp[3770] = sp[3689] / std::pow(sp[593], 0.3333333333333333);
    sp[3771] = sp[3690] / std::pow(sp[593], 0.3333333333333333);
    sp[3772] = sp[3691] / std::pow(sp[593], 0.3333333333333333);
    sp[3773] = sp[3692] / std::pow(sp[593], 0.3333333333333333);
    sp[3774] = sp[3693] / std::pow(sp[593], 0.3333333333333333);
    sp[3775] = sp[3694] / std::pow(sp[593], 0.3333333333333333);
    sp[3776] = sp[3695] / std::pow(sp[593], 0.3333333333333333);
    sp[3777] = sp[3696] / std::pow(sp[593], 0.3333333333333333);
    sp[3778] = sp[3697] / std::pow(sp[593], 0.3333333333333333);
    sp[3779] = sp[3698] / std::pow(sp[593], 0.3333333333333333);
    sp[3780] = sp[3699] / std::pow(sp[593], 0.3333333333333333);
    sp[3781] = sp[3700] / std::pow(sp[593], 0.3333333333333333);
    sp[3782] = sp[3701] / std::pow(sp[593], 0.3333333333333333);
    sp[3783] = sp[3702] / std::pow(sp[593], 0.3333333333333333);
    sp[3784] = sp[3703] / std::pow(sp[593], 0.3333333333333333);
    sp[3785] = sp[3704] / std::pow(sp[593], 0.3333333333333333);
    sp[3786] = sp[3705] / std::pow(sp[593], 0.3333333333333333);
    sp[3787] = sp[3706] / std::pow(sp[593], 0.3333333333333333);
    sp[3788] = sp[3707] / std::pow(sp[593], 0.3333333333333333);
    sp[3789] = sp[3708] / std::pow(sp[593], 0.3333333333333333);
    sp[3790] = sp[3709] / std::pow(sp[593], 0.3333333333333333);
    sp[3791] = sp[3710] / std::pow(sp[593], 0.3333333333333333);
    sp[3792] = sp[3711] / std::pow(sp[593], 0.3333333333333333);
    sp[3793] = sp[3712] / std::pow(sp[593], 0.3333333333333333);
    sp[3794] = sp[3713] / std::pow(sp[593], 0.3333333333333333);
    sp[3795] = sp[3714] / std::pow(sp[593], 0.3333333333333333);
    sp[3796] = sp[3715] / std::pow(sp[593], 0.3333333333333333);
    sp[3797] = sp[3716] / std::pow(sp[593], 0.3333333333333333);
    sp[3798] = sp[3717] / std::pow(sp[593], 0.3333333333333333);
    sp[3799] = sp[3718] / std::pow(sp[593], 0.3333333333333333);
    sp[3800] = sp[3719] / std::pow(sp[593], 0.3333333333333333);
    sp[3801] = sp[3720] / std::pow(sp[593], 0.3333333333333333);
    sp[3802] = sp[3721] / std::pow(sp[593], 0.3333333333333333);
    sp[3803] = sp[3722] / std::pow(sp[593], 0.3333333333333333);
    sp[3804] = sp[3723] / std::pow(sp[593], 0.3333333333333333);
    sp[3805] = sp[3724] / std::pow(sp[593], 0.3333333333333333);
    sp[3806] = sp[3725] / std::pow(sp[593], 0.3333333333333333);
    sp[3807] = sp[3726] / std::pow(sp[593], 0.3333333333333333);
    sp[3808] = sp[3727] / std::pow(sp[593], 0.3333333333333333);
    sp[3809] = sp[3728] / std::pow(sp[593], 0.3333333333333333);
    sp[3810] = sp[3729] / std::pow(sp[593], 0.3333333333333333);
    sp[3811] = sp[3730] / std::pow(sp[593], 0.3333333333333333);
    sp[3812] = sp[3731] / std::pow(sp[593], 0.3333333333333333);
    sp[3813] = sp[3732] * w[1][0];
    sp[3814] = sp[3733] * w[1][0];
    sp[3815] = sp[3734] * w[1][0];
    sp[3816] = sp[3735] * w[1][0];
    sp[3817] = sp[3736] * w[1][0];
    sp[3818] = sp[3737] * w[1][0];
    sp[3819] = sp[3738] * w[1][0];
    sp[3820] = sp[3739] * w[1][0];
    sp[3821] = sp[3740] * w[1][0];
    sp[3822] = sp[3741] * w[1][0];
    sp[3823] = sp[3742] * w[1][0];
    sp[3824] = sp[3743] * w[1][0];
    sp[3825] = sp[3744] * w[1][0];
    sp[3826] = sp[3745] * w[1][0];
    sp[3827] = sp[3746] * w[1][0];
    sp[3828] = sp[3747] * w[1][0];
    sp[3829] = sp[3748] * w[1][0];
    sp[3830] = sp[3749] * w[1][0];
    sp[3831] = sp[3750] * w[1][0];
    sp[3832] = sp[3751] * w[1][0];
    sp[3833] = sp[3752] * w[1][0];
    sp[3834] = sp[3753] * w[1][0];
    sp[3835] = sp[3754] * w[1][0];
    sp[3836] = sp[3755] * w[1][0];
    sp[3837] = sp[3756] * w[1][0];
    sp[3838] = sp[3757] * w[1][0];
    sp[3839] = sp[3758] * w[1][0];
    sp[3840] = sp[3759] * w[1][0];
    sp[3841] = sp[3760] * w[1][0];
    sp[3842] = sp[3761] * w[1][0];
    sp[3843] = sp[3762] * w[1][0];
    sp[3844] = sp[3763] * w[1][0];
    sp[3845] = sp[3764] * w[1][0];
    sp[3846] = sp[3765] * w[1][0];
    sp[3847] = sp[3766] * w[1][0];
    sp[3848] = sp[3767] * w[1][0];
    sp[3849] = sp[3768] * w[1][0];
    sp[3850] = sp[3769] * w[1][0];
    sp[3851] = sp[3770] * w[1][0];
    sp[3852] = sp[3771] * w[1][0];
    sp[3853] = sp[3772] * w[1][0];
    sp[3854] = sp[3773] * w[1][0];
    sp[3855] = sp[3774] * w[1][0];
    sp[3856] = sp[3775] * w[1][0];
    sp[3857] = sp[3776] * w[1][0];
    sp[3858] = sp[3777] * w[1][0];
    sp[3859] = sp[3778] * w[1][0];
    sp[3860] = sp[3779] * w[1][0];
    sp[3861] = sp[3780] * w[1][0];
    sp[3862] = sp[3781] * w[1][0];
    sp[3863] = sp[3782] * w[1][0];
    sp[3864] = sp[3783] * w[1][0];
    sp[3865] = sp[3784] * w[1][0];
    sp[3866] = sp[3785] * w[1][0];
    sp[3867] = sp[3786] * w[1][0];
    sp[3868] = sp[3787] * w[1][0];
    sp[3869] = sp[3788] * w[1][0];
    sp[3870] = sp[3789] * w[1][0];
    sp[3871] = sp[3790] * w[1][0];
    sp[3872] = sp[3791] * w[1][0];
    sp[3873] = sp[3792] * w[1][0];
    sp[3874] = sp[3793] * w[1][0];
    sp[3875] = sp[3794] * w[1][0];
    sp[3876] = sp[3795] * w[1][0];
    sp[3877] = sp[3796] * w[1][0];
    sp[3878] = sp[3797] * w[1][0];
    sp[3879] = sp[3798] * w[1][0];
    sp[3880] = sp[3799] * w[1][0];
    sp[3881] = sp[3800] * w[1][0];
    sp[3882] = sp[3801] * w[1][0];
    sp[3883] = sp[3802] * w[1][0];
    sp[3884] = sp[3803] * w[1][0];
    sp[3885] = sp[3804] * w[1][0];
    sp[3886] = sp[3805] * w[1][0];
    sp[3887] = sp[3806] * w[1][0];
    sp[3888] = sp[3807] * w[1][0];
    sp[3889] = sp[3808] * w[1][0];
    sp[3890] = sp[3809] * w[1][0];
    sp[3891] = sp[3810] * w[1][0];
    sp[3892] = sp[3811] * w[1][0];
    sp[3893] = sp[3812] * w[1][0];
    sp[3894] = sp[580] * (-1 + w[3][0]);
    sp[3895] = sp[581] * (-1 + w[3][0]);
    sp[3896] = sp[582] * (-1 + w[3][0]);
    sp[3897] = sp[583] * (-1 + w[3][0]);
    sp[3898] = sp[584] * (-1 + w[3][0]);
    sp[3899] = sp[585] * (-1 + w[3][0]);
    sp[3900] = sp[586] * (-1 + w[3][0]);
    sp[3901] = sp[587] * (-1 + w[3][0]);
    sp[3902] = sp[588] * (-1 + w[3][0]);
    sp[3903] = std::pow(sp[593], -1 + (-1 + w[3][0]));
    sp[3904] = sp[3894] * sp[3903];
    sp[3905] = sp[3895] * sp[3903];
    sp[3906] = sp[3896] * sp[3903];
    sp[3907] = sp[3897] * sp[3903];
    sp[3908] = sp[3898] * sp[3903];
    sp[3909] = sp[3899] * sp[3903];
    sp[3910] = sp[3900] * sp[3903];
    sp[3911] = sp[3901] * sp[3903];
    sp[3912] = sp[3902] * sp[3903];
    sp[3913] = sp[580] * w[3][0];
    sp[3914] = sp[581] * w[3][0];
    sp[3915] = sp[582] * w[3][0];
    sp[3916] = sp[583] * w[3][0];
    sp[3917] = sp[584] * w[3][0];
    sp[3918] = sp[585] * w[3][0];
    sp[3919] = sp[586] * w[3][0];
    sp[3920] = sp[587] * w[3][0];
    sp[3921] = sp[588] * w[3][0];
    sp[3922] = sp[3904] * sp[3913];
    sp[3923] = sp[3904] * sp[3914];
    sp[3924] = sp[3904] * sp[3915];
    sp[3925] = sp[3904] * sp[3916];
    sp[3926] = sp[3904] * sp[3917];
    sp[3927] = sp[3904] * sp[3918];
    sp[3928] = sp[3904] * sp[3919];
    sp[3929] = sp[3904] * sp[3920];
    sp[3930] = sp[3904] * sp[3921];
    sp[3931] = sp[3905] * sp[3913];
    sp[3932] = sp[3905] * sp[3914];
    sp[3933] = sp[3905] * sp[3915];
    sp[3934] = sp[3905] * sp[3916];
    sp[3935] = sp[3905] * sp[3917];
    sp[3936] = sp[3905] * sp[3918];
    sp[3937] = sp[3905] * sp[3919];
    sp[3938] = sp[3905] * sp[3920];
    sp[3939] = sp[3905] * sp[3921];
    sp[3940] = sp[3906] * sp[3913];
    sp[3941] = sp[3906] * sp[3914];
    sp[3942] = sp[3906] * sp[3915];
    sp[3943] = sp[3906] * sp[3916];
    sp[3944] = sp[3906] * sp[3917];
    sp[3945] = sp[3906] * sp[3918];
    sp[3946] = sp[3906] * sp[3919];
    sp[3947] = sp[3906] * sp[3920];
    sp[3948] = sp[3906] * sp[3921];
    sp[3949] = sp[3907] * sp[3913];
    sp[3950] = sp[3907] * sp[3914];
    sp[3951] = sp[3907] * sp[3915];
    sp[3952] = sp[3907] * sp[3916];
    sp[3953] = sp[3907] * sp[3917];
    sp[3954] = sp[3907] * sp[3918];
    sp[3955] = sp[3907] * sp[3919];
    sp[3956] = sp[3907] * sp[3920];
    sp[3957] = sp[3907] * sp[3921];
    sp[3958] = sp[3908] * sp[3913];
    sp[3959] = sp[3908] * sp[3914];
    sp[3960] = sp[3908] * sp[3915];
    sp[3961] = sp[3908] * sp[3916];
    sp[3962] = sp[3908] * sp[3917];
    sp[3963] = sp[3908] * sp[3918];
    sp[3964] = sp[3908] * sp[3919];
    sp[3965] = sp[3908] * sp[3920];
    sp[3966] = sp[3908] * sp[3921];
    sp[3967] = sp[3909] * sp[3913];
    sp[3968] = sp[3909] * sp[3914];
    sp[3969] = sp[3909] * sp[3915];
    sp[3970] = sp[3909] * sp[3916];
    sp[3971] = sp[3909] * sp[3917];
    sp[3972] = sp[3909] * sp[3918];
    sp[3973] = sp[3909] * sp[3919];
    sp[3974] = sp[3909] * sp[3920];
    sp[3975] = sp[3909] * sp[3921];
    sp[3976] = sp[3910] * sp[3913];
    sp[3977] = sp[3910] * sp[3914];
    sp[3978] = sp[3910] * sp[3915];
    sp[3979] = sp[3910] * sp[3916];
    sp[3980] = sp[3910] * sp[3917];
    sp[3981] = sp[3910] * sp[3918];
    sp[3982] = sp[3910] * sp[3919];
    sp[3983] = sp[3910] * sp[3920];
    sp[3984] = sp[3910] * sp[3921];
    sp[3985] = sp[3911] * sp[3913];
    sp[3986] = sp[3911] * sp[3914];
    sp[3987] = sp[3911] * sp[3915];
    sp[3988] = sp[3911] * sp[3916];
    sp[3989] = sp[3911] * sp[3917];
    sp[3990] = sp[3911] * sp[3918];
    sp[3991] = sp[3911] * sp[3919];
    sp[3992] = sp[3911] * sp[3920];
    sp[3993] = sp[3911] * sp[3921];
    sp[3994] = sp[3912] * sp[3913];
    sp[3995] = sp[3912] * sp[3914];
    sp[3996] = sp[3912] * sp[3915];
    sp[3997] = sp[3912] * sp[3916];
    sp[3998] = sp[3912] * sp[3917];
    sp[3999] = sp[3912] * sp[3918];
    sp[4000] = sp[3912] * sp[3919];
    sp[4001] = sp[3912] * sp[3920];
    sp[4002] = sp[3912] * sp[3921];
    sp[4003] = sp[3081] * w[3][0];
    sp[4004] = sp[3082] * w[3][0];
    sp[4005] = sp[3083] * w[3][0];
    sp[4006] = sp[3084] * w[3][0];
    sp[4007] = sp[3085] * w[3][0];
    sp[4008] = sp[3086] * w[3][0];
    sp[4009] = sp[3087] * w[3][0];
    sp[4010] = sp[3088] * w[3][0];
    sp[4011] = sp[3089] * w[3][0];
    sp[4012] = sp[3090] * w[3][0];
    sp[4013] = sp[3091] * w[3][0];
    sp[4014] = sp[3092] * w[3][0];
    sp[4015] = sp[3093] * w[3][0];
    sp[4016] = sp[3094] * w[3][0];
    sp[4017] = sp[3095] * w[3][0];
    sp[4018] = sp[3096] * w[3][0];
    sp[4019] = sp[3097] * w[3][0];
    sp[4020] = sp[3098] * w[3][0];
    sp[4021] = sp[3099] * w[3][0];
    sp[4022] = sp[3100] * w[3][0];
    sp[4023] = sp[3101] * w[3][0];
    sp[4024] = sp[3102] * w[3][0];
    sp[4025] = sp[3103] * w[3][0];
    sp[4026] = sp[3104] * w[3][0];
    sp[4027] = sp[3105] * w[3][0];
    sp[4028] = sp[3106] * w[3][0];
    sp[4029] = sp[3107] * w[3][0];
    sp[4030] = sp[3108] * w[3][0];
    sp[4031] = sp[3109] * w[3][0];
    sp[4032] = sp[3110] * w[3][0];
    sp[4033] = sp[3111] * w[3][0];
    sp[4034] = sp[3112] * w[3][0];
    sp[4035] = sp[3113] * w[3][0];
    sp[4036] = sp[3114] * w[3][0];
    sp[4037] = sp[3115] * w[3][0];
    sp[4038] = sp[3116] * w[3][0];
    sp[4039] = sp[3117] * w[3][0];
    sp[4040] = sp[3118] * w[3][0];
    sp[4041] = sp[3119] * w[3][0];
    sp[4042] = sp[3120] * w[3][0];
    sp[4043] = sp[3121] * w[3][0];
    sp[4044] = sp[3122] * w[3][0];
    sp[4045] = sp[3123] * w[3][0];
    sp[4046] = sp[3124] * w[3][0];
    sp[4047] = sp[3125] * w[3][0];
    sp[4048] = sp[3126] * w[3][0];
    sp[4049] = sp[3127] * w[3][0];
    sp[4050] = sp[3128] * w[3][0];
    sp[4051] = sp[3129] * w[3][0];
    sp[4052] = sp[3130] * w[3][0];
    sp[4053] = sp[3131] * w[3][0];
    sp[4054] = sp[3132] * w[3][0];
    sp[4055] = sp[3133] * w[3][0];
    sp[4056] = sp[3134] * w[3][0];
    sp[4057] = sp[3135] * w[3][0];
    sp[4058] = sp[3136] * w[3][0];
    sp[4059] = sp[3137] * w[3][0];
    sp[4060] = sp[3138] * w[3][0];
    sp[4061] = sp[3139] * w[3][0];
    sp[4062] = sp[3140] * w[3][0];
    sp[4063] = sp[3141] * w[3][0];
    sp[4064] = sp[3142] * w[3][0];
    sp[4065] = sp[3143] * w[3][0];
    sp[4066] = sp[3144] * w[3][0];
    sp[4067] = sp[3145] * w[3][0];
    sp[4068] = sp[3146] * w[3][0];
    sp[4069] = sp[3147] * w[3][0];
    sp[4070] = sp[3148] * w[3][0];
    sp[4071] = sp[3149] * w[3][0];
    sp[4072] = sp[3150] * w[3][0];
    sp[4073] = sp[3151] * w[3][0];
    sp[4074] = sp[3152] * w[3][0];
    sp[4075] = sp[3153] * w[3][0];
    sp[4076] = sp[3154] * w[3][0];
    sp[4077] = sp[3155] * w[3][0];
    sp[4078] = sp[3156] * w[3][0];
    sp[4079] = sp[3157] * w[3][0];
    sp[4080] = sp[3158] * w[3][0];
    sp[4081] = sp[3159] * w[3][0];
    sp[4082] = sp[3160] * w[3][0];
    sp[4083] = sp[3161] * w[3][0];
    sp[4084] = std::pow(sp[593], -1 + w[3][0]);
    sp[4085] = sp[4003] * sp[4084];
    sp[4086] = sp[4004] * sp[4084];
    sp[4087] = sp[4005] * sp[4084];
    sp[4088] = sp[4006] * sp[4084];
    sp[4089] = sp[4007] * sp[4084];
    sp[4090] = sp[4008] * sp[4084];
    sp[4091] = sp[4009] * sp[4084];
    sp[4092] = sp[4010] * sp[4084];
    sp[4093] = sp[4011] * sp[4084];
    sp[4094] = sp[4012] * sp[4084];
    sp[4095] = sp[4013] * sp[4084];
    sp[4096] = sp[4014] * sp[4084];
    sp[4097] = sp[4015] * sp[4084];
    sp[4098] = sp[4016] * sp[4084];
    sp[4099] = sp[4017] * sp[4084];
    sp[4100] = sp[4018] * sp[4084];
    sp[4101] = sp[4019] * sp[4084];
    sp[4102] = sp[4020] * sp[4084];
    sp[4103] = sp[4021] * sp[4084];
    sp[4104] = sp[4022] * sp[4084];
    sp[4105] = sp[4023] * sp[4084];
    sp[4106] = sp[4024] * sp[4084];
    sp[4107] = sp[4025] * sp[4084];
    sp[4108] = sp[4026] * sp[4084];
    sp[4109] = sp[4027] * sp[4084];
    sp[4110] = sp[4028] * sp[4084];
    sp[4111] = sp[4029] * sp[4084];
    sp[4112] = sp[4030] * sp[4084];
    sp[4113] = sp[4031] * sp[4084];
    sp[4114] = sp[4032] * sp[4084];
    sp[4115] = sp[4033] * sp[4084];
    sp[4116] = sp[4034] * sp[4084];
    sp[4117] = sp[4035] * sp[4084];
    sp[4118] = sp[4036] * sp[4084];
    sp[4119] = sp[4037] * sp[4084];
    sp[4120] = sp[4038] * sp[4084];
    sp[4121] = sp[4039] * sp[4084];
    sp[4122] = sp[4040] * sp[4084];
    sp[4123] = sp[4041] * sp[4084];
    sp[4124] = sp[4042] * sp[4084];
    sp[4125] = sp[4043] * sp[4084];
    sp[4126] = sp[4044] * sp[4084];
    sp[4127] = sp[4045] * sp[4084];
    sp[4128] = sp[4046] * sp[4084];
    sp[4129] = sp[4047] * sp[4084];
    sp[4130] = sp[4048] * sp[4084];
    sp[4131] = sp[4049] * sp[4084];
    sp[4132] = sp[4050] * sp[4084];
    sp[4133] = sp[4051] * sp[4084];
    sp[4134] = sp[4052] * sp[4084];
    sp[4135] = sp[4053] * sp[4084];
    sp[4136] = sp[4054] * sp[4084];
    sp[4137] = sp[4055] * sp[4084];
    sp[4138] = sp[4056] * sp[4084];
    sp[4139] = sp[4057] * sp[4084];
    sp[4140] = sp[4058] * sp[4084];
    sp[4141] = sp[4059] * sp[4084];
    sp[4142] = sp[4060] * sp[4084];
    sp[4143] = sp[4061] * sp[4084];
    sp[4144] = sp[4062] * sp[4084];
    sp[4145] = sp[4063] * sp[4084];
    sp[4146] = sp[4064] * sp[4084];
    sp[4147] = sp[4065] * sp[4084];
    sp[4148] = sp[4066] * sp[4084];
    sp[4149] = sp[4067] * sp[4084];
    sp[4150] = sp[4068] * sp[4084];
    sp[4151] = sp[4069] * sp[4084];
    sp[4152] = sp[4070] * sp[4084];
    sp[4153] = sp[4071] * sp[4084];
    sp[4154] = sp[4072] * sp[4084];
    sp[4155] = sp[4073] * sp[4084];
    sp[4156] = sp[4074] * sp[4084];
    sp[4157] = sp[4075] * sp[4084];
    sp[4158] = sp[4076] * sp[4084];
    sp[4159] = sp[4077] * sp[4084];
    sp[4160] = sp[4078] * sp[4084];
    sp[4161] = sp[4079] * sp[4084];
    sp[4162] = sp[4080] * sp[4084];
    sp[4163] = sp[4081] * sp[4084];
    sp[4164] = sp[4082] * sp[4084];
    sp[4165] = sp[4083] * sp[4084];
    sp[4166] = sp[3922] + sp[4085];
    sp[4167] = sp[3931] + sp[4086];
    sp[4168] = sp[3940] + sp[4087];
    sp[4169] = sp[3949] + sp[4088];
    sp[4170] = sp[3958] + sp[4089];
    sp[4171] = sp[3967] + sp[4090];
    sp[4172] = sp[3976] + sp[4091];
    sp[4173] = sp[3985] + sp[4092];
    sp[4174] = sp[3994] + sp[4093];
    sp[4175] = sp[3923] + sp[4094];
    sp[4176] = sp[3932] + sp[4095];
    sp[4177] = sp[3941] + sp[4096];
    sp[4178] = sp[3950] + sp[4097];
    sp[4179] = sp[3959] + sp[4098];
    sp[4180] = sp[3968] + sp[4099];
    sp[4181] = sp[3977] + sp[4100];
    sp[4182] = sp[3986] + sp[4101];
    sp[4183] = sp[3995] + sp[4102];
    sp[4184] = sp[3924] + sp[4103];
    sp[4185] = sp[3933] + sp[4104];
    sp[4186] = sp[3942] + sp[4105];
    sp[4187] = sp[3951] + sp[4106];
    sp[4188] = sp[3960] + sp[4107];
    sp[4189] = sp[3969] + sp[4108];
    sp[4190] = sp[3978] + sp[4109];
    sp[4191] = sp[3987] + sp[4110];
    sp[4192] = sp[3996] + sp[4111];
    sp[4193] = sp[3925] + sp[4112];
    sp[4194] = sp[3926] + sp[4113];
    sp[4195] = sp[3927] + sp[4114];
    sp[4196] = sp[3928] + sp[4115];
    sp[4197] = sp[3929] + sp[4116];
    sp[4198] = sp[3930] + sp[4117];
    sp[4199] = sp[3934] + sp[4118];
    sp[4200] = sp[3935] + sp[4119];
    sp[4201] = sp[3936] + sp[4120];
    sp[4202] = sp[3937] + sp[4121];
    sp[4203] = sp[3938] + sp[4122];
    sp[4204] = sp[3939] + sp[4123];
    sp[4205] = sp[3943] + sp[4124];
    sp[4206] = sp[3944] + sp[4125];
    sp[4207] = sp[3945] + sp[4126];
    sp[4208] = sp[3946] + sp[4127];
    sp[4209] = sp[3947] + sp[4128];
    sp[4210] = sp[3948] + sp[4129];
    sp[4211] = sp[3952] + sp[4130];
    sp[4212] = sp[3961] + sp[4131];
    sp[4213] = sp[3970] + sp[4132];
    sp[4214] = sp[3979] + sp[4133];
    sp[4215] = sp[3988] + sp[4134];
    sp[4216] = sp[3997] + sp[4135];
    sp[4217] = sp[3953] + sp[4136];
    sp[4218] = sp[3962] + sp[4137];
    sp[4219] = sp[3971] + sp[4138];
    sp[4220] = sp[3980] + sp[4139];
    sp[4221] = sp[3989] + sp[4140];
    sp[4222] = sp[3998] + sp[4141];
    sp[4223] = sp[3954] + sp[4142];
    sp[4224] = sp[3963] + sp[4143];
    sp[4225] = sp[3972] + sp[4144];
    sp[4226] = sp[3981] + sp[4145];
    sp[4227] = sp[3990] + sp[4146];
    sp[4228] = sp[3999] + sp[4147];
    sp[4229] = sp[3955] + sp[4148];
    sp[4230] = sp[3956] + sp[4149];
    sp[4231] = sp[3957] + sp[4150];
    sp[4232] = sp[3964] + sp[4151];
    sp[4233] = sp[3965] + sp[4152];
    sp[4234] = sp[3966] + sp[4153];
    sp[4235] = sp[3973] + sp[4154];
    sp[4236] = sp[3974] + sp[4155];
    sp[4237] = sp[3975] + sp[4156];
    sp[4238] = sp[3982] + sp[4157];
    sp[4239] = sp[3991] + sp[4158];
    sp[4240] = sp[4000] + sp[4159];
    sp[4241] = sp[3983] + sp[4160];
    sp[4242] = sp[3992] + sp[4161];
    sp[4243] = sp[4001] + sp[4162];
    sp[4244] = sp[3984] + sp[4163];
    sp[4245] = sp[3993] + sp[4164];
    sp[4246] = sp[4002] + sp[4165];
    sp[4247] = std::pow(sp[593], w[3][0]);
    sp[4248] = sp[4166] * (1.0 / sp[4247]);
    sp[4249] = sp[4167] * (1.0 / sp[4247]);
    sp[4250] = sp[4168] * (1.0 / sp[4247]);
    sp[4251] = sp[4169] * (1.0 / sp[4247]);
    sp[4252] = sp[4170] * (1.0 / sp[4247]);
    sp[4253] = sp[4171] * (1.0 / sp[4247]);
    sp[4254] = sp[4172] * (1.0 / sp[4247]);
    sp[4255] = sp[4173] * (1.0 / sp[4247]);
    sp[4256] = sp[4174] * (1.0 / sp[4247]);
    sp[4257] = sp[4175] * (1.0 / sp[4247]);
    sp[4258] = sp[4176] * (1.0 / sp[4247]);
    sp[4259] = sp[4177] * (1.0 / sp[4247]);
    sp[4260] = sp[4178] * (1.0 / sp[4247]);
    sp[4261] = sp[4179] * (1.0 / sp[4247]);
    sp[4262] = sp[4180] * (1.0 / sp[4247]);
    sp[4263] = sp[4181] * (1.0 / sp[4247]);
    sp[4264] = sp[4182] * (1.0 / sp[4247]);
    sp[4265] = sp[4183] * (1.0 / sp[4247]);
    sp[4266] = sp[4184] * (1.0 / sp[4247]);
    sp[4267] = sp[4185] * (1.0 / sp[4247]);
    sp[4268] = sp[4186] * (1.0 / sp[4247]);
    sp[4269] = sp[4187] * (1.0 / sp[4247]);
    sp[4270] = sp[4188] * (1.0 / sp[4247]);
    sp[4271] = sp[4189] * (1.0 / sp[4247]);
    sp[4272] = sp[4190] * (1.0 / sp[4247]);
    sp[4273] = sp[4191] * (1.0 / sp[4247]);
    sp[4274] = sp[4192] * (1.0 / sp[4247]);
    sp[4275] = sp[4193] * (1.0 / sp[4247]);
    sp[4276] = sp[4194] * (1.0 / sp[4247]);
    sp[4277] = sp[4195] * (1.0 / sp[4247]);
    sp[4278] = sp[4196] * (1.0 / sp[4247]);
    sp[4279] = sp[4197] * (1.0 / sp[4247]);
    sp[4280] = sp[4198] * (1.0 / sp[4247]);
    sp[4281] = sp[4199] * (1.0 / sp[4247]);
    sp[4282] = sp[4200] * (1.0 / sp[4247]);
    sp[4283] = sp[4201] * (1.0 / sp[4247]);
    sp[4284] = sp[4202] * (1.0 / sp[4247]);
    sp[4285] = sp[4203] * (1.0 / sp[4247]);
    sp[4286] = sp[4204] * (1.0 / sp[4247]);
    sp[4287] = sp[4205] * (1.0 / sp[4247]);
    sp[4288] = sp[4206] * (1.0 / sp[4247]);
    sp[4289] = sp[4207] * (1.0 / sp[4247]);
    sp[4290] = sp[4208] * (1.0 / sp[4247]);
    sp[4291] = sp[4209] * (1.0 / sp[4247]);
    sp[4292] = sp[4210] * (1.0 / sp[4247]);
    sp[4293] = sp[4211] * (1.0 / sp[4247]);
    sp[4294] = sp[4212] * (1.0 / sp[4247]);
    sp[4295] = sp[4213] * (1.0 / sp[4247]);
    sp[4296] = sp[4214] * (1.0 / sp[4247]);
    sp[4297] = sp[4215] * (1.0 / sp[4247]);
    sp[4298] = sp[4216] * (1.0 / sp[4247]);
    sp[4299] = sp[4217] * (1.0 / sp[4247]);
    sp[4300] = sp[4218] * (1.0 / sp[4247]);
    sp[4301] = sp[4219] * (1.0 / sp[4247]);
    sp[4302] = sp[4220] * (1.0 / sp[4247]);
    sp[4303] = sp[4221] * (1.0 / sp[4247]);
    sp[4304] = sp[4222] * (1.0 / sp[4247]);
    sp[4305] = sp[4223] * (1.0 / sp[4247]);
    sp[4306] = sp[4224] * (1.0 / sp[4247]);
    sp[4307] = sp[4225] * (1.0 / sp[4247]);
    sp[4308] = sp[4226] * (1.0 / sp[4247]);
    sp[4309] = sp[4227] * (1.0 / sp[4247]);
    sp[4310] = sp[4228] * (1.0 / sp[4247]);
    sp[4311] = sp[4229] * (1.0 / sp[4247]);
    sp[4312] = sp[4230] * (1.0 / sp[4247]);
    sp[4313] = sp[4231] * (1.0 / sp[4247]);
    sp[4314] = sp[4232] * (1.0 / sp[4247]);
    sp[4315] = sp[4233] * (1.0 / sp[4247]);
    sp[4316] = sp[4234] * (1.0 / sp[4247]);
    sp[4317] = sp[4235] * (1.0 / sp[4247]);
    sp[4318] = sp[4236] * (1.0 / sp[4247]);
    sp[4319] = sp[4237] * (1.0 / sp[4247]);
    sp[4320] = sp[4238] * (1.0 / sp[4247]);
    sp[4321] = sp[4239] * (1.0 / sp[4247]);
    sp[4322] = sp[4240] * (1.0 / sp[4247]);
    sp[4323] = sp[4241] * (1.0 / sp[4247]);
    sp[4324] = sp[4242] * (1.0 / sp[4247]);
    sp[4325] = sp[4243] * (1.0 / sp[4247]);
    sp[4326] = sp[4244] * (1.0 / sp[4247]);
    sp[4327] = sp[4245] * (1.0 / sp[4247]);
    sp[4328] = sp[4246] * (1.0 / sp[4247]);
    sp[4329] = sp[3913] * sp[4084];
    sp[4330] = sp[3914] * sp[4084];
    sp[4331] = sp[3915] * sp[4084];
    sp[4332] = sp[3916] * sp[4084];
    sp[4333] = sp[3917] * sp[4084];
    sp[4334] = sp[3918] * sp[4084];
    sp[4335] = sp[3919] * sp[4084];
    sp[4336] = sp[3920] * sp[4084];
    sp[4337] = sp[3921] * sp[4084];
    sp[4338] = sp[4329] * (1.0 / sp[4247]);
    sp[4339] = sp[4330] * (1.0 / sp[4247]);
    sp[4340] = sp[4331] * (1.0 / sp[4247]);
    sp[4341] = sp[4332] * (1.0 / sp[4247]);
    sp[4342] = sp[4333] * (1.0 / sp[4247]);
    sp[4343] = sp[4334] * (1.0 / sp[4247]);
    sp[4344] = sp[4335] * (1.0 / sp[4247]);
    sp[4345] = sp[4336] * (1.0 / sp[4247]);
    sp[4346] = sp[4337] * (1.0 / sp[4247]);
    sp[4347] = -1 * sp[4338] / sp[4247];
    sp[4348] = -1 * sp[4339] / sp[4247];
    sp[4349] = -1 * sp[4340] / sp[4247];
    sp[4350] = -1 * sp[4341] / sp[4247];
    sp[4351] = -1 * sp[4342] / sp[4247];
    sp[4352] = -1 * sp[4343] / sp[4247];
    sp[4353] = -1 * sp[4344] / sp[4247];
    sp[4354] = -1 * sp[4345] / sp[4247];
    sp[4355] = -1 * sp[4346] / sp[4247];
    sp[4356] = sp[4329] * sp[4347];
    sp[4357] = sp[4329] * sp[4348];
    sp[4358] = sp[4329] * sp[4349];
    sp[4359] = sp[4329] * sp[4350];
    sp[4360] = sp[4329] * sp[4351];
    sp[4361] = sp[4329] * sp[4352];
    sp[4362] = sp[4329] * sp[4353];
    sp[4363] = sp[4329] * sp[4354];
    sp[4364] = sp[4329] * sp[4355];
    sp[4365] = sp[4330] * sp[4347];
    sp[4366] = sp[4330] * sp[4348];
    sp[4367] = sp[4330] * sp[4349];
    sp[4368] = sp[4330] * sp[4350];
    sp[4369] = sp[4330] * sp[4351];
    sp[4370] = sp[4330] * sp[4352];
    sp[4371] = sp[4330] * sp[4353];
    sp[4372] = sp[4330] * sp[4354];
    sp[4373] = sp[4330] * sp[4355];
    sp[4374] = sp[4331] * sp[4347];
    sp[4375] = sp[4331] * sp[4348];
    sp[4376] = sp[4331] * sp[4349];
    sp[4377] = sp[4331] * sp[4350];
    sp[4378] = sp[4331] * sp[4351];
    sp[4379] = sp[4331] * sp[4352];
    sp[4380] = sp[4331] * sp[4353];
    sp[4381] = sp[4331] * sp[4354];
    sp[4382] = sp[4331] * sp[4355];
    sp[4383] = sp[4332] * sp[4347];
    sp[4384] = sp[4332] * sp[4348];
    sp[4385] = sp[4332] * sp[4349];
    sp[4386] = sp[4332] * sp[4350];
    sp[4387] = sp[4332] * sp[4351];
    sp[4388] = sp[4332] * sp[4352];
    sp[4389] = sp[4332] * sp[4353];
    sp[4390] = sp[4332] * sp[4354];
    sp[4391] = sp[4332] * sp[4355];
    sp[4392] = sp[4333] * sp[4347];
    sp[4393] = sp[4333] * sp[4348];
    sp[4394] = sp[4333] * sp[4349];
    sp[4395] = sp[4333] * sp[4350];
    sp[4396] = sp[4333] * sp[4351];
    sp[4397] = sp[4333] * sp[4352];
    sp[4398] = sp[4333] * sp[4353];
    sp[4399] = sp[4333] * sp[4354];
    sp[4400] = sp[4333] * sp[4355];
    sp[4401] = sp[4334] * sp[4347];
    sp[4402] = sp[4334] * sp[4348];
    sp[4403] = sp[4334] * sp[4349];
    sp[4404] = sp[4334] * sp[4350];
    sp[4405] = sp[4334] * sp[4351];
    sp[4406] = sp[4334] * sp[4352];
    sp[4407] = sp[4334] * sp[4353];
    sp[4408] = sp[4334] * sp[4354];
    sp[4409] = sp[4334] * sp[4355];
    sp[4410] = sp[4335] * sp[4347];
    sp[4411] = sp[4335] * sp[4348];
    sp[4412] = sp[4335] * sp[4349];
    sp[4413] = sp[4335] * sp[4350];
    sp[4414] = sp[4335] * sp[4351];
    sp[4415] = sp[4335] * sp[4352];
    sp[4416] = sp[4335] * sp[4353];
    sp[4417] = sp[4335] * sp[4354];
    sp[4418] = sp[4335] * sp[4355];
    sp[4419] = sp[4336] * sp[4347];
    sp[4420] = sp[4336] * sp[4348];
    sp[4421] = sp[4336] * sp[4349];
    sp[4422] = sp[4336] * sp[4350];
    sp[4423] = sp[4336] * sp[4351];
    sp[4424] = sp[4336] * sp[4352];
    sp[4425] = sp[4336] * sp[4353];
    sp[4426] = sp[4336] * sp[4354];
    sp[4427] = sp[4336] * sp[4355];
    sp[4428] = sp[4337] * sp[4347];
    sp[4429] = sp[4337] * sp[4348];
    sp[4430] = sp[4337] * sp[4349];
    sp[4431] = sp[4337] * sp[4350];
    sp[4432] = sp[4337] * sp[4351];
    sp[4433] = sp[4337] * sp[4352];
    sp[4434] = sp[4337] * sp[4353];
    sp[4435] = sp[4337] * sp[4354];
    sp[4436] = sp[4337] * sp[4355];
    sp[4437] = sp[4248] + sp[4356];
    sp[4438] = sp[4249] + sp[4357];
    sp[4439] = sp[4250] + sp[4358];
    sp[4440] = sp[4251] + sp[4359];
    sp[4441] = sp[4252] + sp[4360];
    sp[4442] = sp[4253] + sp[4361];
    sp[4443] = sp[4254] + sp[4362];
    sp[4444] = sp[4255] + sp[4363];
    sp[4445] = sp[4256] + sp[4364];
    sp[4446] = sp[4257] + sp[4365];
    sp[4447] = sp[4258] + sp[4366];
    sp[4448] = sp[4259] + sp[4367];
    sp[4449] = sp[4260] + sp[4368];
    sp[4450] = sp[4261] + sp[4369];
    sp[4451] = sp[4262] + sp[4370];
    sp[4452] = sp[4263] + sp[4371];
    sp[4453] = sp[4264] + sp[4372];
    sp[4454] = sp[4265] + sp[4373];
    sp[4455] = sp[4266] + sp[4374];
    sp[4456] = sp[4267] + sp[4375];
    sp[4457] = sp[4268] + sp[4376];
    sp[4458] = sp[4269] + sp[4377];
    sp[4459] = sp[4270] + sp[4378];
    sp[4460] = sp[4271] + sp[4379];
    sp[4461] = sp[4272] + sp[4380];
    sp[4462] = sp[4273] + sp[4381];
    sp[4463] = sp[4274] + sp[4382];
    sp[4464] = sp[4275] + sp[4383];
    sp[4465] = sp[4276] + sp[4392];
    sp[4466] = sp[4277] + sp[4401];
    sp[4467] = sp[4278] + sp[4410];
    sp[4468] = sp[4279] + sp[4419];
    sp[4469] = sp[4280] + sp[4428];
    sp[4470] = sp[4281] + sp[4384];
    sp[4471] = sp[4282] + sp[4393];
    sp[4472] = sp[4283] + sp[4402];
    sp[4473] = sp[4284] + sp[4411];
    sp[4474] = sp[4285] + sp[4420];
    sp[4475] = sp[4286] + sp[4429];
    sp[4476] = sp[4287] + sp[4385];
    sp[4477] = sp[4288] + sp[4394];
    sp[4478] = sp[4289] + sp[4403];
    sp[4479] = sp[4290] + sp[4412];
    sp[4480] = sp[4291] + sp[4421];
    sp[4481] = sp[4292] + sp[4430];
    sp[4482] = sp[4293] + sp[4386];
    sp[4483] = sp[4294] + sp[4387];
    sp[4484] = sp[4295] + sp[4388];
    sp[4485] = sp[4296] + sp[4389];
    sp[4486] = sp[4297] + sp[4390];
    sp[4487] = sp[4298] + sp[4391];
    sp[4488] = sp[4299] + sp[4395];
    sp[4489] = sp[4300] + sp[4396];
    sp[4490] = sp[4301] + sp[4397];
    sp[4491] = sp[4302] + sp[4398];
    sp[4492] = sp[4303] + sp[4399];
    sp[4493] = sp[4304] + sp[4400];
    sp[4494] = sp[4305] + sp[4404];
    sp[4495] = sp[4306] + sp[4405];
    sp[4496] = sp[4307] + sp[4406];
    sp[4497] = sp[4308] + sp[4407];
    sp[4498] = sp[4309] + sp[4408];
    sp[4499] = sp[4310] + sp[4409];
    sp[4500] = sp[4311] + sp[4413];
    sp[4501] = sp[4312] + sp[4422];
    sp[4502] = sp[4313] + sp[4431];
    sp[4503] = sp[4314] + sp[4414];
    sp[4504] = sp[4315] + sp[4423];
    sp[4505] = sp[4316] + sp[4432];
    sp[4506] = sp[4317] + sp[4415];
    sp[4507] = sp[4318] + sp[4424];
    sp[4508] = sp[4319] + sp[4433];
    sp[4509] = sp[4320] + sp[4416];
    sp[4510] = sp[4321] + sp[4417];
    sp[4511] = sp[4322] + sp[4418];
    sp[4512] = sp[4323] + sp[4425];
    sp[4513] = sp[4324] + sp[4426];
    sp[4514] = sp[4325] + sp[4427];
    sp[4515] = sp[4326] + sp[4434];
    sp[4516] = sp[4327] + sp[4435];
    sp[4517] = sp[4328] + sp[4436];
    sp[4518] = -1 * sp[4437] + -1 * sp[4356];
    sp[4519] = -1 * sp[4438] + -1 * sp[4365];
    sp[4520] = -1 * sp[4439] + -1 * sp[4374];
    sp[4521] = -1 * sp[4440] + -1 * sp[4383];
    sp[4522] = -1 * sp[4441] + -1 * sp[4392];
    sp[4523] = -1 * sp[4442] + -1 * sp[4401];
    sp[4524] = -1 * sp[4443] + -1 * sp[4410];
    sp[4525] = -1 * sp[4444] + -1 * sp[4419];
    sp[4526] = -1 * sp[4445] + -1 * sp[4428];
    sp[4527] = -1 * sp[4446] + -1 * sp[4357];
    sp[4528] = -1 * sp[4447] + -1 * sp[4366];
    sp[4529] = -1 * sp[4448] + -1 * sp[4375];
    sp[4530] = -1 * sp[4449] + -1 * sp[4384];
    sp[4531] = -1 * sp[4450] + -1 * sp[4393];
    sp[4532] = -1 * sp[4451] + -1 * sp[4402];
    sp[4533] = -1 * sp[4452] + -1 * sp[4411];
    sp[4534] = -1 * sp[4453] + -1 * sp[4420];
    sp[4535] = -1 * sp[4454] + -1 * sp[4429];
    sp[4536] = -1 * sp[4455] + -1 * sp[4358];
    sp[4537] = -1 * sp[4456] + -1 * sp[4367];
    sp[4538] = -1 * sp[4457] + -1 * sp[4376];
    sp[4539] = -1 * sp[4458] + -1 * sp[4385];
    sp[4540] = -1 * sp[4459] + -1 * sp[4394];
    sp[4541] = -1 * sp[4460] + -1 * sp[4403];
    sp[4542] = -1 * sp[4461] + -1 * sp[4412];
    sp[4543] = -1 * sp[4462] + -1 * sp[4421];
    sp[4544] = -1 * sp[4463] + -1 * sp[4430];
    sp[4545] = -1 * sp[4464] + -1 * sp[4359];
    sp[4546] = -1 * sp[4465] + -1 * sp[4360];
    sp[4547] = -1 * sp[4466] + -1 * sp[4361];
    sp[4548] = -1 * sp[4467] + -1 * sp[4362];
    sp[4549] = -1 * sp[4468] + -1 * sp[4363];
    sp[4550] = -1 * sp[4469] + -1 * sp[4364];
    sp[4551] = -1 * sp[4470] + -1 * sp[4368];
    sp[4552] = -1 * sp[4471] + -1 * sp[4369];
    sp[4553] = -1 * sp[4472] + -1 * sp[4370];
    sp[4554] = -1 * sp[4473] + -1 * sp[4371];
    sp[4555] = -1 * sp[4474] + -1 * sp[4372];
    sp[4556] = -1 * sp[4475] + -1 * sp[4373];
    sp[4557] = -1 * sp[4476] + -1 * sp[4377];
    sp[4558] = -1 * sp[4477] + -1 * sp[4378];
    sp[4559] = -1 * sp[4478] + -1 * sp[4379];
    sp[4560] = -1 * sp[4479] + -1 * sp[4380];
    sp[4561] = -1 * sp[4480] + -1 * sp[4381];
    sp[4562] = -1 * sp[4481] + -1 * sp[4382];
    sp[4563] = -1 * sp[4482] + -1 * sp[4386];
    sp[4564] = -1 * sp[4483] + -1 * sp[4395];
    sp[4565] = -1 * sp[4484] + -1 * sp[4404];
    sp[4566] = -1 * sp[4485] + -1 * sp[4413];
    sp[4567] = -1 * sp[4486] + -1 * sp[4422];
    sp[4568] = -1 * sp[4487] + -1 * sp[4431];
    sp[4569] = -1 * sp[4488] + -1 * sp[4387];
    sp[4570] = -1 * sp[4489] + -1 * sp[4396];
    sp[4571] = -1 * sp[4490] + -1 * sp[4405];
    sp[4572] = -1 * sp[4491] + -1 * sp[4414];
    sp[4573] = -1 * sp[4492] + -1 * sp[4423];
    sp[4574] = -1 * sp[4493] + -1 * sp[4432];
    sp[4575] = -1 * sp[4494] + -1 * sp[4388];
    sp[4576] = -1 * sp[4495] + -1 * sp[4397];
    sp[4577] = -1 * sp[4496] + -1 * sp[4406];
    sp[4578] = -1 * sp[4497] + -1 * sp[4415];
    sp[4579] = -1 * sp[4498] + -1 * sp[4424];
    sp[4580] = -1 * sp[4499] + -1 * sp[4433];
    sp[4581] = -1 * sp[4500] + -1 * sp[4389];
    sp[4582] = -1 * sp[4501] + -1 * sp[4390];
    sp[4583] = -1 * sp[4502] + -1 * sp[4391];
    sp[4584] = -1 * sp[4503] + -1 * sp[4398];
    sp[4585] = -1 * sp[4504] + -1 * sp[4399];
    sp[4586] = -1 * sp[4505] + -1 * sp[4400];
    sp[4587] = -1 * sp[4506] + -1 * sp[4407];
    sp[4588] = -1 * sp[4507] + -1 * sp[4408];
    sp[4589] = -1 * sp[4508] + -1 * sp[4409];
    sp[4590] = -1 * sp[4509] + -1 * sp[4416];
    sp[4591] = -1 * sp[4510] + -1 * sp[4425];
    sp[4592] = -1 * sp[4511] + -1 * sp[4434];
    sp[4593] = -1 * sp[4512] + -1 * sp[4417];
    sp[4594] = -1 * sp[4513] + -1 * sp[4426];
    sp[4595] = -1 * sp[4514] + -1 * sp[4435];
    sp[4596] = -1 * sp[4515] + -1 * sp[4418];
    sp[4597] = -1 * sp[4516] + -1 * sp[4427];
    sp[4598] = -1 * sp[4517] + -1 * sp[4436];
    sp[4599] = sp[4518] / sp[4247];
    sp[4600] = sp[4519] / sp[4247];
    sp[4601] = sp[4520] / sp[4247];
    sp[4602] = sp[4521] / sp[4247];
    sp[4603] = sp[4522] / sp[4247];
    sp[4604] = sp[4523] / sp[4247];
    sp[4605] = sp[4524] / sp[4247];
    sp[4606] = sp[4525] / sp[4247];
    sp[4607] = sp[4526] / sp[4247];
    sp[4608] = sp[4527] / sp[4247];
    sp[4609] = sp[4528] / sp[4247];
    sp[4610] = sp[4529] / sp[4247];
    sp[4611] = sp[4530] / sp[4247];
    sp[4612] = sp[4531] / sp[4247];
    sp[4613] = sp[4532] / sp[4247];
    sp[4614] = sp[4533] / sp[4247];
    sp[4615] = sp[4534] / sp[4247];
    sp[4616] = sp[4535] / sp[4247];
    sp[4617] = sp[4536] / sp[4247];
    sp[4618] = sp[4537] / sp[4247];
    sp[4619] = sp[4538] / sp[4247];
    sp[4620] = sp[4539] / sp[4247];
    sp[4621] = sp[4540] / sp[4247];
    sp[4622] = sp[4541] / sp[4247];
    sp[4623] = sp[4542] / sp[4247];
    sp[4624] = sp[4543] / sp[4247];
    sp[4625] = sp[4544] / sp[4247];
    sp[4626] = sp[4545] / sp[4247];
    sp[4627] = sp[4546] / sp[4247];
    sp[4628] = sp[4547] / sp[4247];
    sp[4629] = sp[4548] / sp[4247];
    sp[4630] = sp[4549] / sp[4247];
    sp[4631] = sp[4550] / sp[4247];
    sp[4632] = sp[4551] / sp[4247];
    sp[4633] = sp[4552] / sp[4247];
    sp[4634] = sp[4553] / sp[4247];
    sp[4635] = sp[4554] / sp[4247];
    sp[4636] = sp[4555] / sp[4247];
    sp[4637] = sp[4556] / sp[4247];
    sp[4638] = sp[4557] / sp[4247];
    sp[4639] = sp[4558] / sp[4247];
    sp[4640] = sp[4559] / sp[4247];
    sp[4641] = sp[4560] / sp[4247];
    sp[4642] = sp[4561] / sp[4247];
    sp[4643] = sp[4562] / sp[4247];
    sp[4644] = sp[4563] / sp[4247];
    sp[4645] = sp[4564] / sp[4247];
    sp[4646] = sp[4565] / sp[4247];
    sp[4647] = sp[4566] / sp[4247];
    sp[4648] = sp[4567] / sp[4247];
    sp[4649] = sp[4568] / sp[4247];
    sp[4650] = sp[4569] / sp[4247];
    sp[4651] = sp[4570] / sp[4247];
    sp[4652] = sp[4571] / sp[4247];
    sp[4653] = sp[4572] / sp[4247];
    sp[4654] = sp[4573] / sp[4247];
    sp[4655] = sp[4574] / sp[4247];
    sp[4656] = sp[4575] / sp[4247];
    sp[4657] = sp[4576] / sp[4247];
    sp[4658] = sp[4577] / sp[4247];
    sp[4659] = sp[4578] / sp[4247];
    sp[4660] = sp[4579] / sp[4247];
    sp[4661] = sp[4580] / sp[4247];
    sp[4662] = sp[4581] / sp[4247];
    sp[4663] = sp[4582] / sp[4247];
    sp[4664] = sp[4583] / sp[4247];
    sp[4665] = sp[4584] / sp[4247];
    sp[4666] = sp[4585] / sp[4247];
    sp[4667] = sp[4586] / sp[4247];
    sp[4668] = sp[4587] / sp[4247];
    sp[4669] = sp[4588] / sp[4247];
    sp[4670] = sp[4589] / sp[4247];
    sp[4671] = sp[4590] / sp[4247];
    sp[4672] = sp[4591] / sp[4247];
    sp[4673] = sp[4592] / sp[4247];
    sp[4674] = sp[4593] / sp[4247];
    sp[4675] = sp[4594] / sp[4247];
    sp[4676] = sp[4595] / sp[4247];
    sp[4677] = sp[4596] / sp[4247];
    sp[4678] = sp[4597] / sp[4247];
    sp[4679] = sp[4598] / sp[4247];
    sp[4680] = sp[4166] + sp[4599];
    sp[4681] = sp[4167] + sp[4600];
    sp[4682] = sp[4168] + sp[4601];
    sp[4683] = sp[4169] + sp[4602];
    sp[4684] = sp[4170] + sp[4603];
    sp[4685] = sp[4171] + sp[4604];
    sp[4686] = sp[4172] + sp[4605];
    sp[4687] = sp[4173] + sp[4606];
    sp[4688] = sp[4174] + sp[4607];
    sp[4689] = sp[4175] + sp[4608];
    sp[4690] = sp[4176] + sp[4609];
    sp[4691] = sp[4177] + sp[4610];
    sp[4692] = sp[4178] + sp[4611];
    sp[4693] = sp[4179] + sp[4612];
    sp[4694] = sp[4180] + sp[4613];
    sp[4695] = sp[4181] + sp[4614];
    sp[4696] = sp[4182] + sp[4615];
    sp[4697] = sp[4183] + sp[4616];
    sp[4698] = sp[4184] + sp[4617];
    sp[4699] = sp[4185] + sp[4618];
    sp[4700] = sp[4186] + sp[4619];
    sp[4701] = sp[4187] + sp[4620];
    sp[4702] = sp[4188] + sp[4621];
    sp[4703] = sp[4189] + sp[4622];
    sp[4704] = sp[4190] + sp[4623];
    sp[4705] = sp[4191] + sp[4624];
    sp[4706] = sp[4192] + sp[4625];
    sp[4707] = sp[4193] + sp[4626];
    sp[4708] = sp[4194] + sp[4627];
    sp[4709] = sp[4195] + sp[4628];
    sp[4710] = sp[4196] + sp[4629];
    sp[4711] = sp[4197] + sp[4630];
    sp[4712] = sp[4198] + sp[4631];
    sp[4713] = sp[4199] + sp[4632];
    sp[4714] = sp[4200] + sp[4633];
    sp[4715] = sp[4201] + sp[4634];
    sp[4716] = sp[4202] + sp[4635];
    sp[4717] = sp[4203] + sp[4636];
    sp[4718] = sp[4204] + sp[4637];
    sp[4719] = sp[4205] + sp[4638];
    sp[4720] = sp[4206] + sp[4639];
    sp[4721] = sp[4207] + sp[4640];
    sp[4722] = sp[4208] + sp[4641];
    sp[4723] = sp[4209] + sp[4642];
    sp[4724] = sp[4210] + sp[4643];
    sp[4725] = sp[4211] + sp[4644];
    sp[4726] = sp[4212] + sp[4645];
    sp[4727] = sp[4213] + sp[4646];
    sp[4728] = sp[4214] + sp[4647];
    sp[4729] = sp[4215] + sp[4648];
    sp[4730] = sp[4216] + sp[4649];
    sp[4731] = sp[4217] + sp[4650];
    sp[4732] = sp[4218] + sp[4651];
    sp[4733] = sp[4219] + sp[4652];
    sp[4734] = sp[4220] + sp[4653];
    sp[4735] = sp[4221] + sp[4654];
    sp[4736] = sp[4222] + sp[4655];
    sp[4737] = sp[4223] + sp[4656];
    sp[4738] = sp[4224] + sp[4657];
    sp[4739] = sp[4225] + sp[4658];
    sp[4740] = sp[4226] + sp[4659];
    sp[4741] = sp[4227] + sp[4660];
    sp[4742] = sp[4228] + sp[4661];
    sp[4743] = sp[4229] + sp[4662];
    sp[4744] = sp[4230] + sp[4663];
    sp[4745] = sp[4231] + sp[4664];
    sp[4746] = sp[4232] + sp[4665];
    sp[4747] = sp[4233] + sp[4666];
    sp[4748] = sp[4234] + sp[4667];
    sp[4749] = sp[4235] + sp[4668];
    sp[4750] = sp[4236] + sp[4669];
    sp[4751] = sp[4237] + sp[4670];
    sp[4752] = sp[4238] + sp[4671];
    sp[4753] = sp[4239] + sp[4672];
    sp[4754] = sp[4240] + sp[4673];
    sp[4755] = sp[4241] + sp[4674];
    sp[4756] = sp[4242] + sp[4675];
    sp[4757] = sp[4243] + sp[4676];
    sp[4758] = sp[4244] + sp[4677];
    sp[4759] = sp[4245] + sp[4678];
    sp[4760] = sp[4246] + sp[4679];
    sp[4761] = sp[4680] * w[2][0];
    sp[4762] = sp[4681] * w[2][0];
    sp[4763] = sp[4682] * w[2][0];
    sp[4764] = sp[4683] * w[2][0];
    sp[4765] = sp[4684] * w[2][0];
    sp[4766] = sp[4685] * w[2][0];
    sp[4767] = sp[4686] * w[2][0];
    sp[4768] = sp[4687] * w[2][0];
    sp[4769] = sp[4688] * w[2][0];
    sp[4770] = sp[4689] * w[2][0];
    sp[4771] = sp[4690] * w[2][0];
    sp[4772] = sp[4691] * w[2][0];
    sp[4773] = sp[4692] * w[2][0];
    sp[4774] = sp[4693] * w[2][0];
    sp[4775] = sp[4694] * w[2][0];
    sp[4776] = sp[4695] * w[2][0];
    sp[4777] = sp[4696] * w[2][0];
    sp[4778] = sp[4697] * w[2][0];
    sp[4779] = sp[4698] * w[2][0];
    sp[4780] = sp[4699] * w[2][0];
    sp[4781] = sp[4700] * w[2][0];
    sp[4782] = sp[4701] * w[2][0];
    sp[4783] = sp[4702] * w[2][0];
    sp[4784] = sp[4703] * w[2][0];
    sp[4785] = sp[4704] * w[2][0];
    sp[4786] = sp[4705] * w[2][0];
    sp[4787] = sp[4706] * w[2][0];
    sp[4788] = sp[4707] * w[2][0];
    sp[4789] = sp[4708] * w[2][0];
    sp[4790] = sp[4709] * w[2][0];
    sp[4791] = sp[4710] * w[2][0];
    sp[4792] = sp[4711] * w[2][0];
    sp[4793] = sp[4712] * w[2][0];
    sp[4794] = sp[4713] * w[2][0];
    sp[4795] = sp[4714] * w[2][0];
    sp[4796] = sp[4715] * w[2][0];
    sp[4797] = sp[4716] * w[2][0];
    sp[4798] = sp[4717] * w[2][0];
    sp[4799] = sp[4718] * w[2][0];
    sp[4800] = sp[4719] * w[2][0];
    sp[4801] = sp[4720] * w[2][0];
    sp[4802] = sp[4721] * w[2][0];
    sp[4803] = sp[4722] * w[2][0];
    sp[4804] = sp[4723] * w[2][0];
    sp[4805] = sp[4724] * w[2][0];
    sp[4806] = sp[4725] * w[2][0];
    sp[4807] = sp[4726] * w[2][0];
    sp[4808] = sp[4727] * w[2][0];
    sp[4809] = sp[4728] * w[2][0];
    sp[4810] = sp[4729] * w[2][0];
    sp[4811] = sp[4730] * w[2][0];
    sp[4812] = sp[4731] * w[2][0];
    sp[4813] = sp[4732] * w[2][0];
    sp[4814] = sp[4733] * w[2][0];
    sp[4815] = sp[4734] * w[2][0];
    sp[4816] = sp[4735] * w[2][0];
    sp[4817] = sp[4736] * w[2][0];
    sp[4818] = sp[4737] * w[2][0];
    sp[4819] = sp[4738] * w[2][0];
    sp[4820] = sp[4739] * w[2][0];
    sp[4821] = sp[4740] * w[2][0];
    sp[4822] = sp[4741] * w[2][0];
    sp[4823] = sp[4742] * w[2][0];
    sp[4824] = sp[4743] * w[2][0];
    sp[4825] = sp[4744] * w[2][0];
    sp[4826] = sp[4745] * w[2][0];
    sp[4827] = sp[4746] * w[2][0];
    sp[4828] = sp[4747] * w[2][0];
    sp[4829] = sp[4748] * w[2][0];
    sp[4830] = sp[4749] * w[2][0];
    sp[4831] = sp[4750] * w[2][0];
    sp[4832] = sp[4751] * w[2][0];
    sp[4833] = sp[4752] * w[2][0];
    sp[4834] = sp[4753] * w[2][0];
    sp[4835] = sp[4754] * w[2][0];
    sp[4836] = sp[4755] * w[2][0];
    sp[4837] = sp[4756] * w[2][0];
    sp[4838] = sp[4757] * w[2][0];
    sp[4839] = sp[4758] * w[2][0];
    sp[4840] = sp[4759] * w[2][0];
    sp[4841] = sp[4760] * w[2][0];
    sp[4842] = sp[3813] + sp[4761];
    sp[4843] = sp[3814] + sp[4762];
    sp[4844] = sp[3815] + sp[4763];
    sp[4845] = sp[3816] + sp[4764];
    sp[4846] = sp[3817] + sp[4765];
    sp[4847] = sp[3818] + sp[4766];
    sp[4848] = sp[3819] + sp[4767];
    sp[4849] = sp[3820] + sp[4768];
    sp[4850] = sp[3821] + sp[4769];
    sp[4851] = sp[3822] + sp[4770];
    sp[4852] = sp[3823] + sp[4771];
    sp[4853] = sp[3824] + sp[4772];
    sp[4854] = sp[3825] + sp[4773];
    sp[4855] = sp[3826] + sp[4774];
    sp[4856] = sp[3827] + sp[4775];
    sp[4857] = sp[3828] + sp[4776];
    sp[4858] = sp[3829] + sp[4777];
    sp[4859] = sp[3830] + sp[4778];
    sp[4860] = sp[3831] + sp[4779];
    sp[4861] = sp[3832] + sp[4780];
    sp[4862] = sp[3833] + sp[4781];
    sp[4863] = sp[3834] + sp[4782];
    sp[4864] = sp[3835] + sp[4783];
    sp[4865] = sp[3836] + sp[4784];
    sp[4866] = sp[3837] + sp[4785];
    sp[4867] = sp[3838] + sp[4786];
    sp[4868] = sp[3839] + sp[4787];
    sp[4869] = sp[3840] + sp[4788];
    sp[4870] = sp[3841] + sp[4789];
    sp[4871] = sp[3842] + sp[4790];
    sp[4872] = sp[3843] + sp[4791];
    sp[4873] = sp[3844] + sp[4792];
    sp[4874] = sp[3845] + sp[4793];
    sp[4875] = sp[3846] + sp[4794];
    sp[4876] = sp[3847] + sp[4795];
    sp[4877] = sp[3848] + sp[4796];
    sp[4878] = sp[3849] + sp[4797];
    sp[4879] = sp[3850] + sp[4798];
    sp[4880] = sp[3851] + sp[4799];
    sp[4881] = sp[3852] + sp[4800];
    sp[4882] = sp[3853] + sp[4801];
    sp[4883] = sp[3854] + sp[4802];
    sp[4884] = sp[3855] + sp[4803];
    sp[4885] = sp[3856] + sp[4804];
    sp[4886] = sp[3857] + sp[4805];
    sp[4887] = sp[3858] + sp[4806];
    sp[4888] = sp[3859] + sp[4807];
    sp[4889] = sp[3860] + sp[4808];
    sp[4890] = sp[3861] + sp[4809];
    sp[4891] = sp[3862] + sp[4810];
    sp[4892] = sp[3863] + sp[4811];
    sp[4893] = sp[3864] + sp[4812];
    sp[4894] = sp[3865] + sp[4813];
    sp[4895] = sp[3866] + sp[4814];
    sp[4896] = sp[3867] + sp[4815];
    sp[4897] = sp[3868] + sp[4816];
    sp[4898] = sp[3869] + sp[4817];
    sp[4899] = sp[3870] + sp[4818];
    sp[4900] = sp[3871] + sp[4819];
    sp[4901] = sp[3872] + sp[4820];
    sp[4902] = sp[3873] + sp[4821];
    sp[4903] = sp[3874] + sp[4822];
    sp[4904] = sp[3875] + sp[4823];
    sp[4905] = sp[3876] + sp[4824];
    sp[4906] = sp[3877] + sp[4825];
    sp[4907] = sp[3878] + sp[4826];
    sp[4908] = sp[3879] + sp[4827];
    sp[4909] = sp[3880] + sp[4828];
    sp[4910] = sp[3881] + sp[4829];
    sp[4911] = sp[3882] + sp[4830];
    sp[4912] = sp[3883] + sp[4831];
    sp[4913] = sp[3884] + sp[4832];
    sp[4914] = sp[3885] + sp[4833];
    sp[4915] = sp[3886] + sp[4834];
    sp[4916] = sp[3887] + sp[4835];
    sp[4917] = sp[3888] + sp[4836];
    sp[4918] = sp[3889] + sp[4837];
    sp[4919] = sp[3890] + sp[4838];
    sp[4920] = sp[3891] + sp[4839];
    sp[4921] = sp[3892] + sp[4840];
    sp[4922] = sp[3893] + sp[4841];
    sp[4923] = std::abs(sp[13]);
    sp[4924] = sp[4842] * sp[4923];
    sp[4925] = sp[4843] * sp[4923];
    sp[4926] = sp[4844] * sp[4923];
    sp[4927] = sp[4845] * sp[4923];
    sp[4928] = sp[4846] * sp[4923];
    sp[4929] = sp[4847] * sp[4923];
    sp[4930] = sp[4848] * sp[4923];
    sp[4931] = sp[4849] * sp[4923];
    sp[4932] = sp[4850] * sp[4923];
    sp[4933] = sp[4851] * sp[4923];
    sp[4934] = sp[4852] * sp[4923];
    sp[4935] = sp[4853] * sp[4923];
    sp[4936] = sp[4854] * sp[4923];
    sp[4937] = sp[4855] * sp[4923];
    sp[4938] = sp[4856] * sp[4923];
    sp[4939] = sp[4857] * sp[4923];
    sp[4940] = sp[4858] * sp[4923];
    sp[4941] = sp[4859] * sp[4923];
    sp[4942] = sp[4860] * sp[4923];
    sp[4943] = sp[4861] * sp[4923];
    sp[4944] = sp[4862] * sp[4923];
    sp[4945] = sp[4863] * sp[4923];
    sp[4946] = sp[4864] * sp[4923];
    sp[4947] = sp[4865] * sp[4923];
    sp[4948] = sp[4866] * sp[4923];
    sp[4949] = sp[4867] * sp[4923];
    sp[4950] = sp[4868] * sp[4923];
    sp[4951] = sp[4869] * sp[4923];
    sp[4952] = sp[4870] * sp[4923];
    sp[4953] = sp[4871] * sp[4923];
    sp[4954] = sp[4872] * sp[4923];
    sp[4955] = sp[4873] * sp[4923];
    sp[4956] = sp[4874] * sp[4923];
    sp[4957] = sp[4875] * sp[4923];
    sp[4958] = sp[4876] * sp[4923];
    sp[4959] = sp[4877] * sp[4923];
    sp[4960] = sp[4878] * sp[4923];
    sp[4961] = sp[4879] * sp[4923];
    sp[4962] = sp[4880] * sp[4923];
    sp[4963] = sp[4881] * sp[4923];
    sp[4964] = sp[4882] * sp[4923];
    sp[4965] = sp[4883] * sp[4923];
    sp[4966] = sp[4884] * sp[4923];
    sp[4967] = sp[4885] * sp[4923];
    sp[4968] = sp[4886] * sp[4923];
    sp[4969] = sp[4887] * sp[4923];
    sp[4970] = sp[4888] * sp[4923];
    sp[4971] = sp[4889] * sp[4923];
    sp[4972] = sp[4890] * sp[4923];
    sp[4973] = sp[4891] * sp[4923];
    sp[4974] = sp[4892] * sp[4923];
    sp[4975] = sp[4893] * sp[4923];
    sp[4976] = sp[4894] * sp[4923];
    sp[4977] = sp[4895] * sp[4923];
    sp[4978] = sp[4896] * sp[4923];
    sp[4979] = sp[4897] * sp[4923];
    sp[4980] = sp[4898] * sp[4923];
    sp[4981] = sp[4899] * sp[4923];
    sp[4982] = sp[4900] * sp[4923];
    sp[4983] = sp[4901] * sp[4923];
    sp[4984] = sp[4902] * sp[4923];
    sp[4985] = sp[4903] * sp[4923];
    sp[4986] = sp[4904] * sp[4923];
    sp[4987] = sp[4905] * sp[4923];
    sp[4988] = sp[4906] * sp[4923];
    sp[4989] = sp[4907] * sp[4923];
    sp[4990] = sp[4908] * sp[4923];
    sp[4991] = sp[4909] * sp[4923];
    sp[4992] = sp[4910] * sp[4923];
    sp[4993] = sp[4911] * sp[4923];
    sp[4994] = sp[4912] * sp[4923];
    sp[4995] = sp[4913] * sp[4923];
    sp[4996] = sp[4914] * sp[4923];
    sp[4997] = sp[4915] * sp[4923];
    sp[4998] = sp[4916] * sp[4923];
    sp[4999] = sp[4917] * sp[4923];
    sp[5000] = sp[4918] * sp[4923];
    sp[5001] = sp[4919] * sp[4923];
    sp[5002] = sp[4920] * sp[4923];
    sp[5003] = sp[4921] * sp[4923];
    sp[5004] = sp[4922] * sp[4923];
    A[0] = 0.1666666666666667 * sp[4924] + 0.1666666666666667 * sp[4925] + 0.1666666666666667 * sp[4926] + 0.1666666666666667 * sp[4933] + 0.1666666666666667 * sp[4934] + 0.1666666666666667 * sp[4935] + 0.1666666666666667 * sp[4942] + 0.1666666666666667 * sp[4943] + 0.1666666666666667 * sp[4944];
    A[1] = -0.1666666666666667 * sp[4924] + -0.1666666666666667 * sp[4933] + -0.1666666666666667 * sp[4942];
    A[2] = -0.1666666666666667 * sp[4925] + -0.1666666666666667 * sp[4934] + -0.1666666666666667 * sp[4943];
    A[3] = -0.1666666666666667 * sp[4926] + -0.1666666666666667 * sp[4935] + -0.1666666666666667 * sp[4944];
    A[4] = 0.1666666666666667 * sp[4927] + 0.1666666666666667 * sp[4928] + 0.1666666666666667 * sp[4929] + 0.1666666666666667 * sp[4936] + 0.1666666666666667 * sp[4937] + 0.1666666666666667 * sp[4938] + 0.1666666666666667 * sp[4945] + 0.1666666666666667 * sp[4946] + 0.1666666666666667 * sp[4947];
    A[5] = -0.1666666666666667 * sp[4927] + -0.1666666666666667 * sp[4936] + -0.1666666666666667 * sp[4945];
    A[6] = -0.1666666666666667 * sp[4928] + -0.1666666666666667 * sp[4937] + -0.1666666666666667 * sp[4946];
    A[7] = -0.1666666666666667 * sp[4929] + -0.1666666666666667 * sp[4938] + -0.1666666666666667 * sp[4947];
    A[8] = 0.1666666666666667 * sp[4930] + 0.1666666666666667 * sp[4931] + 0.1666666666666667 * sp[4932] + 0.1666666666666667 * sp[4939] + 0.1666666666666667 * sp[4940] + 0.1666666666666667 * sp[4941] + 0.1666666666666667 * sp[4948] + 0.1666666666666667 * sp[4949] + 0.1666666666666667 * sp[4950];
    A[9] = -0.1666666666666667 * sp[4930] + -0.1666666666666667 * sp[4939] + -0.1666666666666667 * sp[4948];
    A[10] = -0.1666666666666667 * sp[4931] + -0.1666666666666667 * sp[4940] + -0.1666666666666667 * sp[4949];
    A[11] = -0.1666666666666667 * sp[4932] + -0.1666666666666667 * sp[4941] + -0.1666666666666667 * sp[4950];
    A[12] = -0.1666666666666667 * sp[4924] + -0.1666666666666667 * sp[4925] + -0.1666666666666667 * sp[4926];
    A[13] = 0.1666666666666667 * sp[4924];
    A[14] = 0.1666666666666667 * sp[4925];
    A[15] = 0.1666666666666667 * sp[4926];
    A[16] = -0.1666666666666667 * sp[4927] + -0.1666666666666667 * sp[4928] + -0.1666666666666667 * sp[4929];
    A[17] = 0.1666666666666667 * sp[4927];
    A[18] = 0.1666666666666667 * sp[4928];
    A[19] = 0.1666666666666667 * sp[4929];
    A[20] = -0.1666666666666667 * sp[4930] + -0.1666666666666667 * sp[4931] + -0.1666666666666667 * sp[4932];
    A[21] = 0.1666666666666667 * sp[4930];
    A[22] = 0.1666666666666667 * sp[4931];
    A[23] = 0.1666666666666667 * sp[4932];
    A[24] = -0.1666666666666667 * sp[4933] + -0.1666666666666667 * sp[4934] + -0.1666666666666667 * sp[4935];
    A[25] = 0.1666666666666667 * sp[4933];
    A[26] = 0.1666666666666667 * sp[4934];
    A[27] = 0.1666666666666667 * sp[4935];
    A[28] = -0.1666666666666667 * sp[4936] + -0.1666666666666667 * sp[4937] + -0.1666666666666667 * sp[4938];
    A[29] = 0.1666666666666667 * sp[4936];
    A[30] = 0.1666666666666667 * sp[4937];
    A[31] = 0.1666666666666667 * sp[4938];
    A[32] = -0.1666666666666667 * sp[4939] + -0.1666666666666667 * sp[4940] + -0.1666666666666667 * sp[4941];
    A[33] = 0.1666666666666667 * sp[4939];
    A[34] = 0.1666666666666667 * sp[4940];
    A[35] = 0.1666666666666667 * sp[4941];
    A[36] = -0.1666666666666667 * sp[4942] + -0.1666666666666667 * sp[4943] + -0.1666666666666667 * sp[4944];
    A[37] = 0.1666666666666667 * sp[4942];
    A[38] = 0.1666666666666667 * sp[4943];
    A[39] = 0.1666666666666667 * sp[4944];
    A[40] = -0.1666666666666667 * sp[4945] + -0.1666666666666667 * sp[4946] + -0.1666666666666667 * sp[4947];
    A[41] = 0.1666666666666667 * sp[4945];
    A[42] = 0.1666666666666667 * sp[4946];
    A[43] = 0.1666666666666667 * sp[4947];
    A[44] = -0.1666666666666667 * sp[4948] + -0.1666666666666667 * sp[4949] + -0.1666666666666667 * sp[4950];
    A[45] = 0.1666666666666667 * sp[4948];
    A[46] = 0.1666666666666667 * sp[4949];
    A[47] = 0.1666666666666667 * sp[4950];
    A[48] = 0.1666666666666667 * sp[4951] + 0.1666666666666667 * sp[4957] + 0.1666666666666667 * sp[4963] + 0.1666666666666667 * sp[4952] + 0.1666666666666667 * sp[4958] + 0.1666666666666667 * sp[4964] + 0.1666666666666667 * sp[4953] + 0.1666666666666667 * sp[4959] + 0.1666666666666667 * sp[4965];
    A[49] = -0.1666666666666667 * sp[4951] + -0.1666666666666667 * sp[4952] + -0.1666666666666667 * sp[4953];
    A[50] = -0.1666666666666667 * sp[4957] + -0.1666666666666667 * sp[4958] + -0.1666666666666667 * sp[4959];
    A[51] = -0.1666666666666667 * sp[4963] + -0.1666666666666667 * sp[4964] + -0.1666666666666667 * sp[4965];
    A[52] = 0.1666666666666667 * sp[4969] + 0.1666666666666667 * sp[4970] + 0.1666666666666667 * sp[4971] + 0.1666666666666667 * sp[4975] + 0.1666666666666667 * sp[4976] + 0.1666666666666667 * sp[4977] + 0.1666666666666667 * sp[4981] + 0.1666666666666667 * sp[4982] + 0.1666666666666667 * sp[4983];
    A[53] = -0.1666666666666667 * sp[4969] + -0.1666666666666667 * sp[4975] + -0.1666666666666667 * sp[4981];
    A[54] = -0.1666666666666667 * sp[4970] + -0.1666666666666667 * sp[4976] + -0.1666666666666667 * sp[4982];
    A[55] = -0.1666666666666667 * sp[4971] + -0.1666666666666667 * sp[4977] + -0.1666666666666667 * sp[4983];
    A[56] = 0.1666666666666667 * sp[4972] + 0.1666666666666667 * sp[4973] + 0.1666666666666667 * sp[4974] + 0.1666666666666667 * sp[4978] + 0.1666666666666667 * sp[4979] + 0.1666666666666667 * sp[4980] + 0.1666666666666667 * sp[4984] + 0.1666666666666667 * sp[4985] + 0.1666666666666667 * sp[4986];
    A[57] = -0.1666666666666667 * sp[4972] + -0.1666666666666667 * sp[4978] + -0.1666666666666667 * sp[4984];
    A[58] = -0.1666666666666667 * sp[4973] + -0.1666666666666667 * sp[4979] + -0.1666666666666667 * sp[4985];
    A[59] = -0.1666666666666667 * sp[4974] + -0.1666666666666667 * sp[4980] + -0.1666666666666667 * sp[4986];
    A[60] = -0.1666666666666667 * sp[4951] + -0.1666666666666667 * sp[4957] + -0.1666666666666667 * sp[4963];
    A[61] = 0.1666666666666667 * sp[4951];
    A[62] = 0.1666666666666667 * sp[4957];
    A[63] = 0.1666666666666667 * sp[4963];
    A[64] = -0.1666666666666667 * sp[4969] + -0.1666666666666667 * sp[4970] + -0.1666666666666667 * sp[4971];
    A[65] = 0.1666666666666667 * sp[4969];
    A[66] = 0.1666666666666667 * sp[4970];
    A[67] = 0.1666666666666667 * sp[4971];
    A[68] = -0.1666666666666667 * sp[4972] + -0.1666666666666667 * sp[4973] + -0.1666666666666667 * sp[4974];
    A[69] = 0.1666666666666667 * sp[4972];
    A[70] = 0.1666666666666667 * sp[4973];
    A[71] = 0.1666666666666667 * sp[4974];
    A[72] = -0.1666666666666667 * sp[4952] + -0.1666666666666667 * sp[4958] + -0.1666666666666667 * sp[4964];
    A[73] = 0.1666666666666667 * sp[4952];
    A[74] = 0.1666666666666667 * sp[4958];
    A[75] = 0.1666666666666667 * sp[4964];
    A[76] = -0.1666666666666667 * sp[4975] + -0.1666666666666667 * sp[4976] + -0.1666666666666667 * sp[4977];
    A[77] = 0.1666666666666667 * sp[4975];
    A[78] = 0.1666666666666667 * sp[4976];
    A[79] = 0.1666666666666667 * sp[4977];
    A[80] = -0.1666666666666667 * sp[4978] + -0.1666666666666667 * sp[4979] + -0.1666666666666667 * sp[4980];
    A[81] = 0.1666666666666667 * sp[4978];
    A[82] = 0.1666666666666667 * sp[4979];
    A[83] = 0.1666666666666667 * sp[4980];
    A[84] = -0.1666666666666667 * sp[4953] + -0.1666666666666667 * sp[4959] + -0.1666666666666667 * sp[4965];
    A[85] = 0.1666666666666667 * sp[4953];
    A[86] = 0.1666666666666667 * sp[4959];
    A[87] = 0.1666666666666667 * sp[4965];
    A[88] = -0.1666666666666667 * sp[4981] + -0.1666666666666667 * sp[4982] + -0.1666666666666667 * sp[4983];
    A[89] = 0.1666666666666667 * sp[4981];
    A[90] = 0.1666666666666667 * sp[4982];
    A[91] = 0.1666666666666667 * sp[4983];
    A[92] = -0.1666666666666667 * sp[4984] + -0.1666666666666667 * sp[4985] + -0.1666666666666667 * sp[4986];
    A[93] = 0.1666666666666667 * sp[4984];
    A[94] = 0.1666666666666667 * sp[4985];
    A[95] = 0.1666666666666667 * sp[4986];
    A[96] = 0.1666666666666667 * sp[4954] + 0.1666666666666667 * sp[4960] + 0.1666666666666667 * sp[4966] + 0.1666666666666667 * sp[4955] + 0.1666666666666667 * sp[4961] + 0.1666666666666667 * sp[4967] + 0.1666666666666667 * sp[4956] + 0.1666666666666667 * sp[4962] + 0.1666666666666667 * sp[4968];
    A[97] = -0.1666666666666667 * sp[4954] + -0.1666666666666667 * sp[4955] + -0.1666666666666667 * sp[4956];
    A[98] = -0.1666666666666667 * sp[4960] + -0.1666666666666667 * sp[4961] + -0.1666666666666667 * sp[4962];
    A[99] = -0.1666666666666667 * sp[4966] + -0.1666666666666667 * sp[4967] + -0.1666666666666667 * sp[4968];
    A[100] = 0.1666666666666667 * sp[4987] + 0.1666666666666667 * sp[4990] + 0.1666666666666667 * sp[4993] + 0.1666666666666667 * sp[4988] + 0.1666666666666667 * sp[4991] + 0.1666666666666667 * sp[4994] + 0.1666666666666667 * sp[4989] + 0.1666666666666667 * sp[4992] + 0.1666666666666667 * sp[4995];
    A[101] = -0.1666666666666667 * sp[4987] + -0.1666666666666667 * sp[4988] + -0.1666666666666667 * sp[4989];
    A[102] = -0.1666666666666667 * sp[4990] + -0.1666666666666667 * sp[4991] + -0.1666666666666667 * sp[4992];
    A[103] = -0.1666666666666667 * sp[4993] + -0.1666666666666667 * sp[4994] + -0.1666666666666667 * sp[4995];
    A[104] = 0.1666666666666667 * sp[4996] + 0.1666666666666667 * sp[4997] + 0.1666666666666667 * sp[4998] + 0.1666666666666667 * sp[4999] + 0.1666666666666667 * sp[5000] + 0.1666666666666667 * sp[5001] + 0.1666666666666667 * sp[5002] + 0.1666666666666667 * sp[5003] + 0.1666666666666667 * sp[5004];
    A[105] = -0.1666666666666667 * sp[4996] + -0.1666666666666667 * sp[4999] + -0.1666666666666667 * sp[5002];
    A[106] = -0.1666666666666667 * sp[4997] + -0.1666666666666667 * sp[5000] + -0.1666666666666667 * sp[5003];
    A[107] = -0.1666666666666667 * sp[4998] + -0.1666666666666667 * sp[5001] + -0.1666666666666667 * sp[5004];
    A[108] = -0.1666666666666667 * sp[4954] + -0.1666666666666667 * sp[4960] + -0.1666666666666667 * sp[4966];
    A[109] = 0.1666666666666667 * sp[4954];
    A[110] = 0.1666666666666667 * sp[4960];
    A[111] = 0.1666666666666667 * sp[4966];
    A[112] = -0.1666666666666667 * sp[4987] + -0.1666666666666667 * sp[4990] + -0.1666666666666667 * sp[4993];
    A[113] = 0.1666666666666667 * sp[4987];
    A[114] = 0.1666666666666667 * sp[4990];
    A[115] = 0.1666666666666667 * sp[4993];
    A[116] = -0.1666666666666667 * sp[4996] + -0.1666666666666667 * sp[4997] + -0.1666666666666667 * sp[4998];
    A[117] = 0.1666666666666667 * sp[4996];
    A[118] = 0.1666666666666667 * sp[4997];
    A[119] = 0.1666666666666667 * sp[4998];
    A[120] = -0.1666666666666667 * sp[4955] + -0.1666666666666667 * sp[4961] + -0.1666666666666667 * sp[4967];
    A[121] = 0.1666666666666667 * sp[4955];
    A[122] = 0.1666666666666667 * sp[4961];
    A[123] = 0.1666666666666667 * sp[4967];
    A[124] = -0.1666666666666667 * sp[4988] + -0.1666666666666667 * sp[4991] + -0.1666666666666667 * sp[4994];
    A[125] = 0.1666666666666667 * sp[4988];
    A[126] = 0.1666666666666667 * sp[4991];
    A[127] = 0.1666666666666667 * sp[4994];
    A[128] = -0.1666666666666667 * sp[4999] + -0.1666666666666667 * sp[5000] + -0.1666666666666667 * sp[5001];
    A[129] = 0.1666666666666667 * sp[4999];
    A[130] = 0.1666666666666667 * sp[5000];
    A[131] = 0.1666666666666667 * sp[5001];
    A[132] = -0.1666666666666667 * sp[4956] + -0.1666666666666667 * sp[4962] + -0.1666666666666667 * sp[4968];
    A[133] = 0.1666666666666667 * sp[4956];
    A[134] = 0.1666666666666667 * sp[4962];
    A[135] = 0.1666666666666667 * sp[4968];
    A[136] = -0.1666666666666667 * sp[4989] + -0.1666666666666667 * sp[4992] + -0.1666666666666667 * sp[4995];
    A[137] = 0.1666666666666667 * sp[4989];
    A[138] = 0.1666666666666667 * sp[4992];
    A[139] = 0.1666666666666667 * sp[4995];
    A[140] = -0.1666666666666667 * sp[5002] + -0.1666666666666667 * sp[5003] + -0.1666666666666667 * sp[5004];
    A[141] = 0.1666666666666667 * sp[5002];
    A[142] = 0.1666666666666667 * sp[5003];
    A[143] = 0.1666666666666667 * sp[5004];
}


hyperelasticitybiso_cell_integral_1_otherwise::hyperelasticitybiso_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

hyperelasticitybiso_cell_integral_1_otherwise::~hyperelasticitybiso_cell_integral_1_otherwise()
{

}

const std::vector<bool> & hyperelasticitybiso_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, false, true, true, true});
return enabled;
}

void hyperelasticitybiso_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 1
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 1
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           1
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE33_C0_D001_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE33_C0_D001_Q1[0][0][ic];
    const double J_c4 = coordinate_dofs[1] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[7] * FE33_C0_D001_Q1[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[11] * FE33_C0_D001_Q1[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[10] * FE33_C0_D001_Q1[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[8] * FE33_C0_D001_Q1[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[3] * FE33_C0_D001_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[6] * FE33_C0_D001_Q1[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[5] * FE33_C0_D001_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[4] * FE33_C0_D001_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE33_C0_D001_Q1[0][0][0] + coordinate_dofs[9] * FE33_C0_D001_Q1[0][0][1];
    const double w0_d1_c0 = w[0][0] * FE33_C0_D001_Q1[0][0][0] + w[0][2] * FE33_C0_D001_Q1[0][0][1];
    const double w0_d2_c0 = w[0][0] * FE33_C0_D001_Q1[0][0][0] + w[0][3] * FE33_C0_D001_Q1[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 4] * FE33_C0_D001_Q1[0][0][ic];
    const double w0_d1_c1 = w[0][4] * FE33_C0_D001_Q1[0][0][0] + w[0][6] * FE33_C0_D001_Q1[0][0][1];
    const double w0_d2_c1 = w[0][4] * FE33_C0_D001_Q1[0][0][0] + w[0][7] * FE33_C0_D001_Q1[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 8] * FE33_C0_D001_Q1[0][0][ic];
    const double w0_d1_c2 = w[0][8] * FE33_C0_D001_Q1[0][0][0] + w[0][10] * FE33_C0_D001_Q1[0][0][1];
    const double w0_d2_c2 = w[0][8] * FE33_C0_D001_Q1[0][0][0] + w[0][11] * FE33_C0_D001_Q1[0][0][1];
    alignas(32) double sp[690];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = sp[2] / sp[13];
    sp[15] = w0_d0_c0 * sp[14];
    sp[16] = J_c3 * (-1 * J_c8);
    sp[17] = sp[4] + sp[16];
    sp[18] = sp[17] / sp[13];
    sp[19] = w0_d1_c0 * sp[18];
    sp[20] = sp[15] + sp[19];
    sp[21] = sp[11] / sp[13];
    sp[22] = w0_d2_c0 * sp[21];
    sp[23] = sp[20] + sp[22];
    sp[24] = (1 + sp[23]) * sp[14];
    sp[25] = (1 + sp[23]) * sp[18];
    sp[26] = (1 + sp[23]) * sp[21];
    sp[27] = sp[24] + sp[24];
    sp[28] = sp[25] + sp[25];
    sp[29] = sp[26] + sp[26];
    sp[30] = w0_d0_c1 * sp[14];
    sp[31] = w0_d1_c1 * sp[18];
    sp[32] = sp[30] + sp[31];
    sp[33] = w0_d2_c1 * sp[21];
    sp[34] = sp[32] + sp[33];
    sp[35] = sp[34] * sp[14];
    sp[36] = sp[34] * sp[18];
    sp[37] = sp[34] * sp[21];
    sp[38] = sp[35] + sp[35];
    sp[39] = sp[36] + sp[36];
    sp[40] = sp[37] + sp[37];
    sp[41] = w0_d0_c2 * sp[14];
    sp[42] = w0_d1_c2 * sp[18];
    sp[43] = sp[41] + sp[42];
    sp[44] = w0_d2_c2 * sp[21];
    sp[45] = sp[43] + sp[44];
    sp[46] = sp[45] * sp[14];
    sp[47] = sp[45] * sp[18];
    sp[48] = sp[45] * sp[21];
    sp[49] = sp[46] + sp[46];
    sp[50] = sp[47] + sp[47];
    sp[51] = sp[48] + sp[48];
    sp[52] = J_c2 * J_c7;
    sp[53] = J_c8 * (-1 * J_c1);
    sp[54] = sp[52] + sp[53];
    sp[55] = sp[54] / sp[13];
    sp[56] = J_c0 * J_c8;
    sp[57] = J_c6 * (-1 * J_c2);
    sp[58] = sp[56] + sp[57];
    sp[59] = sp[58] / sp[13];
    sp[60] = J_c1 * J_c6;
    sp[61] = J_c0 * J_c7;
    sp[62] = sp[60] + -1 * sp[61];
    sp[63] = sp[62] / sp[13];
    sp[64] = w0_d0_c0 * sp[55];
    sp[65] = w0_d1_c0 * sp[59];
    sp[66] = sp[64] + sp[65];
    sp[67] = w0_d2_c0 * sp[63];
    sp[68] = sp[66] + sp[67];
    sp[69] = sp[68] * sp[55];
    sp[70] = sp[68] * sp[59];
    sp[71] = sp[68] * sp[63];
    sp[72] = sp[69] + sp[69];
    sp[73] = sp[70] + sp[70];
    sp[74] = sp[71] + sp[71];
    sp[75] = w0_d0_c1 * sp[55];
    sp[76] = w0_d1_c1 * sp[59];
    sp[77] = sp[75] + sp[76];
    sp[78] = w0_d2_c1 * sp[63];
    sp[79] = sp[77] + sp[78];
    sp[80] = (1 + sp[79]) * sp[55];
    sp[81] = (1 + sp[79]) * sp[59];
    sp[82] = (1 + sp[79]) * sp[63];
    sp[83] = sp[80] + sp[80];
    sp[84] = sp[81] + sp[81];
    sp[85] = sp[82] + sp[82];
    sp[86] = w0_d0_c2 * sp[55];
    sp[87] = w0_d1_c2 * sp[59];
    sp[88] = sp[86] + sp[87];
    sp[89] = w0_d2_c2 * sp[63];
    sp[90] = sp[88] + sp[89];
    sp[91] = sp[90] * sp[55];
    sp[92] = sp[90] * sp[59];
    sp[93] = sp[90] * sp[63];
    sp[94] = sp[91] + sp[91];
    sp[95] = sp[92] + sp[92];
    sp[96] = sp[93] + sp[93];
    sp[97] = sp[72] + sp[27];
    sp[98] = sp[73] + sp[28];
    sp[99] = sp[29] + sp[74];
    sp[100] = sp[83] + sp[38];
    sp[101] = sp[84] + sp[39];
    sp[102] = sp[40] + sp[85];
    sp[103] = sp[94] + sp[49];
    sp[104] = sp[95] + sp[50];
    sp[105] = sp[51] + sp[96];
    sp[106] = J_c1 * J_c5;
    sp[107] = J_c2 * J_c4;
    sp[108] = sp[106] + -1 * sp[107];
    sp[109] = sp[108] / sp[13];
    sp[110] = J_c2 * J_c3;
    sp[111] = J_c0 * J_c5;
    sp[112] = sp[110] + -1 * sp[111];
    sp[113] = sp[112] / sp[13];
    sp[114] = J_c0 * J_c4;
    sp[115] = J_c1 * J_c3;
    sp[116] = sp[114] + -1 * sp[115];
    sp[117] = sp[116] / sp[13];
    sp[118] = w0_d0_c0 * sp[109];
    sp[119] = w0_d1_c0 * sp[113];
    sp[120] = sp[118] + sp[119];
    sp[121] = w0_d2_c0 * sp[117];
    sp[122] = sp[120] + sp[121];
    sp[123] = sp[122] * sp[109];
    sp[124] = sp[122] * sp[113];
    sp[125] = sp[122] * sp[117];
    sp[126] = sp[123] + sp[123];
    sp[127] = sp[124] + sp[124];
    sp[128] = sp[125] + sp[125];
    sp[129] = w0_d0_c1 * sp[109];
    sp[130] = w0_d1_c1 * sp[113];
    sp[131] = sp[129] + sp[130];
    sp[132] = w0_d2_c1 * sp[117];
    sp[133] = sp[131] + sp[132];
    sp[134] = sp[133] * sp[109];
    sp[135] = sp[133] * sp[113];
    sp[136] = sp[133] * sp[117];
    sp[137] = sp[134] + sp[134];
    sp[138] = sp[135] + sp[135];
    sp[139] = sp[136] + sp[136];
    sp[140] = w0_d0_c2 * sp[109];
    sp[141] = w0_d1_c2 * sp[113];
    sp[142] = sp[140] + sp[141];
    sp[143] = w0_d2_c2 * sp[117];
    sp[144] = sp[142] + sp[143];
    sp[145] = (1 + sp[144]) * sp[109];
    sp[146] = (1 + sp[144]) * sp[113];
    sp[147] = (1 + sp[144]) * sp[117];
    sp[148] = sp[145] + sp[145];
    sp[149] = sp[146] + sp[146];
    sp[150] = sp[147] + sp[147];
    sp[151] = sp[97] + sp[126];
    sp[152] = sp[98] + sp[127];
    sp[153] = sp[99] + sp[128];
    sp[154] = sp[100] + sp[137];
    sp[155] = sp[101] + sp[138];
    sp[156] = sp[102] + sp[139];
    sp[157] = sp[103] + sp[148];
    sp[158] = sp[104] + sp[149];
    sp[159] = sp[105] + sp[150];
    sp[160] = sp[122] * sp[122];
    sp[161] = sp[133] * sp[133];
    sp[162] = sp[160] + sp[161];
    sp[163] = (1 + sp[144]) * (1 + sp[144]);
    sp[164] = sp[162] + sp[163];
    sp[165] = sp[164] * sp[72];
    sp[166] = sp[164] * sp[73];
    sp[167] = sp[164] * sp[74];
    sp[168] = sp[164] * sp[83];
    sp[169] = sp[164] * sp[84];
    sp[170] = sp[164] * sp[85];
    sp[171] = sp[164] * sp[94];
    sp[172] = sp[164] * sp[95];
    sp[173] = sp[164] * sp[96];
    sp[174] = (1 + sp[79]) * (1 + sp[79]);
    sp[175] = sp[68] * sp[68];
    sp[176] = sp[174] + sp[175];
    sp[177] = sp[90] * sp[90];
    sp[178] = sp[176] + sp[177];
    sp[179] = sp[178] * sp[126];
    sp[180] = sp[178] * sp[127];
    sp[181] = sp[178] * sp[128];
    sp[182] = sp[178] * sp[137];
    sp[183] = sp[178] * sp[138];
    sp[184] = sp[178] * sp[139];
    sp[185] = sp[178] * sp[148];
    sp[186] = sp[178] * sp[149];
    sp[187] = sp[178] * sp[150];
    sp[188] = sp[165] + sp[179];
    sp[189] = sp[166] + sp[180];
    sp[190] = sp[181] + sp[167];
    sp[191] = sp[168] + sp[182];
    sp[192] = sp[169] + sp[183];
    sp[193] = sp[184] + sp[170];
    sp[194] = sp[171] + sp[185];
    sp[195] = sp[172] + sp[186];
    sp[196] = sp[187] + sp[173];
    sp[197] = sp[122] * sp[55];
    sp[198] = sp[122] * sp[59];
    sp[199] = sp[122] * sp[63];
    sp[200] = sp[68] * sp[109];
    sp[201] = sp[68] * sp[113];
    sp[202] = sp[68] * sp[117];
    sp[203] = sp[197] + sp[200];
    sp[204] = sp[198] + sp[201];
    sp[205] = sp[202] + sp[199];
    sp[206] = (1 + sp[79]) * sp[109];
    sp[207] = (1 + sp[79]) * sp[113];
    sp[208] = (1 + sp[79]) * sp[117];
    sp[209] = sp[133] * sp[55];
    sp[210] = sp[133] * sp[59];
    sp[211] = sp[133] * sp[63];
    sp[212] = sp[209] + sp[206];
    sp[213] = sp[210] + sp[207];
    sp[214] = sp[208] + sp[211];
    sp[215] = (1 + sp[144]) * sp[55];
    sp[216] = (1 + sp[144]) * sp[59];
    sp[217] = (1 + sp[144]) * sp[63];
    sp[218] = sp[90] * sp[109];
    sp[219] = sp[90] * sp[113];
    sp[220] = sp[90] * sp[117];
    sp[221] = sp[215] + sp[218];
    sp[222] = sp[216] + sp[219];
    sp[223] = sp[220] + sp[217];
    sp[224] = (1 + sp[79]) * sp[133];
    sp[225] = sp[122] * sp[68];
    sp[226] = sp[224] + sp[225];
    sp[227] = (1 + sp[144]) * sp[90];
    sp[228] = sp[226] + sp[227];
    sp[229] = sp[228] * sp[203];
    sp[230] = sp[228] * sp[204];
    sp[231] = sp[228] * sp[205];
    sp[232] = sp[228] * sp[212];
    sp[233] = sp[228] * sp[213];
    sp[234] = sp[228] * sp[214];
    sp[235] = sp[228] * sp[221];
    sp[236] = sp[228] * sp[222];
    sp[237] = sp[228] * sp[223];
    sp[238] = sp[229] + sp[229];
    sp[239] = sp[230] + sp[230];
    sp[240] = sp[231] + sp[231];
    sp[241] = sp[232] + sp[232];
    sp[242] = sp[233] + sp[233];
    sp[243] = sp[234] + sp[234];
    sp[244] = sp[235] + sp[235];
    sp[245] = sp[236] + sp[236];
    sp[246] = sp[237] + sp[237];
    sp[247] = sp[188] + -1 * sp[238];
    sp[248] = sp[189] + -1 * sp[239];
    sp[249] = sp[190] + -1 * sp[240];
    sp[250] = sp[191] + -1 * sp[241];
    sp[251] = sp[192] + -1 * sp[242];
    sp[252] = sp[193] + -1 * sp[243];
    sp[253] = sp[194] + -1 * sp[244];
    sp[254] = sp[195] + -1 * sp[245];
    sp[255] = sp[196] + -1 * sp[246];
    sp[256] = (1 + sp[23]) * (1 + sp[23]);
    sp[257] = sp[34] * sp[34];
    sp[258] = sp[256] + sp[257];
    sp[259] = sp[45] * sp[45];
    sp[260] = sp[258] + sp[259];
    sp[261] = sp[247] * sp[260];
    sp[262] = sp[248] * sp[260];
    sp[263] = sp[249] * sp[260];
    sp[264] = sp[250] * sp[260];
    sp[265] = sp[251] * sp[260];
    sp[266] = sp[252] * sp[260];
    sp[267] = sp[253] * sp[260];
    sp[268] = sp[254] * sp[260];
    sp[269] = sp[255] * sp[260];
    sp[270] = sp[164] * sp[178];
    sp[271] = sp[228] * sp[228];
    sp[272] = sp[270] + -1 * sp[271];
    sp[273] = sp[272] * sp[27];
    sp[274] = sp[272] * sp[28];
    sp[275] = sp[272] * sp[29];
    sp[276] = sp[272] * sp[38];
    sp[277] = sp[272] * sp[39];
    sp[278] = sp[272] * sp[40];
    sp[279] = sp[272] * sp[49];
    sp[280] = sp[272] * sp[50];
    sp[281] = sp[272] * sp[51];
    sp[282] = sp[261] + sp[273];
    sp[283] = sp[262] + sp[274];
    sp[284] = sp[263] + sp[275];
    sp[285] = sp[264] + sp[276];
    sp[286] = sp[265] + sp[277];
    sp[287] = sp[266] + sp[278];
    sp[288] = sp[267] + sp[279];
    sp[289] = sp[268] + sp[280];
    sp[290] = sp[269] + sp[281];
    sp[291] = (1 + sp[23]) * sp[122];
    sp[292] = sp[133] * sp[34];
    sp[293] = sp[291] + sp[292];
    sp[294] = (1 + sp[144]) * sp[45];
    sp[295] = sp[293] + sp[294];
    sp[296] = sp[295] * sp[203];
    sp[297] = sp[295] * sp[204];
    sp[298] = sp[295] * sp[205];
    sp[299] = sp[295] * sp[212];
    sp[300] = sp[295] * sp[213];
    sp[301] = sp[295] * sp[214];
    sp[302] = sp[295] * sp[221];
    sp[303] = sp[295] * sp[222];
    sp[304] = sp[295] * sp[223];
    sp[305] = (1 + sp[23]) * sp[109];
    sp[306] = (1 + sp[23]) * sp[113];
    sp[307] = (1 + sp[23]) * sp[117];
    sp[308] = sp[122] * sp[14];
    sp[309] = sp[122] * sp[18];
    sp[310] = sp[122] * sp[21];
    sp[311] = sp[305] + sp[308];
    sp[312] = sp[306] + sp[309];
    sp[313] = sp[307] + sp[310];
    sp[314] = sp[133] * sp[14];
    sp[315] = sp[133] * sp[18];
    sp[316] = sp[133] * sp[21];
    sp[317] = sp[34] * sp[109];
    sp[318] = sp[34] * sp[113];
    sp[319] = sp[34] * sp[117];
    sp[320] = sp[317] + sp[314];
    sp[321] = sp[318] + sp[315];
    sp[322] = sp[319] + sp[316];
    sp[323] = (1 + sp[144]) * sp[14];
    sp[324] = (1 + sp[144]) * sp[18];
    sp[325] = (1 + sp[144]) * sp[21];
    sp[326] = sp[45] * sp[109];
    sp[327] = sp[45] * sp[113];
    sp[328] = sp[45] * sp[117];
    sp[329] = sp[326] + sp[323];
    sp[330] = sp[327] + sp[324];
    sp[331] = sp[328] + sp[325];
    sp[332] = sp[228] * sp[311];
    sp[333] = sp[228] * sp[312];
    sp[334] = sp[228] * sp[313];
    sp[335] = sp[228] * sp[320];
    sp[336] = sp[228] * sp[321];
    sp[337] = sp[228] * sp[322];
    sp[338] = sp[228] * sp[329];
    sp[339] = sp[228] * sp[330];
    sp[340] = sp[228] * sp[331];
    sp[341] = sp[296] + sp[332];
    sp[342] = sp[297] + sp[333];
    sp[343] = sp[334] + sp[298];
    sp[344] = sp[299] + sp[335];
    sp[345] = sp[300] + sp[336];
    sp[346] = sp[337] + sp[301];
    sp[347] = sp[302] + sp[338];
    sp[348] = sp[303] + sp[339];
    sp[349] = sp[340] + sp[304];
    sp[350] = (1 + sp[23]) * sp[55];
    sp[351] = (1 + sp[23]) * sp[59];
    sp[352] = (1 + sp[23]) * sp[63];
    sp[353] = sp[68] * sp[14];
    sp[354] = sp[68] * sp[18];
    sp[355] = sp[68] * sp[21];
    sp[356] = sp[350] + sp[353];
    sp[357] = sp[351] + sp[354];
    sp[358] = sp[355] + sp[352];
    sp[359] = (1 + sp[79]) * sp[14];
    sp[360] = (1 + sp[79]) * sp[18];
    sp[361] = (1 + sp[79]) * sp[21];
    sp[362] = sp[34] * sp[55];
    sp[363] = sp[34] * sp[59];
    sp[364] = sp[34] * sp[63];
    sp[365] = sp[362] + sp[359];
    sp[366] = sp[363] + sp[360];
    sp[367] = sp[361] + sp[364];
    sp[368] = sp[45] * sp[55];
    sp[369] = sp[45] * sp[59];
    sp[370] = sp[45] * sp[63];
    sp[371] = sp[90] * sp[14];
    sp[372] = sp[90] * sp[18];
    sp[373] = sp[90] * sp[21];
    sp[374] = sp[368] + sp[371];
    sp[375] = sp[369] + sp[372];
    sp[376] = sp[373] + sp[370];
    sp[377] = sp[164] * sp[356];
    sp[378] = sp[164] * sp[357];
    sp[379] = sp[164] * sp[358];
    sp[380] = sp[164] * sp[365];
    sp[381] = sp[164] * sp[366];
    sp[382] = sp[164] * sp[367];
    sp[383] = sp[164] * sp[374];
    sp[384] = sp[164] * sp[375];
    sp[385] = sp[164] * sp[376];
    sp[386] = (1 + sp[79]) * sp[34];
    sp[387] = (1 + sp[23]) * sp[68];
    sp[388] = sp[386] + sp[387];
    sp[389] = sp[45] * sp[90];
    sp[390] = sp[388] + sp[389];
    sp[391] = sp[390] * sp[126];
    sp[392] = sp[390] * sp[127];
    sp[393] = sp[390] * sp[128];
    sp[394] = sp[390] * sp[137];
    sp[395] = sp[390] * sp[138];
    sp[396] = sp[390] * sp[139];
    sp[397] = sp[390] * sp[148];
    sp[398] = sp[390] * sp[149];
    sp[399] = sp[390] * sp[150];
    sp[400] = sp[391] + sp[377];
    sp[401] = sp[392] + sp[378];
    sp[402] = sp[393] + sp[379];
    sp[403] = sp[394] + sp[380];
    sp[404] = sp[395] + sp[381];
    sp[405] = sp[396] + sp[382];
    sp[406] = sp[397] + sp[383];
    sp[407] = sp[398] + sp[384];
    sp[408] = sp[399] + sp[385];
    sp[409] = sp[341] + -1 * sp[400];
    sp[410] = sp[342] + -1 * sp[401];
    sp[411] = sp[343] + -1 * sp[402];
    sp[412] = sp[344] + -1 * sp[403];
    sp[413] = sp[345] + -1 * sp[404];
    sp[414] = sp[346] + -1 * sp[405];
    sp[415] = sp[347] + -1 * sp[406];
    sp[416] = sp[348] + -1 * sp[407];
    sp[417] = sp[349] + -1 * sp[408];
    sp[418] = sp[409] * sp[390];
    sp[419] = sp[410] * sp[390];
    sp[420] = sp[411] * sp[390];
    sp[421] = sp[412] * sp[390];
    sp[422] = sp[413] * sp[390];
    sp[423] = sp[414] * sp[390];
    sp[424] = sp[415] * sp[390];
    sp[425] = sp[416] * sp[390];
    sp[426] = sp[417] * sp[390];
    sp[427] = sp[295] * sp[228];
    sp[428] = sp[164] * sp[390];
    sp[429] = sp[427] + -1 * sp[428];
    sp[430] = sp[429] * sp[356];
    sp[431] = sp[429] * sp[357];
    sp[432] = sp[429] * sp[358];
    sp[433] = sp[429] * sp[365];
    sp[434] = sp[429] * sp[366];
    sp[435] = sp[429] * sp[367];
    sp[436] = sp[429] * sp[374];
    sp[437] = sp[429] * sp[375];
    sp[438] = sp[429] * sp[376];
    sp[439] = sp[418] + sp[430];
    sp[440] = sp[419] + sp[431];
    sp[441] = sp[420] + sp[432];
    sp[442] = sp[421] + sp[433];
    sp[443] = sp[422] + sp[434];
    sp[444] = sp[423] + sp[435];
    sp[445] = sp[424] + sp[436];
    sp[446] = sp[425] + sp[437];
    sp[447] = sp[426] + sp[438];
    sp[448] = sp[282] + sp[439];
    sp[449] = sp[283] + sp[440];
    sp[450] = sp[284] + sp[441];
    sp[451] = sp[442] + sp[285];
    sp[452] = sp[443] + sp[286];
    sp[453] = sp[287] + sp[444];
    sp[454] = sp[288] + sp[445];
    sp[455] = sp[289] + sp[446];
    sp[456] = sp[290] + sp[447];
    sp[457] = sp[228] * sp[356];
    sp[458] = sp[228] * sp[357];
    sp[459] = sp[228] * sp[358];
    sp[460] = sp[228] * sp[365];
    sp[461] = sp[228] * sp[366];
    sp[462] = sp[228] * sp[367];
    sp[463] = sp[228] * sp[374];
    sp[464] = sp[228] * sp[375];
    sp[465] = sp[228] * sp[376];
    sp[466] = sp[390] * sp[203];
    sp[467] = sp[390] * sp[204];
    sp[468] = sp[390] * sp[205];
    sp[469] = sp[390] * sp[212];
    sp[470] = sp[390] * sp[213];
    sp[471] = sp[390] * sp[214];
    sp[472] = sp[390] * sp[221];
    sp[473] = sp[390] * sp[222];
    sp[474] = sp[390] * sp[223];
    sp[475] = sp[466] + sp[457];
    sp[476] = sp[467] + sp[458];
    sp[477] = sp[459] + sp[468];
    sp[478] = sp[469] + sp[460];
    sp[479] = sp[470] + sp[461];
    sp[480] = sp[471] + sp[462];
    sp[481] = sp[472] + sp[463];
    sp[482] = sp[473] + sp[464];
    sp[483] = sp[474] + sp[465];
    sp[484] = sp[295] * sp[72];
    sp[485] = sp[295] * sp[73];
    sp[486] = sp[295] * sp[74];
    sp[487] = sp[295] * sp[83];
    sp[488] = sp[295] * sp[84];
    sp[489] = sp[295] * sp[85];
    sp[490] = sp[295] * sp[94];
    sp[491] = sp[295] * sp[95];
    sp[492] = sp[295] * sp[96];
    sp[493] = sp[178] * sp[311];
    sp[494] = sp[178] * sp[312];
    sp[495] = sp[178] * sp[313];
    sp[496] = sp[178] * sp[320];
    sp[497] = sp[178] * sp[321];
    sp[498] = sp[178] * sp[322];
    sp[499] = sp[178] * sp[329];
    sp[500] = sp[178] * sp[330];
    sp[501] = sp[178] * sp[331];
    sp[502] = sp[484] + sp[493];
    sp[503] = sp[485] + sp[494];
    sp[504] = sp[495] + sp[486];
    sp[505] = sp[487] + sp[496];
    sp[506] = sp[488] + sp[497];
    sp[507] = sp[498] + sp[489];
    sp[508] = sp[490] + sp[499];
    sp[509] = sp[491] + sp[500];
    sp[510] = sp[501] + sp[492];
    sp[511] = sp[475] + -1 * sp[502];
    sp[512] = sp[476] + -1 * sp[503];
    sp[513] = sp[477] + -1 * sp[504];
    sp[514] = sp[478] + -1 * sp[505];
    sp[515] = sp[479] + -1 * sp[506];
    sp[516] = sp[480] + -1 * sp[507];
    sp[517] = sp[481] + -1 * sp[508];
    sp[518] = sp[482] + -1 * sp[509];
    sp[519] = sp[483] + -1 * sp[510];
    sp[520] = sp[511] * sp[295];
    sp[521] = sp[512] * sp[295];
    sp[522] = sp[513] * sp[295];
    sp[523] = sp[514] * sp[295];
    sp[524] = sp[515] * sp[295];
    sp[525] = sp[516] * sp[295];
    sp[526] = sp[517] * sp[295];
    sp[527] = sp[518] * sp[295];
    sp[528] = sp[519] * sp[295];
    sp[529] = sp[228] * sp[390];
    sp[530] = sp[295] * sp[178];
    sp[531] = sp[529] + -1 * sp[530];
    sp[532] = sp[531] * sp[311];
    sp[533] = sp[531] * sp[312];
    sp[534] = sp[531] * sp[313];
    sp[535] = sp[531] * sp[320];
    sp[536] = sp[531] * sp[321];
    sp[537] = sp[531] * sp[322];
    sp[538] = sp[531] * sp[329];
    sp[539] = sp[531] * sp[330];
    sp[540] = sp[531] * sp[331];
    sp[541] = sp[520] + sp[532];
    sp[542] = sp[521] + sp[533];
    sp[543] = sp[522] + sp[534];
    sp[544] = sp[523] + sp[535];
    sp[545] = sp[524] + sp[536];
    sp[546] = sp[525] + sp[537];
    sp[547] = sp[526] + sp[538];
    sp[548] = sp[527] + sp[539];
    sp[549] = sp[528] + sp[540];
    sp[550] = sp[448] + sp[541];
    sp[551] = sp[449] + sp[542];
    sp[552] = sp[450] + sp[543];
    sp[553] = sp[451] + sp[544];
    sp[554] = sp[452] + sp[545];
    sp[555] = sp[453] + sp[546];
    sp[556] = sp[454] + sp[547];
    sp[557] = sp[455] + sp[548];
    sp[558] = sp[456] + sp[549];
    sp[559] = sp[260] * sp[272];
    sp[560] = sp[390] * sp[429];
    sp[561] = sp[559] + sp[560];
    sp[562] = sp[295] * sp[531];
    sp[563] = sp[561] + sp[562];
    sp[564] = 0.3333333333333333 * sp[550] * std::pow(sp[563], -0.6666666666666667);
    sp[565] = 0.3333333333333333 * sp[551] * std::pow(sp[563], -0.6666666666666667);
    sp[566] = 0.3333333333333333 * sp[552] * std::pow(sp[563], -0.6666666666666667);
    sp[567] = 0.3333333333333333 * sp[553] * std::pow(sp[563], -0.6666666666666667);
    sp[568] = 0.3333333333333333 * sp[554] * std::pow(sp[563], -0.6666666666666667);
    sp[569] = 0.3333333333333333 * sp[555] * std::pow(sp[563], -0.6666666666666667);
    sp[570] = 0.3333333333333333 * sp[556] * std::pow(sp[563], -0.6666666666666667);
    sp[571] = 0.3333333333333333 * sp[557] * std::pow(sp[563], -0.6666666666666667);
    sp[572] = 0.3333333333333333 * sp[558] * std::pow(sp[563], -0.6666666666666667);
    sp[573] = sp[260] + sp[178];
    sp[574] = sp[573] + sp[164];
    sp[575] = sp[574] / std::pow(sp[563], 0.3333333333333333);
    sp[576] = sp[564] * sp[575];
    sp[577] = sp[565] * sp[575];
    sp[578] = sp[566] * sp[575];
    sp[579] = sp[567] * sp[575];
    sp[580] = sp[568] * sp[575];
    sp[581] = sp[569] * sp[575];
    sp[582] = sp[570] * sp[575];
    sp[583] = sp[571] * sp[575];
    sp[584] = sp[572] * sp[575];
    sp[585] = sp[151] + -1 * sp[576];
    sp[586] = sp[152] + -1 * sp[577];
    sp[587] = sp[153] + -1 * sp[578];
    sp[588] = sp[154] + -1 * sp[579];
    sp[589] = sp[155] + -1 * sp[580];
    sp[590] = sp[156] + -1 * sp[581];
    sp[591] = sp[157] + -1 * sp[582];
    sp[592] = sp[158] + -1 * sp[583];
    sp[593] = sp[159] + -1 * sp[584];
    sp[594] = sp[585] / std::pow(sp[563], 0.3333333333333333);
    sp[595] = sp[586] / std::pow(sp[563], 0.3333333333333333);
    sp[596] = sp[587] / std::pow(sp[563], 0.3333333333333333);
    sp[597] = sp[588] / std::pow(sp[563], 0.3333333333333333);
    sp[598] = sp[589] / std::pow(sp[563], 0.3333333333333333);
    sp[599] = sp[590] / std::pow(sp[563], 0.3333333333333333);
    sp[600] = sp[591] / std::pow(sp[563], 0.3333333333333333);
    sp[601] = sp[592] / std::pow(sp[563], 0.3333333333333333);
    sp[602] = sp[593] / std::pow(sp[563], 0.3333333333333333);
    sp[603] = sp[594] * w[3][0];
    sp[604] = sp[595] * w[3][0];
    sp[605] = sp[596] * w[3][0];
    sp[606] = sp[597] * w[3][0];
    sp[607] = sp[598] * w[3][0];
    sp[608] = sp[599] * w[3][0];
    sp[609] = sp[600] * w[3][0];
    sp[610] = sp[601] * w[3][0];
    sp[611] = sp[602] * w[3][0];
    sp[612] = sp[550] * w[5][0];
    sp[613] = sp[551] * w[5][0];
    sp[614] = sp[552] * w[5][0];
    sp[615] = sp[553] * w[5][0];
    sp[616] = sp[554] * w[5][0];
    sp[617] = sp[555] * w[5][0];
    sp[618] = sp[556] * w[5][0];
    sp[619] = sp[557] * w[5][0];
    sp[620] = sp[558] * w[5][0];
    sp[621] = std::pow(sp[563], -1 + w[5][0]);
    sp[622] = sp[612] * sp[621];
    sp[623] = sp[613] * sp[621];
    sp[624] = sp[614] * sp[621];
    sp[625] = sp[615] * sp[621];
    sp[626] = sp[616] * sp[621];
    sp[627] = sp[617] * sp[621];
    sp[628] = sp[618] * sp[621];
    sp[629] = sp[619] * sp[621];
    sp[630] = sp[620] * sp[621];
    sp[631] = std::pow(sp[563], w[5][0]);
    sp[632] = sp[622] * (1.0 / sp[631]);
    sp[633] = sp[623] * (1.0 / sp[631]);
    sp[634] = sp[624] * (1.0 / sp[631]);
    sp[635] = sp[625] * (1.0 / sp[631]);
    sp[636] = sp[626] * (1.0 / sp[631]);
    sp[637] = sp[627] * (1.0 / sp[631]);
    sp[638] = sp[628] * (1.0 / sp[631]);
    sp[639] = sp[629] * (1.0 / sp[631]);
    sp[640] = sp[630] * (1.0 / sp[631]);
    sp[641] = -1 * sp[632] / sp[631];
    sp[642] = -1 * sp[633] / sp[631];
    sp[643] = -1 * sp[634] / sp[631];
    sp[644] = -1 * sp[635] / sp[631];
    sp[645] = -1 * sp[636] / sp[631];
    sp[646] = -1 * sp[637] / sp[631];
    sp[647] = -1 * sp[638] / sp[631];
    sp[648] = -1 * sp[639] / sp[631];
    sp[649] = -1 * sp[640] / sp[631];
    sp[650] = sp[622] + sp[641];
    sp[651] = sp[623] + sp[642];
    sp[652] = sp[624] + sp[643];
    sp[653] = sp[625] + sp[644];
    sp[654] = sp[626] + sp[645];
    sp[655] = sp[627] + sp[646];
    sp[656] = sp[628] + sp[647];
    sp[657] = sp[629] + sp[648];
    sp[658] = sp[630] + sp[649];
    sp[659] = sp[650] * w[4][0];
    sp[660] = sp[651] * w[4][0];
    sp[661] = sp[652] * w[4][0];
    sp[662] = sp[653] * w[4][0];
    sp[663] = sp[654] * w[4][0];
    sp[664] = sp[655] * w[4][0];
    sp[665] = sp[656] * w[4][0];
    sp[666] = sp[657] * w[4][0];
    sp[667] = sp[658] * w[4][0];
    sp[668] = sp[603] + sp[659];
    sp[669] = sp[604] + sp[660];
    sp[670] = sp[605] + sp[661];
    sp[671] = sp[606] + sp[662];
    sp[672] = sp[607] + sp[663];
    sp[673] = sp[608] + sp[664];
    sp[674] = sp[609] + sp[665];
    sp[675] = sp[610] + sp[666];
    sp[676] = sp[611] + sp[667];
    sp[677] = std::abs(sp[13]);
    sp[678] = sp[668] * sp[677];
    sp[679] = sp[669] * sp[677];
    sp[680] = sp[670] * sp[677];
    sp[681] = sp[671] * sp[677];
    sp[682] = sp[672] * sp[677];
    sp[683] = sp[673] * sp[677];
    sp[684] = sp[674] * sp[677];
    sp[685] = sp[675] * sp[677];
    sp[686] = sp[676] * sp[677];
    sp[687] = -1 * w[1][0] * sp[677];
    sp[688] = -1 * w[1][1] * sp[677];
    sp[689] = -1 * w[1][2] * sp[677];
    A[0] = -0.1666666666666667 * sp[678] + 0.04166666666666667 * sp[687] + -0.1666666666666667 * sp[679] + -0.1666666666666667 * sp[680];
    A[1] = 0.1666666666666667 * sp[678] + 0.04166666666666666 * sp[687];
    A[2] = 0.04166666666666666 * sp[687] + 0.1666666666666667 * sp[679];
    A[3] = 0.04166666666666666 * sp[687] + 0.1666666666666667 * sp[680];
    A[4] = -0.1666666666666667 * sp[681] + 0.04166666666666667 * sp[688] + -0.1666666666666667 * sp[682] + -0.1666666666666667 * sp[683];
    A[5] = 0.1666666666666667 * sp[681] + 0.04166666666666666 * sp[688];
    A[6] = 0.04166666666666666 * sp[688] + 0.1666666666666667 * sp[682];
    A[7] = 0.04166666666666666 * sp[688] + 0.1666666666666667 * sp[683];
    A[8] = -0.1666666666666667 * sp[684] + 0.04166666666666667 * sp[689] + -0.1666666666666667 * sp[685] + -0.1666666666666667 * sp[686];
    A[9] = 0.1666666666666667 * sp[684] + 0.04166666666666666 * sp[689];
    A[10] = 0.04166666666666666 * sp[689] + 0.1666666666666667 * sp[685];
    A[11] = 0.04166666666666666 * sp[689] + 0.1666666666666667 * sp[686];
}


hyperelasticitybiso_exterior_facet_integral_1_3::hyperelasticitybiso_exterior_facet_integral_1_3() : ufc::exterior_facet_integral()
{

}

hyperelasticitybiso_exterior_facet_integral_1_3::~hyperelasticitybiso_exterior_facet_integral_1_3()
{

}

const std::vector<bool> & hyperelasticitybiso_exterior_facet_integral_1_3::enabled_coefficients() const
{
static const std::vector<bool> enabled({false, false, true, false, false, false});
return enabled;
}

void hyperelasticitybiso_exterior_facet_integral_1_3::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 1
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 1
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           1
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE15_C0_D001_F_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[4][4] =
        { { 0.0, 0.1666666666666666, 0.1666666666666667, 0.1666666666666667 },
          { 0.1666666666666667, 0.0, 0.1666666666666667, 0.1666666666666667 },
          { 0.1666666666666667, 0.1666666666666667, 0.0, 0.1666666666666667 },
          { 0.1666666666666667, 0.1666666666666666, 0.1666666666666667, 0.0 } };
    // Unstructured piecewise computations
    const double J_c3 = coordinate_dofs[1] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[4] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c4 = coordinate_dofs[1] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[7] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[10] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[5] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[8] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[11] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[3] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[6] * FE15_C0_D001_F_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE15_C0_D001_F_Q1[0][0][0] + coordinate_dofs[9] * FE15_C0_D001_F_Q1[0][0][1];
    alignas(32) double sp[48];
    sp[0] = tetrahedron_reference_facet_jacobian[facet][0][0] * J_c3;
    sp[1] = tetrahedron_reference_facet_jacobian[facet][1][0] * J_c4;
    sp[2] = sp[0] + sp[1];
    sp[3] = J_c5 * tetrahedron_reference_facet_jacobian[facet][2][0];
    sp[4] = sp[2] + sp[3];
    sp[5] = tetrahedron_reference_facet_jacobian[facet][0][1] * J_c6;
    sp[6] = tetrahedron_reference_facet_jacobian[facet][1][1] * J_c7;
    sp[7] = sp[5] + sp[6];
    sp[8] = tetrahedron_reference_facet_jacobian[facet][2][1] * J_c8;
    sp[9] = sp[7] + sp[8];
    sp[10] = sp[4] * sp[9];
    sp[11] = tetrahedron_reference_facet_jacobian[facet][0][1] * J_c3;
    sp[12] = J_c4 * tetrahedron_reference_facet_jacobian[facet][1][1];
    sp[13] = sp[11] + sp[12];
    sp[14] = J_c5 * tetrahedron_reference_facet_jacobian[facet][2][1];
    sp[15] = sp[13] + sp[14];
    sp[16] = tetrahedron_reference_facet_jacobian[facet][0][0] * J_c6;
    sp[17] = tetrahedron_reference_facet_jacobian[facet][1][0] * J_c7;
    sp[18] = sp[16] + sp[17];
    sp[19] = tetrahedron_reference_facet_jacobian[facet][2][0] * J_c8;
    sp[20] = sp[18] + sp[19];
    sp[21] = sp[15] * sp[20];
    sp[22] = sp[10] + -1 * sp[21];
    sp[23] = sp[22] * sp[22];
    sp[24] = J_c0 * tetrahedron_reference_facet_jacobian[facet][0][1];
    sp[25] = J_c1 * tetrahedron_reference_facet_jacobian[facet][1][1];
    sp[26] = sp[24] + sp[25];
    sp[27] = J_c2 * tetrahedron_reference_facet_jacobian[facet][2][1];
    sp[28] = sp[26] + sp[27];
    sp[29] = sp[28] * sp[20];
    sp[30] = J_c0 * tetrahedron_reference_facet_jacobian[facet][0][0];
    sp[31] = J_c1 * tetrahedron_reference_facet_jacobian[facet][1][0];
    sp[32] = sp[30] + sp[31];
    sp[33] = J_c2 * tetrahedron_reference_facet_jacobian[facet][2][0];
    sp[34] = sp[32] + sp[33];
    sp[35] = sp[34] * sp[9];
    sp[36] = sp[29] + -1 * sp[35];
    sp[37] = sp[36] * sp[36];
    sp[38] = sp[23] + sp[37];
    sp[39] = sp[34] * sp[15];
    sp[40] = sp[4] * sp[28];
    sp[41] = sp[39] + -1 * sp[40];
    sp[42] = sp[41] * sp[41];
    sp[43] = sp[38] + sp[42];
    sp[44] = std::sqrt(sp[43]);
    sp[45] = -1 * w[2][0] * sp[44];
    sp[46] = -1 * w[2][1] * sp[44];
    sp[47] = -1 * w[2][2] * sp[44];
    A[0] = sp[45] * PI0[facet][0];
    A[1] = sp[45] * PI0[facet][1];
    A[2] = sp[45] * PI0[facet][2];
    A[3] = sp[45] * PI0[facet][3];
    A[4] = sp[46] * PI0[facet][0];
    A[5] = sp[46] * PI0[facet][1];
    A[6] = sp[46] * PI0[facet][2];
    A[7] = sp[46] * PI0[facet][3];
    A[8] = sp[47] * PI0[facet][0];
    A[9] = sp[47] * PI0[facet][1];
    A[10] = sp[47] * PI0[facet][2];
    A[11] = sp[47] * PI0[facet][3];
}


hyperelasticitybiso_cell_integral_2_otherwise::hyperelasticitybiso_cell_integral_2_otherwise() : ufc::cell_integral()
{

}

hyperelasticitybiso_cell_integral_2_otherwise::~hyperelasticitybiso_cell_integral_2_otherwise()
{

}

const std::vector<bool> & hyperelasticitybiso_cell_integral_2_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void hyperelasticitybiso_cell_integral_2_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 1
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 0
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           1
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE8_C0_D001_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[3] * FE8_C0_D001_Q1[0][0][1];
    const double J_c4 = coordinate_dofs[1] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[7] * FE8_C0_D001_Q1[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[11] * FE8_C0_D001_Q1[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[10] * FE8_C0_D001_Q1[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[8] * FE8_C0_D001_Q1[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[6] * FE8_C0_D001_Q1[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[5] * FE8_C0_D001_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[4] * FE8_C0_D001_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE8_C0_D001_Q1[0][0][0] + coordinate_dofs[9] * FE8_C0_D001_Q1[0][0][1];
    alignas(32) double sp[15];
    sp[0] = J_c4 * J_c8;
    sp[1] = J_c5 * J_c7;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 * sp[2];
    sp[4] = J_c5 * J_c6;
    sp[5] = J_c3 * J_c8;
    sp[6] = sp[4] + -1 * sp[5];
    sp[7] = J_c1 * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = J_c3 * J_c7;
    sp[10] = J_c4 * J_c6;
    sp[11] = sp[9] + -1 * sp[10];
    sp[12] = J_c2 * sp[11];
    sp[13] = sp[8] + sp[12];
    sp[14] = std::abs(sp[13]);
    A[0] = 0.1666666666666667 * sp[14];
}


hyperelasticitybiso_cell_integral_3_otherwise::hyperelasticitybiso_cell_integral_3_otherwise() : ufc::cell_integral()
{

}

hyperelasticitybiso_cell_integral_3_otherwise::~hyperelasticitybiso_cell_integral_3_otherwise()
{

}

const std::vector<bool> & hyperelasticitybiso_cell_integral_3_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true});
return enabled;
}

void hyperelasticitybiso_cell_integral_3_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 1
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 0
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           1
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE17_C0_D001_Q1[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE17_C0_D001_Q1[0][0][ic];
    const double J_c1 = coordinate_dofs[0] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[6] * FE17_C0_D001_Q1[0][0][1];
    const double J_c5 = coordinate_dofs[1] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[10] * FE17_C0_D001_Q1[0][0][1];
    const double J_c2 = coordinate_dofs[0] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[9] * FE17_C0_D001_Q1[0][0][1];
    const double J_c4 = coordinate_dofs[1] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[7] * FE17_C0_D001_Q1[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[3] * FE17_C0_D001_Q1[0][0][1];
    const double J_c8 = coordinate_dofs[2] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[11] * FE17_C0_D001_Q1[0][0][1];
    const double J_c7 = coordinate_dofs[2] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[8] * FE17_C0_D001_Q1[0][0][1];
    const double J_c6 = coordinate_dofs[2] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[5] * FE17_C0_D001_Q1[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE17_C0_D001_Q1[0][0][0] + coordinate_dofs[4] * FE17_C0_D001_Q1[0][0][1];
    const double w0_d1_c0 = w[0][0] * FE17_C0_D001_Q1[0][0][0] + w[0][2] * FE17_C0_D001_Q1[0][0][1];
    const double w0_d2_c0 = w[0][0] * FE17_C0_D001_Q1[0][0][0] + w[0][3] * FE17_C0_D001_Q1[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 4] * FE17_C0_D001_Q1[0][0][ic];
    const double w0_d1_c1 = w[0][4] * FE17_C0_D001_Q1[0][0][0] + w[0][6] * FE17_C0_D001_Q1[0][0][1];
    const double w0_d2_c1 = w[0][4] * FE17_C0_D001_Q1[0][0][0] + w[0][7] * FE17_C0_D001_Q1[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 8] * FE17_C0_D001_Q1[0][0][ic];
    const double w0_d1_c2 = w[0][8] * FE17_C0_D001_Q1[0][0][0] + w[0][10] * FE17_C0_D001_Q1[0][0][1];
    const double w0_d2_c2 = w[0][8] * FE17_C0_D001_Q1[0][0][0] + w[0][11] * FE17_C0_D001_Q1[0][0][1];
    alignas(32) double sp[350];
    sp[0] = J_c1 * J_c5;
    sp[1] = J_c2 * J_c4;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c4 * J_c8;
    sp[4] = J_c5 * J_c7;
    sp[5] = sp[3] + -1 * sp[4];
    sp[6] = J_c0 * sp[5];
    sp[7] = J_c5 * J_c6;
    sp[8] = J_c3 * J_c8;
    sp[9] = sp[7] + -1 * sp[8];
    sp[10] = J_c1 * sp[9];
    sp[11] = sp[6] + sp[10];
    sp[12] = J_c3 * J_c7;
    sp[13] = J_c4 * J_c6;
    sp[14] = sp[12] + -1 * sp[13];
    sp[15] = J_c2 * sp[14];
    sp[16] = sp[11] + sp[15];
    sp[17] = sp[2] / sp[16];
    sp[18] = w0_d0_c0 * sp[17];
    sp[19] = J_c2 * J_c3;
    sp[20] = J_c0 * J_c5;
    sp[21] = sp[19] + -1 * sp[20];
    sp[22] = sp[21] / sp[16];
    sp[23] = w0_d1_c0 * sp[22];
    sp[24] = sp[18] + sp[23];
    sp[25] = J_c0 * J_c4;
    sp[26] = J_c1 * J_c3;
    sp[27] = sp[25] + -1 * sp[26];
    sp[28] = sp[27] / sp[16];
    sp[29] = w0_d2_c0 * sp[28];
    sp[30] = sp[24] + sp[29];
    sp[31] = sp[30] * sp[30];
    sp[32] = w0_d0_c1 * sp[17];
    sp[33] = w0_d1_c1 * sp[22];
    sp[34] = sp[32] + sp[33];
    sp[35] = w0_d2_c1 * sp[28];
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * sp[36];
    sp[38] = sp[31] + sp[37];
    sp[39] = w0_d0_c2 * sp[17];
    sp[40] = w0_d1_c2 * sp[22];
    sp[41] = sp[39] + sp[40];
    sp[42] = w0_d2_c2 * sp[28];
    sp[43] = sp[41] + sp[42];
    sp[44] = (1 + sp[43]) * (1 + sp[43]);
    sp[45] = sp[38] + sp[44];
    sp[46] = J_c2 * J_c7;
    sp[47] = J_c8 * (-1 * J_c1);
    sp[48] = sp[46] + sp[47];
    sp[49] = sp[48] / sp[16];
    sp[50] = w0_d0_c1 * sp[49];
    sp[51] = J_c0 * J_c8;
    sp[52] = J_c6 * (-1 * J_c2);
    sp[53] = sp[51] + sp[52];
    sp[54] = sp[53] / sp[16];
    sp[55] = w0_d1_c1 * sp[54];
    sp[56] = sp[50] + sp[55];
    sp[57] = J_c1 * J_c6;
    sp[58] = J_c0 * J_c7;
    sp[59] = sp[57] + -1 * sp[58];
    sp[60] = sp[59] / sp[16];
    sp[61] = w0_d2_c1 * sp[60];
    sp[62] = sp[56] + sp[61];
    sp[63] = (1 + sp[62]) * (1 + sp[62]);
    sp[64] = w0_d0_c0 * sp[49];
    sp[65] = w0_d1_c0 * sp[54];
    sp[66] = sp[64] + sp[65];
    sp[67] = w0_d2_c0 * sp[60];
    sp[68] = sp[66] + sp[67];
    sp[69] = sp[68] * sp[68];
    sp[70] = sp[63] + sp[69];
    sp[71] = w0_d0_c2 * sp[49];
    sp[72] = w0_d1_c2 * sp[54];
    sp[73] = sp[71] + sp[72];
    sp[74] = w0_d2_c2 * sp[60];
    sp[75] = sp[73] + sp[74];
    sp[76] = sp[75] * sp[75];
    sp[77] = sp[70] + sp[76];
    sp[78] = sp[45] * sp[77];
    sp[79] = (1 + sp[62]) * sp[36];
    sp[80] = sp[30] * sp[68];
    sp[81] = sp[79] + sp[80];
    sp[82] = (1 + sp[43]) * sp[75];
    sp[83] = sp[81] + sp[82];
    sp[84] = sp[83] * sp[83];
    sp[85] = sp[78] + -1 * sp[84];
    sp[86] = sp[5] / sp[16];
    sp[87] = w0_d0_c0 * sp[86];
    sp[88] = J_c3 * (-1 * J_c8);
    sp[89] = sp[7] + sp[88];
    sp[90] = sp[89] / sp[16];
    sp[91] = w0_d1_c0 * sp[90];
    sp[92] = sp[87] + sp[91];
    sp[93] = sp[14] / sp[16];
    sp[94] = w0_d2_c0 * sp[93];
    sp[95] = sp[92] + sp[94];
    sp[96] = (1 + sp[95]) * (1 + sp[95]);
    sp[97] = w0_d0_c1 * sp[86];
    sp[98] = w0_d1_c1 * sp[90];
    sp[99] = sp[97] + sp[98];
    sp[100] = w0_d2_c1 * sp[93];
    sp[101] = sp[99] + sp[100];
    sp[102] = sp[101] * sp[101];
    sp[103] = sp[96] + sp[102];
    sp[104] = w0_d0_c2 * sp[86];
    sp[105] = w0_d1_c2 * sp[90];
    sp[106] = sp[104] + sp[105];
    sp[107] = w0_d2_c2 * sp[93];
    sp[108] = sp[106] + sp[107];
    sp[109] = sp[108] * sp[108];
    sp[110] = sp[103] + sp[109];
    sp[111] = sp[110] * sp[85];
    sp[112] = (1 + sp[62]) * sp[101];
    sp[113] = (1 + sp[95]) * sp[68];
    sp[114] = sp[112] + sp[113];
    sp[115] = sp[108] * sp[75];
    sp[116] = sp[114] + sp[115];
    sp[117] = (1 + sp[95]) * sp[30];
    sp[118] = sp[36] * sp[101];
    sp[119] = sp[117] + sp[118];
    sp[120] = (1 + sp[43]) * sp[108];
    sp[121] = sp[119] + sp[120];
    sp[122] = sp[121] * sp[83];
    sp[123] = sp[45] * sp[116];
    sp[124] = sp[122] + -1 * sp[123];
    sp[125] = sp[116] * sp[124];
    sp[126] = sp[111] + sp[125];
    sp[127] = sp[83] * sp[116];
    sp[128] = sp[121] * sp[77];
    sp[129] = sp[127] + -1 * sp[128];
    sp[130] = sp[121] * sp[129];
    sp[131] = sp[126] + sp[130];
    sp[132] = 0.3333333333333333 * sp[85] * std::pow(sp[131], -0.6666666666666667);
    sp[133] = sp[110] + sp[77];
    sp[134] = sp[133] + sp[45];
    sp[135] = sp[134] / std::pow(sp[131], 0.3333333333333333);
    sp[136] = sp[132] * sp[135];
    sp[137] = (1 + -1 * sp[136]) / std::pow(sp[131], 0.3333333333333333);
    sp[138] = sp[137] * w[1][0];
    sp[139] = sp[85] * w[3][0];
    sp[140] = std::pow(sp[131], -1 + w[3][0]);
    sp[141] = sp[139] * sp[140];
    sp[142] = std::pow(sp[131], w[3][0]);
    sp[143] = sp[141] * (1.0 / sp[142]);
    sp[144] = -1 * sp[143] / sp[142];
    sp[145] = sp[141] + sp[144];
    sp[146] = sp[145] * w[2][0];
    sp[147] = sp[138] + sp[146];
    sp[148] = (1 + sp[43]) * (1 + sp[62]);
    sp[149] = sp[36] * sp[75];
    sp[150] = sp[148] + -1 * sp[149];
    sp[151] = (1 + sp[95]) * sp[150];
    sp[152] = sp[36] * sp[108];
    sp[153] = (1 + sp[43]) * sp[101];
    sp[154] = sp[152] + -1 * sp[153];
    sp[155] = sp[154] * sp[68];
    sp[156] = sp[151] + sp[155];
    sp[157] = sp[101] * sp[75];
    sp[158] = (1 + sp[62]) * sp[108];
    sp[159] = sp[157] + -1 * sp[158];
    sp[160] = sp[159] * sp[30];
    sp[161] = sp[156] + sp[160];
    sp[162] = sp[108] * (1.0 / sp[161]);
    sp[163] = sp[147] * sp[162];
    sp[164] = sp[116] * (-1 * sp[45]);
    sp[165] = sp[122] + sp[164];
    sp[166] = 0.3333333333333333 * sp[165] * std::pow(sp[131], -0.6666666666666667);
    sp[167] = sp[166] * sp[135];
    sp[168] = -1 * sp[167] / std::pow(sp[131], 0.3333333333333333);
    sp[169] = sp[168] * w[1][0];
    sp[170] = sp[165] * w[3][0];
    sp[171] = sp[170] * sp[140];
    sp[172] = sp[171] * (1.0 / sp[142]);
    sp[173] = -1 * sp[172] / sp[142];
    sp[174] = sp[171] + sp[173];
    sp[175] = sp[174] * w[2][0];
    sp[176] = sp[169] + sp[175];
    sp[177] = sp[75] * (1.0 / sp[161]);
    sp[178] = sp[176] * sp[177];
    sp[179] = sp[163] + sp[178];
    sp[180] = sp[121] * (-1 * sp[77]);
    sp[181] = sp[127] + sp[180];
    sp[182] = 0.3333333333333333 * sp[181] * std::pow(sp[131], -0.6666666666666667);
    sp[183] = sp[182] * sp[135];
    sp[184] = -1 * sp[183] / std::pow(sp[131], 0.3333333333333333);
    sp[185] = sp[184] * w[1][0];
    sp[186] = sp[181] * w[3][0];
    sp[187] = sp[186] * sp[140];
    sp[188] = sp[187] * (1.0 / sp[142]);
    sp[189] = -1 * sp[188] / sp[142];
    sp[190] = sp[187] + sp[189];
    sp[191] = sp[190] * w[2][0];
    sp[192] = sp[185] + sp[191];
    sp[193] = (1 + sp[43]) * (1.0 / sp[161]);
    sp[194] = sp[192] * sp[193];
    sp[195] = sp[179] + sp[194];
    sp[196] = sp[195] * sp[108];
    sp[197] = 0.3333333333333333 * sp[124] * std::pow(sp[131], -0.6666666666666667);
    sp[198] = sp[197] * sp[135];
    sp[199] = -1 * sp[198] / std::pow(sp[131], 0.3333333333333333);
    sp[200] = sp[199] * w[1][0];
    sp[201] = sp[124] * w[3][0];
    sp[202] = sp[201] * sp[140];
    sp[203] = sp[202] * (1.0 / sp[142]);
    sp[204] = -1 * sp[203] / sp[142];
    sp[205] = sp[202] + sp[204];
    sp[206] = sp[205] * w[2][0];
    sp[207] = sp[200] + sp[206];
    sp[208] = sp[207] * sp[162];
    sp[209] = sp[45] * sp[110];
    sp[210] = sp[121] * (-1 * sp[121]);
    sp[211] = sp[209] + sp[210];
    sp[212] = 0.3333333333333333 * sp[211] * std::pow(sp[131], -0.6666666666666667);
    sp[213] = sp[212] * sp[135];
    sp[214] = (1 + -1 * sp[213]) / std::pow(sp[131], 0.3333333333333333);
    sp[215] = sp[214] * w[1][0];
    sp[216] = sp[211] * w[3][0];
    sp[217] = sp[216] * sp[140];
    sp[218] = sp[217] * (1.0 / sp[142]);
    sp[219] = -1 * sp[218] / sp[142];
    sp[220] = sp[217] + sp[219];
    sp[221] = sp[220] * w[2][0];
    sp[222] = sp[215] + sp[221];
    sp[223] = sp[222] * sp[177];
    sp[224] = sp[208] + sp[223];
    sp[225] = sp[121] * sp[116];
    sp[226] = sp[110] * (-1 * sp[83]);
    sp[227] = sp[225] + sp[226];
    sp[228] = 0.3333333333333333 * sp[227] * std::pow(sp[131], -0.6666666666666667);
    sp[229] = sp[228] * sp[135];
    sp[230] = -1 * sp[229] / std::pow(sp[131], 0.3333333333333333);
    sp[231] = sp[230] * w[1][0];
    sp[232] = sp[227] * w[3][0];
    sp[233] = sp[232] * sp[140];
    sp[234] = sp[233] * (1.0 / sp[142]);
    sp[235] = -1 * sp[234] / sp[142];
    sp[236] = sp[233] + sp[235];
    sp[237] = sp[236] * w[2][0];
    sp[238] = sp[231] + sp[237];
    sp[239] = sp[238] * sp[193];
    sp[240] = sp[224] + sp[239];
    sp[241] = sp[240] * sp[75];
    sp[242] = sp[196] + sp[241];
    sp[243] = 0.3333333333333333 * sp[129] * std::pow(sp[131], -0.6666666666666667);
    sp[244] = sp[243] * sp[135];
    sp[245] = -1 * sp[244] / std::pow(sp[131], 0.3333333333333333);
    sp[246] = sp[245] * w[1][0];
    sp[247] = sp[129] * w[3][0];
    sp[248] = sp[247] * sp[140];
    sp[249] = sp[248] * (1.0 / sp[142]);
    sp[250] = -1 * sp[249] / sp[142];
    sp[251] = sp[248] + sp[250];
    sp[252] = sp[251] * w[2][0];
    sp[253] = sp[246] + sp[252];
    sp[254] = sp[253] * sp[162];
    sp[255] = sp[238] * sp[177];
    sp[256] = sp[254] + sp[255];
    sp[257] = sp[110] * sp[77];
    sp[258] = sp[116] * (-1 * sp[116]);
    sp[259] = sp[257] + sp[258];
    sp[260] = 0.3333333333333333 * sp[259] * std::pow(sp[131], -0.6666666666666667);
    sp[261] = sp[260] * sp[135];
    sp[262] = (1 + -1 * sp[261]) / std::pow(sp[131], 0.3333333333333333);
    sp[263] = sp[262] * w[1][0];
    sp[264] = sp[259] * w[3][0];
    sp[265] = sp[264] * sp[140];
    sp[266] = sp[265] * (1.0 / sp[142]);
    sp[267] = -1 * sp[266] / sp[142];
    sp[268] = sp[265] + sp[267];
    sp[269] = sp[268] * w[2][0];
    sp[270] = sp[263] + sp[269];
    sp[271] = sp[270] * sp[193];
    sp[272] = sp[256] + sp[271];
    sp[273] = (1 + sp[43]) * sp[272];
    sp[274] = sp[242] + sp[273];
    sp[275] = (1 + sp[62]) * (1.0 / sp[161]);
    sp[276] = sp[222] * sp[275];
    sp[277] = sp[101] * (1.0 / sp[161]);
    sp[278] = sp[207] * sp[277];
    sp[279] = sp[276] + sp[278];
    sp[280] = sp[36] * (1.0 / sp[161]);
    sp[281] = sp[238] * sp[280];
    sp[282] = sp[279] + sp[281];
    sp[283] = (1 + sp[62]) * sp[282];
    sp[284] = sp[176] * sp[275];
    sp[285] = sp[147] * sp[277];
    sp[286] = sp[284] + sp[285];
    sp[287] = sp[192] * sp[280];
    sp[288] = sp[286] + sp[287];
    sp[289] = sp[288] * sp[101];
    sp[290] = sp[283] + sp[289];
    sp[291] = sp[238] * sp[275];
    sp[292] = sp[253] * sp[277];
    sp[293] = sp[291] + sp[292];
    sp[294] = sp[270] * sp[280];
    sp[295] = sp[293] + sp[294];
    sp[296] = sp[295] * sp[36];
    sp[297] = sp[290] + sp[296];
    sp[298] = std::pow(sp[274], 2) + std::pow(sp[297], 2);
    sp[299] = (1 + sp[95]) * (1.0 / sp[161]);
    sp[300] = sp[147] * sp[299];
    sp[301] = sp[68] * (1.0 / sp[161]);
    sp[302] = sp[176] * sp[301];
    sp[303] = sp[300] + sp[302];
    sp[304] = sp[30] * (1.0 / sp[161]);
    sp[305] = sp[192] * sp[304];
    sp[306] = sp[303] + sp[305];
    sp[307] = (1 + sp[95]) * sp[306];
    sp[308] = sp[207] * sp[299];
    sp[309] = sp[222] * sp[301];
    sp[310] = sp[308] + sp[309];
    sp[311] = sp[238] * sp[304];
    sp[312] = sp[310] + sp[311];
    sp[313] = sp[312] * sp[68];
    sp[314] = sp[307] + sp[313];
    sp[315] = sp[253] * sp[299];
    sp[316] = sp[238] * sp[301];
    sp[317] = sp[315] + sp[316];
    sp[318] = sp[270] * sp[304];
    sp[319] = sp[317] + sp[318];
    sp[320] = sp[319] * sp[30];
    sp[321] = sp[314] + sp[320];
    sp[322] = sp[298] + std::pow(sp[321], 2);
    sp[323] = sp[274] * sp[297];
    sp[324] = sp[322] + -1 * sp[323];
    sp[325] = sp[321] * sp[297];
    sp[326] = sp[324] + -1 * sp[325];
    sp[327] = sp[274] * sp[321];
    sp[328] = sp[326] + -1 * sp[327];
    sp[329] = sp[288] * sp[108];
    sp[330] = sp[282] * sp[75];
    sp[331] = sp[329] + sp[330];
    sp[332] = (1 + sp[43]) * sp[295];
    sp[333] = sp[331] + sp[332];
    sp[334] = (1 + sp[95]) * sp[288];
    sp[335] = sp[282] * sp[68];
    sp[336] = sp[334] + sp[335];
    sp[337] = sp[295] * sp[30];
    sp[338] = sp[336] + sp[337];
    sp[339] = std::pow(sp[333], 2) + std::pow(sp[338], 2);
    sp[340] = (1 + sp[95]) * sp[195];
    sp[341] = sp[240] * sp[68];
    sp[342] = sp[340] + sp[341];
    sp[343] = sp[272] * sp[30];
    sp[344] = sp[342] + sp[343];
    sp[345] = sp[339] + std::pow(sp[344], 2);
    sp[346] = sp[328] + 3 * sp[345];
    sp[347] = std::sqrt(sp[346]);
    sp[348] = std::abs(sp[16]);
    sp[349] = sp[348] * sp[347];
    A[0] = 0.1666666666666667 * sp[349];
}


hyperelasticitybiso_form_0::hyperelasticitybiso_form_0() : ufc::form()
{
    // Do nothing
}

hyperelasticitybiso_form_0::~hyperelasticitybiso_form_0()
{
    // Do nothing
}

const char * hyperelasticitybiso_form_0::signature() const
{
    return "7d3e477679627e7b90b9497aa6291dd4e0e5ae118d2fbdf0258ed50a6518f7cbb3a8c84ad0a748c3283108121ee93b31e9febd363f42bc71c1ffeed4a1f5468b";
}

std::size_t hyperelasticitybiso_form_0::rank() const
{
    return 2;
}

std::size_t hyperelasticitybiso_form_0::num_coefficients() const
{
    return 4;
}

std::size_t hyperelasticitybiso_form_0::original_coefficient_position(std::size_t i) const
{
    if (i >= 4)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 3, 4, 5};
    return position[i];
}

ufc::finite_element * hyperelasticitybiso_form_0::create_coordinate_finite_element() const
{
    return new hyperelasticitybiso_finite_element_3();
}

ufc::dofmap * hyperelasticitybiso_form_0::create_coordinate_dofmap() const
{
    return new hyperelasticitybiso_dofmap_3();
}

ufc::coordinate_mapping * hyperelasticitybiso_form_0::create_coordinate_mapping() const
{
    return new hyperelasticitybiso_coordinate_mapping_3();
}

ufc::finite_element * hyperelasticitybiso_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_3();
    case 1:
        return new hyperelasticitybiso_finite_element_3();
    case 2:
        return new hyperelasticitybiso_finite_element_3();
    case 3:
        return new hyperelasticitybiso_finite_element_0();
    case 4:
        return new hyperelasticitybiso_finite_element_0();
    case 5:
        return new hyperelasticitybiso_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_3();
    case 1:
        return new hyperelasticitybiso_dofmap_3();
    case 2:
        return new hyperelasticitybiso_dofmap_3();
    case 3:
        return new hyperelasticitybiso_dofmap_0();
    case 4:
        return new hyperelasticitybiso_dofmap_0();
    case 5:
        return new hyperelasticitybiso_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t hyperelasticitybiso_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool hyperelasticitybiso_form_0::has_cell_integrals() const
{
    return true;
}

bool hyperelasticitybiso_form_0::has_exterior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_vertex_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_custom_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_cutcell_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_interface_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * hyperelasticitybiso_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * hyperelasticitybiso_form_0::create_default_cell_integral() const
{
    return new hyperelasticitybiso_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_0::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


hyperelasticitybiso_form_1::hyperelasticitybiso_form_1() : ufc::form()
{
    // Do nothing
}

hyperelasticitybiso_form_1::~hyperelasticitybiso_form_1()
{
    // Do nothing
}

const char * hyperelasticitybiso_form_1::signature() const
{
    return "8c16b66892f53c4771bbba690f54a622c94f40e9e9169b72edee0d9317208c17abfc0fe727f7cd7a5a2529e67ee3f8ff109d873244b8d96fb841a95dbb8ab21a";
}

std::size_t hyperelasticitybiso_form_1::rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_form_1::num_coefficients() const
{
    return 6;
}

std::size_t hyperelasticitybiso_form_1::original_coefficient_position(std::size_t i) const
{
    if (i >= 6)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5};
    return position[i];
}

ufc::finite_element * hyperelasticitybiso_form_1::create_coordinate_finite_element() const
{
    return new hyperelasticitybiso_finite_element_3();
}

ufc::dofmap * hyperelasticitybiso_form_1::create_coordinate_dofmap() const
{
    return new hyperelasticitybiso_dofmap_3();
}

ufc::coordinate_mapping * hyperelasticitybiso_form_1::create_coordinate_mapping() const
{
    return new hyperelasticitybiso_coordinate_mapping_3();
}

ufc::finite_element * hyperelasticitybiso_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_3();
    case 1:
        return new hyperelasticitybiso_finite_element_3();
    case 2:
        return new hyperelasticitybiso_finite_element_1();
    case 3:
        return new hyperelasticitybiso_finite_element_1();
    case 4:
        return new hyperelasticitybiso_finite_element_0();
    case 5:
        return new hyperelasticitybiso_finite_element_0();
    case 6:
        return new hyperelasticitybiso_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_3();
    case 1:
        return new hyperelasticitybiso_dofmap_3();
    case 2:
        return new hyperelasticitybiso_dofmap_1();
    case 3:
        return new hyperelasticitybiso_dofmap_1();
    case 4:
        return new hyperelasticitybiso_dofmap_0();
    case 5:
        return new hyperelasticitybiso_dofmap_0();
    case 6:
        return new hyperelasticitybiso_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t hyperelasticitybiso_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_exterior_facet_subdomain_id() const
{
    return 4;
}

std::size_t hyperelasticitybiso_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool hyperelasticitybiso_form_1::has_cell_integrals() const
{
    return true;
}

bool hyperelasticitybiso_form_1::has_exterior_facet_integrals() const
{
    return true;
}

bool hyperelasticitybiso_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_1::has_vertex_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_1::has_custom_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_1::has_cutcell_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_1::has_interface_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * hyperelasticitybiso_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 3:
        return new hyperelasticitybiso_exterior_facet_integral_1_3();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * hyperelasticitybiso_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * hyperelasticitybiso_form_1::create_default_cell_integral() const
{
    return new hyperelasticitybiso_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_1::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_1::create_default_overlap_integral() const
{
    return nullptr;
}


hyperelasticitybiso_form_2::hyperelasticitybiso_form_2() : ufc::form()
{
    // Do nothing
}

hyperelasticitybiso_form_2::~hyperelasticitybiso_form_2()
{
    // Do nothing
}

const char * hyperelasticitybiso_form_2::signature() const
{
    return "9d6c3270f3a03cdd9a4f78b2aabc50d9e569c340874abfdcc6631d1e1387793b84bf80cf97e813d6e8c8faaa5d40a73596a5c48d29f29cd7c8ba7180feb7c8f9";
}

std::size_t hyperelasticitybiso_form_2::rank() const
{
    return 2;
}

std::size_t hyperelasticitybiso_form_2::num_coefficients() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * hyperelasticitybiso_form_2::create_coordinate_finite_element() const
{
    return new hyperelasticitybiso_finite_element_3();
}

ufc::dofmap * hyperelasticitybiso_form_2::create_coordinate_dofmap() const
{
    return new hyperelasticitybiso_dofmap_3();
}

ufc::coordinate_mapping * hyperelasticitybiso_form_2::create_coordinate_mapping() const
{
    return new hyperelasticitybiso_coordinate_mapping_3();
}

ufc::finite_element * hyperelasticitybiso_form_2::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_4();
    case 1:
        return new hyperelasticitybiso_finite_element_4();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_form_2::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_4();
    case 1:
        return new hyperelasticitybiso_dofmap_4();
    default:
        return nullptr;
    }
}

std::size_t hyperelasticitybiso_form_2::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_2::max_overlap_subdomain_id() const
{
    return 0;
}

bool hyperelasticitybiso_form_2::has_cell_integrals() const
{
    return true;
}

bool hyperelasticitybiso_form_2::has_exterior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_interior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_vertex_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_custom_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_cutcell_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_interface_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_2::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * hyperelasticitybiso_form_2::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_2::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_2::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_2::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_2::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_2::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_2::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_2::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * hyperelasticitybiso_form_2::create_default_cell_integral() const
{
    return new hyperelasticitybiso_cell_integral_2_otherwise();
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_2::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_2::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_2::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_2::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_2::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_2::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_2::create_default_overlap_integral() const
{
    return nullptr;
}


hyperelasticitybiso_form_3::hyperelasticitybiso_form_3() : ufc::form()
{
    // Do nothing
}

hyperelasticitybiso_form_3::~hyperelasticitybiso_form_3()
{
    // Do nothing
}

const char * hyperelasticitybiso_form_3::signature() const
{
    return "6bf114f1510195fb3fe66653fc4028e082da65f60a3248cb0e3f2bf8845ee3a6236845bee1843cf44f4da7066dcae40862d105a23dc3ca9aa01827e95cc7d619";
}

std::size_t hyperelasticitybiso_form_3::rank() const
{
    return 1;
}

std::size_t hyperelasticitybiso_form_3::num_coefficients() const
{
    return 4;
}

std::size_t hyperelasticitybiso_form_3::original_coefficient_position(std::size_t i) const
{
    if (i >= 4)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3};
    return position[i];
}

ufc::finite_element * hyperelasticitybiso_form_3::create_coordinate_finite_element() const
{
    return new hyperelasticitybiso_finite_element_3();
}

ufc::dofmap * hyperelasticitybiso_form_3::create_coordinate_dofmap() const
{
    return new hyperelasticitybiso_dofmap_3();
}

ufc::coordinate_mapping * hyperelasticitybiso_form_3::create_coordinate_mapping() const
{
    return new hyperelasticitybiso_coordinate_mapping_3();
}

ufc::finite_element * hyperelasticitybiso_form_3::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_finite_element_4();
    case 1:
        return new hyperelasticitybiso_finite_element_3();
    case 2:
        return new hyperelasticitybiso_finite_element_0();
    case 3:
        return new hyperelasticitybiso_finite_element_0();
    case 4:
        return new hyperelasticitybiso_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * hyperelasticitybiso_form_3::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new hyperelasticitybiso_dofmap_4();
    case 1:
        return new hyperelasticitybiso_dofmap_3();
    case 2:
        return new hyperelasticitybiso_dofmap_0();
    case 3:
        return new hyperelasticitybiso_dofmap_0();
    case 4:
        return new hyperelasticitybiso_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t hyperelasticitybiso_form_3::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t hyperelasticitybiso_form_3::max_overlap_subdomain_id() const
{
    return 0;
}

bool hyperelasticitybiso_form_3::has_cell_integrals() const
{
    return true;
}

bool hyperelasticitybiso_form_3::has_exterior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_interior_facet_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_vertex_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_custom_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_cutcell_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_interface_integrals() const
{
    return false;
}

bool hyperelasticitybiso_form_3::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * hyperelasticitybiso_form_3::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_3::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_3::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_3::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_3::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_3::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_3::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_3::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * hyperelasticitybiso_form_3::create_default_cell_integral() const
{
    return new hyperelasticitybiso_cell_integral_3_otherwise();
}

ufc::exterior_facet_integral * hyperelasticitybiso_form_3::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * hyperelasticitybiso_form_3::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * hyperelasticitybiso_form_3::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * hyperelasticitybiso_form_3::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * hyperelasticitybiso_form_3::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * hyperelasticitybiso_form_3::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * hyperelasticitybiso_form_3::create_default_overlap_integral() const
{
    return nullptr;
}

